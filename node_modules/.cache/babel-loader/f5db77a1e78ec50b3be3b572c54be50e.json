{"ast":null,"code":"var _toConsumableArray = require(\"/Users/suryanandsunil/Desktop/proto1-arizon/lyo-test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _classCallCheck = require(\"/Users/suryanandsunil/Desktop/proto1-arizon/lyo-test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/suryanandsunil/Desktop/proto1-arizon/lyo-test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar base64url = require('../help/base64url');\n\nvar isDisjoint = require('../help/is_disjoint');\n\nvar isObject = require('../help/is_object');\n\nvar deepClone = require('../help/deep_clone');\n\nvar _require = require('../errors'),\n    JWSInvalid = _require.JWSInvalid;\n\nvar _require2 = require('../jwa'),\n    sign = _require2.sign;\n\nvar getKey = require('../help/get_key');\n\nvar serializers = require('./serializers');\n\nvar PROCESS_RECIPIENT = Symbol('PROCESS_RECIPIENT');\n\nvar Sign = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function Sign(payload) {\n    _classCallCheck(this, Sign);\n\n    if (typeof payload === 'string') {\n      payload = base64url.encode(payload);\n    } else if (Buffer.isBuffer(payload)) {\n      payload = base64url.encodeBuffer(payload);\n      this._binary = true;\n    } else if (isObject(payload)) {\n      payload = base64url.JSON.encode(payload);\n    } else {\n      throw new TypeError('payload argument must be a Buffer, string or an object');\n    }\n\n    this._payload = payload;\n    this._recipients = [];\n  }\n  /*\n   * @public\n   */\n\n\n  _createClass(Sign, [{\n    key: \"recipient\",\n    value: function recipient(key, protectedHeader, unprotectedHeader) {\n      key = getKey(key);\n\n      if (protectedHeader !== undefined && !isObject(protectedHeader)) {\n        throw new TypeError('protectedHeader argument must be a plain object when provided');\n      }\n\n      if (unprotectedHeader !== undefined && !isObject(unprotectedHeader)) {\n        throw new TypeError('unprotectedHeader argument must be a plain object when provided');\n      }\n\n      if (!isDisjoint(protectedHeader, unprotectedHeader)) {\n        throw new JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint');\n      }\n\n      this._recipients.push({\n        key: key,\n        protectedHeader: protectedHeader ? deepClone(protectedHeader) : undefined,\n        unprotectedHeader: unprotectedHeader ? deepClone(unprotectedHeader) : undefined\n      });\n\n      return this;\n    }\n    /*\n     * @private\n     */\n\n  }, {\n    key: PROCESS_RECIPIENT,\n    value: function value(recipient, first) {\n      var key = recipient.key,\n          protectedHeader = recipient.protectedHeader,\n          unprotectedHeader = recipient.unprotectedHeader;\n\n      if (key.use === 'enc') {\n        throw new TypeError('a key with \"use\":\"enc\" is not usable for signing');\n      }\n\n      var joseHeader = {\n        protected: protectedHeader || {},\n        unprotected: unprotectedHeader || {}\n      };\n      var alg = joseHeader.protected.alg || joseHeader.unprotected.alg;\n\n      if (!alg) {\n        alg = key.alg || _toConsumableArray(key.algorithms('sign'))[0];\n\n        if (recipient.protectedHeader) {\n          joseHeader.protected.alg = recipient.protectedHeader.alg = alg;\n        } else {\n          joseHeader.protected = recipient.protectedHeader = {\n            alg: alg\n          };\n        }\n      }\n\n      if (!alg) {\n        throw new JWSInvalid('could not resolve a usable \"alg\" for a recipient');\n      }\n\n      recipient.header = unprotectedHeader;\n      recipient.protected = Object.keys(joseHeader.protected).length ? base64url.JSON.encode(joseHeader.protected) : '';\n\n      if (first && joseHeader.protected.crit && joseHeader.protected.crit.includes('b64') && joseHeader.protected.b64 === false) {\n        if (this._binary) {\n          this._payload = base64url.decodeToBuffer(this._payload);\n        } else {\n          this._payload = base64url.decode(this._payload);\n        }\n      }\n\n      var data = Buffer.concat([Buffer.from(recipient.protected || ''), Buffer.from('.'), Buffer.from(this._payload)]);\n      recipient.signature = base64url.encodeBuffer(sign(alg, key, data));\n    }\n    /*\n     * @public\n     */\n\n  }, {\n    key: \"sign\",\n    value: function sign(serialization) {\n      var _this = this;\n\n      var serializer = serializers[serialization];\n\n      if (!serializer) {\n        throw new TypeError('serialization must be one of \"compact\", \"flattened\", \"general\"');\n      }\n\n      if (!this._recipients.length) {\n        throw new JWSInvalid('missing recipients');\n      }\n\n      serializer.validate(this, this._recipients);\n\n      this._recipients.forEach(function (recipient, i) {\n        _this[PROCESS_RECIPIENT](recipient, i === 0);\n      });\n\n      return serializer(this._payload, this._recipients);\n    }\n  }]);\n\n  return Sign;\n}();\n\nmodule.exports = Sign;","map":{"version":3,"sources":["/Users/suryanandsunil/Desktop/proto1-arizon/lyo-test/node_modules/jose/lib/jws/sign.js"],"names":["base64url","require","isDisjoint","isObject","deepClone","JWSInvalid","sign","getKey","serializers","PROCESS_RECIPIENT","Symbol","Sign","payload","encode","Buffer","isBuffer","encodeBuffer","_binary","JSON","TypeError","_payload","_recipients","key","protectedHeader","unprotectedHeader","undefined","push","recipient","first","use","joseHeader","protected","unprotected","alg","algorithms","header","Object","keys","length","crit","includes","b64","decodeToBuffer","decode","data","concat","from","signature","serialization","serializer","validate","forEach","i","module","exports"],"mappings":"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","sourcesContent":["const base64url = require('../help/base64url')\nconst isDisjoint = require('../help/is_disjoint')\nconst isObject = require('../help/is_object')\nconst deepClone = require('../help/deep_clone')\nconst { JWSInvalid } = require('../errors')\nconst { sign } = require('../jwa')\nconst getKey = require('../help/get_key')\n\nconst serializers = require('./serializers')\n\nconst PROCESS_RECIPIENT = Symbol('PROCESS_RECIPIENT')\n\nclass Sign {\n  constructor (payload) {\n    if (typeof payload === 'string') {\n      payload = base64url.encode(payload)\n    } else if (Buffer.isBuffer(payload)) {\n      payload = base64url.encodeBuffer(payload)\n      this._binary = true\n    } else if (isObject(payload)) {\n      payload = base64url.JSON.encode(payload)\n    } else {\n      throw new TypeError('payload argument must be a Buffer, string or an object')\n    }\n\n    this._payload = payload\n    this._recipients = []\n  }\n\n  /*\n   * @public\n   */\n  recipient (key, protectedHeader, unprotectedHeader) {\n    key = getKey(key)\n\n    if (protectedHeader !== undefined && !isObject(protectedHeader)) {\n      throw new TypeError('protectedHeader argument must be a plain object when provided')\n    }\n\n    if (unprotectedHeader !== undefined && !isObject(unprotectedHeader)) {\n      throw new TypeError('unprotectedHeader argument must be a plain object when provided')\n    }\n\n    if (!isDisjoint(protectedHeader, unprotectedHeader)) {\n      throw new JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint')\n    }\n\n    this._recipients.push({\n      key,\n      protectedHeader: protectedHeader ? deepClone(protectedHeader) : undefined,\n      unprotectedHeader: unprotectedHeader ? deepClone(unprotectedHeader) : undefined\n    })\n\n    return this\n  }\n\n  /*\n   * @private\n   */\n  [PROCESS_RECIPIENT] (recipient, first) {\n    const { key, protectedHeader, unprotectedHeader } = recipient\n\n    if (key.use === 'enc') {\n      throw new TypeError('a key with \"use\":\"enc\" is not usable for signing')\n    }\n\n    const joseHeader = {\n      protected: protectedHeader || {},\n      unprotected: unprotectedHeader || {}\n    }\n\n    let alg = joseHeader.protected.alg || joseHeader.unprotected.alg\n\n    if (!alg) {\n      alg = key.alg || [...key.algorithms('sign')][0]\n      if (recipient.protectedHeader) {\n        joseHeader.protected.alg = recipient.protectedHeader.alg = alg\n      } else {\n        joseHeader.protected = recipient.protectedHeader = { alg }\n      }\n    }\n\n    if (!alg) {\n      throw new JWSInvalid('could not resolve a usable \"alg\" for a recipient')\n    }\n\n    recipient.header = unprotectedHeader\n    recipient.protected = Object.keys(joseHeader.protected).length ? base64url.JSON.encode(joseHeader.protected) : ''\n\n    if (first && joseHeader.protected.crit && joseHeader.protected.crit.includes('b64') && joseHeader.protected.b64 === false) {\n      if (this._binary) {\n        this._payload = base64url.decodeToBuffer(this._payload)\n      } else {\n        this._payload = base64url.decode(this._payload)\n      }\n    }\n\n    const data = Buffer.concat([\n      Buffer.from(recipient.protected || ''),\n      Buffer.from('.'),\n      Buffer.from(this._payload)\n    ])\n\n    recipient.signature = base64url.encodeBuffer(sign(alg, key, data))\n  }\n\n  /*\n   * @public\n   */\n  sign (serialization) {\n    const serializer = serializers[serialization]\n    if (!serializer) {\n      throw new TypeError('serialization must be one of \"compact\", \"flattened\", \"general\"')\n    }\n\n    if (!this._recipients.length) {\n      throw new JWSInvalid('missing recipients')\n    }\n\n    serializer.validate(this, this._recipients)\n\n    this._recipients.forEach((recipient, i) => {\n      this[PROCESS_RECIPIENT](recipient, i === 0)\n    })\n\n    return serializer(this._payload, this._recipients)\n  }\n}\n\nmodule.exports = Sign\n"]},"metadata":{},"sourceType":"script"}