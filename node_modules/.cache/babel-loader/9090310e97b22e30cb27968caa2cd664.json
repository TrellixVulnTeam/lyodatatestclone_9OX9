{"ast":null,"code":"\"use strict\";\n/*!\n * Copyright 2017 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar _regeneratorRuntime = require(\"/Users/suryanandsunil/Desktop/proto1-arizon/lyo-test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/suryanandsunil/Desktop/proto1-arizon/lyo-test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _slicedToArray = require(\"/Users/suryanandsunil/Desktop/proto1-arizon/lyo-test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _classCallCheck = require(\"/Users/suryanandsunil/Desktop/proto1-arizon/lyo-test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/suryanandsunil/Desktop/proto1-arizon/lyo-test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar backoff_1 = require(\"./backoff\");\n\nvar logger_1 = require(\"./logger\");\n\nvar path_1 = require(\"./path\");\n\nvar reference_1 = require(\"./reference\");\n\nvar util_1 = require(\"./util\");\n\nvar validate_1 = require(\"./validate\");\n\nvar document_reader_1 = require(\"./document-reader\");\n/*!\n * Error message for transactional reads that were executed after performing\n * writes.\n */\n\n\nvar READ_AFTER_WRITE_ERROR_MSG = 'Firestore transactions require all reads to be executed before all writes.';\n/**\n * A reference to a transaction.\n *\n * The Transaction object passed to a transaction's updateFunction provides\n * the methods to read and write data within the transaction context. See\n * [runTransaction()]{@link Firestore#runTransaction}.\n *\n * @class Transaction\n */\n\nvar Transaction = /*#__PURE__*/function () {\n  /**\n   * @hideconstructor\n   *\n   * @param firestore The Firestore Database client.\n   * @param requestTag A unique client-assigned identifier for the scope of\n   * this transaction.\n   */\n  function Transaction(firestore, requestTag) {\n    _classCallCheck(this, Transaction);\n\n    this._firestore = firestore;\n    this._writeBatch = firestore.batch();\n    this._requestTag = requestTag;\n    this._backoff = new backoff_1.ExponentialBackoff();\n  }\n  /**\n   * Retrieve a document or a query result from the database. Holds a\n   * pessimistic lock on all returned documents.\n   *\n   * @param {DocumentReference|Query} refOrQuery The document or query to\n   * return.\n   * @returns {Promise} A Promise that resolves with a DocumentSnapshot or\n   * QuerySnapshot for the returned documents.\n   *\n   * @example\n   * firestore.runTransaction(transaction => {\n   *   let documentRef = firestore.doc('col/doc');\n   *   return transaction.get(documentRef).then(doc => {\n   *     if (doc.exists) {\n   *       transaction.update(documentRef, { count: doc.get('count') + 1 });\n   *     } else {\n   *       transaction.create(documentRef, { count: 1 });\n   *     }\n   *   });\n   * });\n   */\n\n\n  _createClass(Transaction, [{\n    key: \"get\",\n    value: function get(refOrQuery) {\n      if (!this._writeBatch.isEmpty) {\n        throw new Error(READ_AFTER_WRITE_ERROR_MSG);\n      }\n\n      if (refOrQuery instanceof reference_1.DocumentReference) {\n        var documentReader = new document_reader_1.DocumentReader(this._firestore, [refOrQuery]);\n        documentReader.transactionId = this._transactionId;\n        return documentReader.get(this._requestTag).then(function (_ref) {\n          var _ref2 = _slicedToArray(_ref, 1),\n              res = _ref2[0];\n\n          return res;\n        });\n      }\n\n      if (refOrQuery instanceof reference_1.Query) {\n        return refOrQuery._get(this._transactionId);\n      }\n\n      throw new Error('Value for argument \"refOrQuery\" must be a DocumentReference or a Query.');\n    }\n    /**\n     * Retrieves multiple documents from Firestore. Holds a pessimistic lock on\n     * all returned documents.\n     *\n     * The first argument is required and must be of type `DocumentReference`\n     * followed by any additional `DocumentReference` documents. If used, the\n     * optional `ReadOptions` must be the last argument.\n     *\n     * @param {...DocumentReference|ReadOptions} documentRefsOrReadOptions The\n     * `DocumentReferences` to receive, followed by an optional field mask.\n     * @returns {Promise<Array.<DocumentSnapshot>>} A Promise that\n     * contains an array with the resulting document snapshots.\n     *\n     * @example\n     * let firstDoc = firestore.doc('col/doc1');\n     * let secondDoc = firestore.doc('col/doc2');\n     * let resultDoc = firestore.doc('col/doc3');\n     *\n     * firestore.runTransaction(transaction => {\n     *   return transaction.getAll(firstDoc, secondDoc).then(docs => {\n     *     transaction.set(resultDoc, {\n     *       sum: docs[0].get('count') + docs[1].get('count')\n     *     });\n     *   });\n     * });\n     */\n\n  }, {\n    key: \"getAll\",\n    value: function getAll() {\n      if (!this._writeBatch.isEmpty) {\n        throw new Error(READ_AFTER_WRITE_ERROR_MSG);\n      }\n\n      for (var _len = arguments.length, documentRefsOrReadOptions = new Array(_len), _key = 0; _key < _len; _key++) {\n        documentRefsOrReadOptions[_key] = arguments[_key];\n      }\n\n      validate_1.validateMinNumberOfArguments('Transaction.getAll', documentRefsOrReadOptions, 1);\n\n      var _parseGetAllArguments = parseGetAllArguments(documentRefsOrReadOptions),\n          documents = _parseGetAllArguments.documents,\n          fieldMask = _parseGetAllArguments.fieldMask;\n\n      var documentReader = new document_reader_1.DocumentReader(this._firestore, documents);\n      documentReader.fieldMask = fieldMask || undefined;\n      documentReader.transactionId = this._transactionId;\n      return documentReader.get(this._requestTag);\n    }\n    /**\n     * Create the document referred to by the provided\n     * [DocumentReference]{@link DocumentReference}. The operation will\n     * fail the transaction if a document exists at the specified location.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * created.\n     * @param {DocumentData} data The object data to serialize as the document.\n     * @returns {Transaction} This Transaction instance. Used for\n     * chaining method calls.\n     *\n     * @example\n     * firestore.runTransaction(transaction => {\n     *   let documentRef = firestore.doc('col/doc');\n     *   return transaction.get(documentRef).then(doc => {\n     *     if (!doc.exists) {\n     *       transaction.create(documentRef, { foo: 'bar' });\n     *     }\n     *   });\n     * });\n     */\n\n  }, {\n    key: \"create\",\n    value: function create(documentRef, data) {\n      this._writeBatch.create(documentRef, data);\n\n      return this;\n    }\n    /**\n     * Writes to the document referred to by the provided\n     * [DocumentReference]{@link DocumentReference}. If the document\n     * does not exist yet, it will be created. If you pass\n     * [SetOptions]{@link SetOptions}, the provided data can be merged into the\n     * existing document.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * set.\n     * @param {T|Partial<T>} data The object to serialize as the document.\n     * @param {SetOptions=} options An object to configure the set behavior.\n     * @param {boolean=} options.merge - If true, set() merges the values\n     * specified in its data argument. Fields omitted from this set() call\n     * remain untouched.\n     * @param {Array.<string|FieldPath>=} options.mergeFields - If provided,\n     * set() only replaces the specified field paths. Any field path that is not\n     * specified is ignored and remains untouched.\n     * @returns {Transaction} This Transaction instance. Used for\n     * chaining method calls.\n     *\n     * @example\n     * firestore.runTransaction(transaction => {\n     *   let documentRef = firestore.doc('col/doc');\n     *   transaction.set(documentRef, { foo: 'bar' });\n     *   return Promise.resolve();\n     * });\n     */\n\n  }, {\n    key: \"set\",\n    value: function set(documentRef, data, options) {\n      this._writeBatch.set(documentRef, data, options);\n\n      return this;\n    }\n    /**\n     * Updates fields in the document referred to by the provided\n     * [DocumentReference]{@link DocumentReference}. The update will\n     * fail if applied to a document that does not exist.\n     *\n     * The update() method accepts either an object with field paths encoded as\n     * keys and field values encoded as values, or a variable number of arguments\n     * that alternate between field paths and field values. Nested fields can be\n     * updated by providing dot-separated field path strings or by providing\n     * FieldPath objects.\n     *\n     * A Precondition restricting this update can be specified as the last\n     * argument.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * updated.\n     * @param {UpdateData|string|FieldPath} dataOrField An object\n     * containing the fields and values with which to update the document\n     * or the path of the first field to update.\n     * @param {\n     * ...(Precondition|*|string|FieldPath)} preconditionOrValues -\n     * An alternating list of field paths and values to update or a Precondition\n     * to to enforce on this update.\n     * @returns {Transaction} This Transaction instance. Used for\n     * chaining method calls.\n     *\n     * @example\n     * firestore.runTransaction(transaction => {\n     *   let documentRef = firestore.doc('col/doc');\n     *   return transaction.get(documentRef).then(doc => {\n     *     if (doc.exists) {\n     *       transaction.update(documentRef, { count: doc.get('count') + 1 });\n     *     } else {\n     *       transaction.create(documentRef, { count: 1 });\n     *     }\n     *   });\n     * });\n     */\n\n  }, {\n    key: \"update\",\n    value: function update(documentRef, dataOrField) {\n      var _this$_writeBatch;\n\n      for (var _len2 = arguments.length, preconditionOrValues = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n        preconditionOrValues[_key2 - 2] = arguments[_key2];\n      }\n\n      // eslint-disable-next-line prefer-rest-params\n      validate_1.validateMinNumberOfArguments('Transaction.update', arguments, 2);\n\n      (_this$_writeBatch = this._writeBatch).update.apply(_this$_writeBatch, [documentRef, dataOrField].concat(preconditionOrValues));\n\n      return this;\n    }\n    /**\n     * Deletes the document referred to by the provided [DocumentReference]\n     * {@link DocumentReference}.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * deleted.\n     * @param {Precondition=} precondition A precondition to enforce for this\n     * delete.\n     * @param {Timestamp=} precondition.lastUpdateTime If set, enforces that the\n     * document was last updated at lastUpdateTime. Fails the transaction if the\n     * document doesn't exist or was last updated at a different time.\n     * @param {boolean=} precondition.exists If set, enforces that the target\n     * document must or must not exist.\n     * @returns {Transaction} This Transaction instance. Used for\n     * chaining method calls.\n     *\n     * @example\n     * firestore.runTransaction(transaction => {\n     *   let documentRef = firestore.doc('col/doc');\n     *   transaction.delete(documentRef);\n     *   return Promise.resolve();\n     * });\n     */\n\n  }, {\n    key: \"delete\",\n    value: function _delete(documentRef, precondition) {\n      this._writeBatch.delete(documentRef, precondition);\n\n      return this;\n    }\n    /**\n     * Starts a transaction and obtains the transaction id from the server.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"begin\",\n    value: function begin(readOnly, readTime) {\n      var _this = this;\n\n      var _a;\n\n      var request = {\n        database: this._firestore.formattedName\n      };\n\n      if (readOnly) {\n        request.options = {\n          readOnly: {\n            readTime: (_a = readTime === null || readTime === void 0 ? void 0 : readTime.toProto()) === null || _a === void 0 ? void 0 : _a.timestampValue\n          }\n        };\n      } else if (this._transactionId) {\n        request.options = {\n          readWrite: {\n            retryTransaction: this._transactionId\n          }\n        };\n      }\n\n      return this._firestore.request('beginTransaction', request, this._requestTag).then(function (resp) {\n        _this._transactionId = resp.transaction;\n      });\n    }\n    /**\n     * Commits all queued-up changes in this transaction and releases all locks.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"commit\",\n    value: function commit() {\n      return this._writeBatch._commit({\n        transactionId: this._transactionId,\n        requestTag: this._requestTag\n      }).then(function () {});\n    }\n    /**\n     * Releases all locks and rolls back this transaction.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"rollback\",\n    value: function rollback() {\n      var request = {\n        database: this._firestore.formattedName,\n        transaction: this._transactionId\n      };\n      return this._firestore.request('rollback', request, this._requestTag);\n    }\n    /**\n     * Executes `updateFunction()` and commits the transaction with retry.\n     *\n     * @private\n     * @param updateFunction The user function to execute within the transaction\n     * context.\n     * @param requestTag A unique client-assigned identifier for the scope of\n     * this transaction.\n     * @param options The user-defined options for this transaction.\n     */\n\n  }, {\n    key: \"runTransaction\",\n    value: function () {\n      var _runTransaction = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(updateFunction, options) {\n        var result, lastError, attempt, promise;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                lastError = undefined;\n                attempt = 0;\n\n              case 2:\n                if (!(attempt < options.maxAttempts)) {\n                  _context.next = 33;\n                  break;\n                }\n\n                _context.prev = 3;\n\n                if (!lastError) {\n                  _context.next = 8;\n                  break;\n                }\n\n                logger_1.logger('Firestore.runTransaction', this._requestTag, 'Retrying transaction after error:', lastError);\n                _context.next = 8;\n                return this.rollback();\n\n              case 8:\n                this._writeBatch._reset();\n\n                _context.next = 11;\n                return this.maybeBackoff(lastError);\n\n              case 11:\n                _context.next = 13;\n                return this.begin(options.readOnly, options.readTime);\n\n              case 13:\n                promise = updateFunction(this);\n\n                if (promise instanceof Promise) {\n                  _context.next = 16;\n                  break;\n                }\n\n                throw new Error('You must return a Promise in your transaction()-callback.');\n\n              case 16:\n                _context.next = 18;\n                return promise;\n\n              case 18:\n                result = _context.sent;\n                _context.next = 21;\n                return this.commit();\n\n              case 21:\n                return _context.abrupt(\"return\", result);\n\n              case 24:\n                _context.prev = 24;\n                _context.t0 = _context[\"catch\"](3);\n                logger_1.logger('Firestore.runTransaction', this._requestTag, 'Rolling back transaction after callback error:', _context.t0);\n                lastError = _context.t0;\n\n                if (!(!this._transactionId || !isRetryableTransactionError(_context.t0))) {\n                  _context.next = 30;\n                  break;\n                }\n\n                return _context.abrupt(\"break\", 33);\n\n              case 30:\n                ++attempt;\n                _context.next = 2;\n                break;\n\n              case 33:\n                logger_1.logger('Firestore.runTransaction', this._requestTag, 'Transaction not eligible for retry, returning error: %s', lastError);\n                _context.next = 36;\n                return this.rollback();\n\n              case 36:\n                return _context.abrupt(\"return\", Promise.reject(lastError));\n\n              case 37:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[3, 24]]);\n      }));\n\n      function runTransaction(_x, _x2) {\n        return _runTransaction.apply(this, arguments);\n      }\n\n      return runTransaction;\n    }()\n    /**\n     * Delays further operations based on the provided error.\n     *\n     * @private\n     * @return A Promise that resolves after the delay expired.\n     */\n\n  }, {\n    key: \"maybeBackoff\",\n    value: function () {\n      var _maybeBackoff = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(error) {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if ((error === null || error === void 0 ? void 0 : error.code) === 8\n                /* RESOURCE_EXHAUSTED */\n                ) {\n                    this._backoff.resetToMax();\n                  }\n\n                _context2.next = 3;\n                return this._backoff.backoffAndWait();\n\n              case 3:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function maybeBackoff(_x3) {\n        return _maybeBackoff.apply(this, arguments);\n      }\n\n      return maybeBackoff;\n    }()\n  }]);\n\n  return Transaction;\n}();\n\nexports.Transaction = Transaction;\n/**\n * Parses the arguments for the `getAll()` call supported by both the Firestore\n * and Transaction class.\n *\n * @private\n * @param documentRefsOrReadOptions An array of document references followed by\n * an optional ReadOptions object.\n */\n\nfunction parseGetAllArguments(documentRefsOrReadOptions) {\n  var documents;\n  var readOptions = undefined;\n\n  if (Array.isArray(documentRefsOrReadOptions[0])) {\n    throw new Error('getAll() no longer accepts an array as its first argument. ' + 'Please unpack your array and call getAll() with individual arguments.');\n  }\n\n  if (documentRefsOrReadOptions.length > 0 && util_1.isPlainObject(documentRefsOrReadOptions[documentRefsOrReadOptions.length - 1])) {\n    readOptions = documentRefsOrReadOptions.pop();\n    documents = documentRefsOrReadOptions;\n  } else {\n    documents = documentRefsOrReadOptions;\n  }\n\n  for (var i = 0; i < documents.length; ++i) {\n    reference_1.validateDocumentReference(i, documents[i]);\n  }\n\n  validateReadOptions('options', readOptions, {\n    optional: true\n  });\n  var fieldMask = readOptions && readOptions.fieldMask ? readOptions.fieldMask.map(function (fieldPath) {\n    return path_1.FieldPath.fromArgument(fieldPath);\n  }) : null;\n  return {\n    fieldMask: fieldMask,\n    documents: documents\n  };\n}\n\nexports.parseGetAllArguments = parseGetAllArguments;\n/**\n * Validates the use of 'options' as ReadOptions and enforces that 'fieldMask'\n * is an array of strings or field paths.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The input to validate.\n * @param options Options that specify whether the ReadOptions can be omitted.\n */\n\nfunction validateReadOptions(arg, value, options) {\n  if (!validate_1.validateOptional(value, options)) {\n    if (!util_1.isObject(value)) {\n      throw new Error(\"\".concat(validate_1.invalidArgumentMessage(arg, 'read option'), \" Input is not an object.'\"));\n    }\n\n    var _options = value;\n\n    if (_options.fieldMask !== undefined) {\n      if (!Array.isArray(_options.fieldMask)) {\n        throw new Error(\"\".concat(validate_1.invalidArgumentMessage(arg, 'read option'), \" \\\"fieldMask\\\" is not an array.\"));\n      }\n\n      for (var i = 0; i < _options.fieldMask.length; ++i) {\n        try {\n          path_1.validateFieldPath(i, _options.fieldMask[i]);\n        } catch (err) {\n          throw new Error(\"\".concat(validate_1.invalidArgumentMessage(arg, 'read option'), \" \\\"fieldMask\\\" is not valid: \").concat(err.message));\n        }\n      }\n    }\n  }\n}\n\nfunction isRetryableTransactionError(error) {\n  if (error.code !== undefined) {\n    // This list is based on https://github.com/firebase/firebase-js-sdk/blob/master/packages/firestore/src/core/transaction_runner.ts#L112\n    switch (error.code) {\n      case 10\n      /* ABORTED */\n      :\n      case 1\n      /* CANCELLED */\n      :\n      case 2\n      /* UNKNOWN */\n      :\n      case 4\n      /* DEADLINE_EXCEEDED */\n      :\n      case 13\n      /* INTERNAL */\n      :\n      case 14\n      /* UNAVAILABLE */\n      :\n      case 16\n      /* UNAUTHENTICATED */\n      :\n      case 8\n      /* RESOURCE_EXHAUSTED */\n      :\n        return true;\n\n      case 3\n      /* INVALID_ARGUMENT */\n      :\n        // The Firestore backend uses \"INVALID_ARGUMENT\" for transactions\n        // IDs that have expired. While INVALID_ARGUMENT is generally not\n        // retryable, we retry this specific case.\n        return !!error.message.match(/transaction has expired/);\n\n      default:\n        return false;\n    }\n  }\n\n  return false;\n}","map":{"version":3,"sources":["/Users/suryanandsunil/Desktop/proto1-arizon/lyo-test/node_modules/@google-cloud/firestore/build/src/transaction.js"],"names":["Object","defineProperty","exports","value","backoff_1","require","logger_1","path_1","reference_1","util_1","validate_1","document_reader_1","READ_AFTER_WRITE_ERROR_MSG","Transaction","firestore","requestTag","_firestore","_writeBatch","batch","_requestTag","_backoff","ExponentialBackoff","refOrQuery","isEmpty","Error","DocumentReference","documentReader","DocumentReader","transactionId","_transactionId","get","then","res","Query","_get","documentRefsOrReadOptions","validateMinNumberOfArguments","parseGetAllArguments","documents","fieldMask","undefined","documentRef","data","create","options","set","dataOrField","preconditionOrValues","arguments","update","precondition","delete","readOnly","readTime","_a","request","database","formattedName","toProto","timestampValue","readWrite","retryTransaction","resp","transaction","_commit","updateFunction","lastError","attempt","maxAttempts","logger","rollback","_reset","maybeBackoff","begin","promise","Promise","result","commit","isRetryableTransactionError","reject","error","code","resetToMax","backoffAndWait","readOptions","Array","isArray","length","isPlainObject","pop","i","validateDocumentReference","validateReadOptions","optional","map","fieldPath","FieldPath","fromArgument","arg","validateOptional","isObject","invalidArgumentMessage","validateFieldPath","err","message","match"],"mappings":"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CC,IAArC;;AACA,aAAO,IAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACI,aAAID,WAAJ,EAAiBC,IAAjB,EAAuBE,OAAvB,EAAgC;AAC5B,WAAK3B,WAAL,CAAiB4B,GAAjB,CAAqBJ,WAArB,EAAkCC,IAAlC,EAAwCE,OAAxC;;AACA,aAAO,IAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACI,gBAAOH,WAAP,EAAoBK,WAApB,EAA0D;AAAA;;AAAA,yCAAtBC,oBAAsB;AAAtBA,QAAAA,oBAAsB;AAAA;;AACtD;AACArC,MAAAA,UAAU,CAAC0B,4BAAX,CAAwC,oBAAxC,EAA8DY,SAA9D,EAAyE,CAAzE;;AACA,gCAAK/B,WAAL,EAAiBgC,MAAjB,2BAAwBR,WAAxB,EAAqCK,WAArC,SAAqDC,oBAArD;;AACA,aAAO,IAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACI,iBAAON,WAAP,EAAoBS,YAApB,EAAkC;AAC9B,WAAKjC,WAAL,CAAiBkC,MAAjB,CAAwBV,WAAxB,EAAqCS,YAArC;;AACA,aAAO,IAAP;AACH;AACD;AACJ;AACA;AACA;AACA;;;;WACI,eAAME,QAAN,EAAgBC,QAAhB,EAA0B;AAAA;;AACtB,UAAIC,EAAJ;;AACA,UAAMC,OAAO,GAAG;AACZC,QAAAA,QAAQ,EAAE,KAAKxC,UAAL,CAAgByC;AADd,OAAhB;;AAGA,UAAIL,QAAJ,EAAc;AACVG,QAAAA,OAAO,CAACX,OA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","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2017 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst backoff_1 = require(\"./backoff\");\nconst logger_1 = require(\"./logger\");\nconst path_1 = require(\"./path\");\nconst reference_1 = require(\"./reference\");\nconst util_1 = require(\"./util\");\nconst validate_1 = require(\"./validate\");\nconst document_reader_1 = require(\"./document-reader\");\n/*!\n * Error message for transactional reads that were executed after performing\n * writes.\n */\nconst READ_AFTER_WRITE_ERROR_MSG = 'Firestore transactions require all reads to be executed before all writes.';\n/**\n * A reference to a transaction.\n *\n * The Transaction object passed to a transaction's updateFunction provides\n * the methods to read and write data within the transaction context. See\n * [runTransaction()]{@link Firestore#runTransaction}.\n *\n * @class Transaction\n */\nclass Transaction {\n    /**\n     * @hideconstructor\n     *\n     * @param firestore The Firestore Database client.\n     * @param requestTag A unique client-assigned identifier for the scope of\n     * this transaction.\n     */\n    constructor(firestore, requestTag) {\n        this._firestore = firestore;\n        this._writeBatch = firestore.batch();\n        this._requestTag = requestTag;\n        this._backoff = new backoff_1.ExponentialBackoff();\n    }\n    /**\n     * Retrieve a document or a query result from the database. Holds a\n     * pessimistic lock on all returned documents.\n     *\n     * @param {DocumentReference|Query} refOrQuery The document or query to\n     * return.\n     * @returns {Promise} A Promise that resolves with a DocumentSnapshot or\n     * QuerySnapshot for the returned documents.\n     *\n     * @example\n     * firestore.runTransaction(transaction => {\n     *   let documentRef = firestore.doc('col/doc');\n     *   return transaction.get(documentRef).then(doc => {\n     *     if (doc.exists) {\n     *       transaction.update(documentRef, { count: doc.get('count') + 1 });\n     *     } else {\n     *       transaction.create(documentRef, { count: 1 });\n     *     }\n     *   });\n     * });\n     */\n    get(refOrQuery) {\n        if (!this._writeBatch.isEmpty) {\n            throw new Error(READ_AFTER_WRITE_ERROR_MSG);\n        }\n        if (refOrQuery instanceof reference_1.DocumentReference) {\n            const documentReader = new document_reader_1.DocumentReader(this._firestore, [refOrQuery]);\n            documentReader.transactionId = this._transactionId;\n            return documentReader.get(this._requestTag).then(([res]) => res);\n        }\n        if (refOrQuery instanceof reference_1.Query) {\n            return refOrQuery._get(this._transactionId);\n        }\n        throw new Error('Value for argument \"refOrQuery\" must be a DocumentReference or a Query.');\n    }\n    /**\n     * Retrieves multiple documents from Firestore. Holds a pessimistic lock on\n     * all returned documents.\n     *\n     * The first argument is required and must be of type `DocumentReference`\n     * followed by any additional `DocumentReference` documents. If used, the\n     * optional `ReadOptions` must be the last argument.\n     *\n     * @param {...DocumentReference|ReadOptions} documentRefsOrReadOptions The\n     * `DocumentReferences` to receive, followed by an optional field mask.\n     * @returns {Promise<Array.<DocumentSnapshot>>} A Promise that\n     * contains an array with the resulting document snapshots.\n     *\n     * @example\n     * let firstDoc = firestore.doc('col/doc1');\n     * let secondDoc = firestore.doc('col/doc2');\n     * let resultDoc = firestore.doc('col/doc3');\n     *\n     * firestore.runTransaction(transaction => {\n     *   return transaction.getAll(firstDoc, secondDoc).then(docs => {\n     *     transaction.set(resultDoc, {\n     *       sum: docs[0].get('count') + docs[1].get('count')\n     *     });\n     *   });\n     * });\n     */\n    getAll(...documentRefsOrReadOptions) {\n        if (!this._writeBatch.isEmpty) {\n            throw new Error(READ_AFTER_WRITE_ERROR_MSG);\n        }\n        validate_1.validateMinNumberOfArguments('Transaction.getAll', documentRefsOrReadOptions, 1);\n        const { documents, fieldMask } = parseGetAllArguments(documentRefsOrReadOptions);\n        const documentReader = new document_reader_1.DocumentReader(this._firestore, documents);\n        documentReader.fieldMask = fieldMask || undefined;\n        documentReader.transactionId = this._transactionId;\n        return documentReader.get(this._requestTag);\n    }\n    /**\n     * Create the document referred to by the provided\n     * [DocumentReference]{@link DocumentReference}. The operation will\n     * fail the transaction if a document exists at the specified location.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * created.\n     * @param {DocumentData} data The object data to serialize as the document.\n     * @returns {Transaction} This Transaction instance. Used for\n     * chaining method calls.\n     *\n     * @example\n     * firestore.runTransaction(transaction => {\n     *   let documentRef = firestore.doc('col/doc');\n     *   return transaction.get(documentRef).then(doc => {\n     *     if (!doc.exists) {\n     *       transaction.create(documentRef, { foo: 'bar' });\n     *     }\n     *   });\n     * });\n     */\n    create(documentRef, data) {\n        this._writeBatch.create(documentRef, data);\n        return this;\n    }\n    /**\n     * Writes to the document referred to by the provided\n     * [DocumentReference]{@link DocumentReference}. If the document\n     * does not exist yet, it will be created. If you pass\n     * [SetOptions]{@link SetOptions}, the provided data can be merged into the\n     * existing document.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * set.\n     * @param {T|Partial<T>} data The object to serialize as the document.\n     * @param {SetOptions=} options An object to configure the set behavior.\n     * @param {boolean=} options.merge - If true, set() merges the values\n     * specified in its data argument. Fields omitted from this set() call\n     * remain untouched.\n     * @param {Array.<string|FieldPath>=} options.mergeFields - If provided,\n     * set() only replaces the specified field paths. Any field path that is not\n     * specified is ignored and remains untouched.\n     * @returns {Transaction} This Transaction instance. Used for\n     * chaining method calls.\n     *\n     * @example\n     * firestore.runTransaction(transaction => {\n     *   let documentRef = firestore.doc('col/doc');\n     *   transaction.set(documentRef, { foo: 'bar' });\n     *   return Promise.resolve();\n     * });\n     */\n    set(documentRef, data, options) {\n        this._writeBatch.set(documentRef, data, options);\n        return this;\n    }\n    /**\n     * Updates fields in the document referred to by the provided\n     * [DocumentReference]{@link DocumentReference}. The update will\n     * fail if applied to a document that does not exist.\n     *\n     * The update() method accepts either an object with field paths encoded as\n     * keys and field values encoded as values, or a variable number of arguments\n     * that alternate between field paths and field values. Nested fields can be\n     * updated by providing dot-separated field path strings or by providing\n     * FieldPath objects.\n     *\n     * A Precondition restricting this update can be specified as the last\n     * argument.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * updated.\n     * @param {UpdateData|string|FieldPath} dataOrField An object\n     * containing the fields and values with which to update the document\n     * or the path of the first field to update.\n     * @param {\n     * ...(Precondition|*|string|FieldPath)} preconditionOrValues -\n     * An alternating list of field paths and values to update or a Precondition\n     * to to enforce on this update.\n     * @returns {Transaction} This Transaction instance. Used for\n     * chaining method calls.\n     *\n     * @example\n     * firestore.runTransaction(transaction => {\n     *   let documentRef = firestore.doc('col/doc');\n     *   return transaction.get(documentRef).then(doc => {\n     *     if (doc.exists) {\n     *       transaction.update(documentRef, { count: doc.get('count') + 1 });\n     *     } else {\n     *       transaction.create(documentRef, { count: 1 });\n     *     }\n     *   });\n     * });\n     */\n    update(documentRef, dataOrField, ...preconditionOrValues) {\n        // eslint-disable-next-line prefer-rest-params\n        validate_1.validateMinNumberOfArguments('Transaction.update', arguments, 2);\n        this._writeBatch.update(documentRef, dataOrField, ...preconditionOrValues);\n        return this;\n    }\n    /**\n     * Deletes the document referred to by the provided [DocumentReference]\n     * {@link DocumentReference}.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * deleted.\n     * @param {Precondition=} precondition A precondition to enforce for this\n     * delete.\n     * @param {Timestamp=} precondition.lastUpdateTime If set, enforces that the\n     * document was last updated at lastUpdateTime. Fails the transaction if the\n     * document doesn't exist or was last updated at a different time.\n     * @param {boolean=} precondition.exists If set, enforces that the target\n     * document must or must not exist.\n     * @returns {Transaction} This Transaction instance. Used for\n     * chaining method calls.\n     *\n     * @example\n     * firestore.runTransaction(transaction => {\n     *   let documentRef = firestore.doc('col/doc');\n     *   transaction.delete(documentRef);\n     *   return Promise.resolve();\n     * });\n     */\n    delete(documentRef, precondition) {\n        this._writeBatch.delete(documentRef, precondition);\n        return this;\n    }\n    /**\n     * Starts a transaction and obtains the transaction id from the server.\n     *\n     * @private\n     */\n    begin(readOnly, readTime) {\n        var _a;\n        const request = {\n            database: this._firestore.formattedName,\n        };\n        if (readOnly) {\n            request.options = {\n                readOnly: {\n                    readTime: (_a = readTime === null || readTime === void 0 ? void 0 : readTime.toProto()) === null || _a === void 0 ? void 0 : _a.timestampValue,\n                },\n            };\n        }\n        else if (this._transactionId) {\n            request.options = {\n                readWrite: {\n                    retryTransaction: this._transactionId,\n                },\n            };\n        }\n        return this._firestore\n            .request('beginTransaction', request, this._requestTag)\n            .then(resp => {\n            this._transactionId = resp.transaction;\n        });\n    }\n    /**\n     * Commits all queued-up changes in this transaction and releases all locks.\n     *\n     * @private\n     */\n    commit() {\n        return this._writeBatch\n            ._commit({\n            transactionId: this._transactionId,\n            requestTag: this._requestTag,\n        })\n            .then(() => { });\n    }\n    /**\n     * Releases all locks and rolls back this transaction.\n     *\n     * @private\n     */\n    rollback() {\n        const request = {\n            database: this._firestore.formattedName,\n            transaction: this._transactionId,\n        };\n        return this._firestore.request('rollback', request, this._requestTag);\n    }\n    /**\n     * Executes `updateFunction()` and commits the transaction with retry.\n     *\n     * @private\n     * @param updateFunction The user function to execute within the transaction\n     * context.\n     * @param requestTag A unique client-assigned identifier for the scope of\n     * this transaction.\n     * @param options The user-defined options for this transaction.\n     */\n    async runTransaction(updateFunction, options) {\n        let result;\n        let lastError = undefined;\n        for (let attempt = 0; attempt < options.maxAttempts; ++attempt) {\n            try {\n                if (lastError) {\n                    logger_1.logger('Firestore.runTransaction', this._requestTag, 'Retrying transaction after error:', lastError);\n                    await this.rollback();\n                }\n                this._writeBatch._reset();\n                await this.maybeBackoff(lastError);\n                await this.begin(options.readOnly, options.readTime);\n                const promise = updateFunction(this);\n                if (!(promise instanceof Promise)) {\n                    throw new Error('You must return a Promise in your transaction()-callback.');\n                }\n                result = await promise;\n                await this.commit();\n                return result;\n            }\n            catch (err) {\n                logger_1.logger('Firestore.runTransaction', this._requestTag, 'Rolling back transaction after callback error:', err);\n                lastError = err;\n                if (!this._transactionId || !isRetryableTransactionError(err)) {\n                    break;\n                }\n            }\n        }\n        logger_1.logger('Firestore.runTransaction', this._requestTag, 'Transaction not eligible for retry, returning error: %s', lastError);\n        await this.rollback();\n        return Promise.reject(lastError);\n    }\n    /**\n     * Delays further operations based on the provided error.\n     *\n     * @private\n     * @return A Promise that resolves after the delay expired.\n     */\n    async maybeBackoff(error) {\n        if ((error === null || error === void 0 ? void 0 : error.code) === 8 /* RESOURCE_EXHAUSTED */) {\n            this._backoff.resetToMax();\n        }\n        await this._backoff.backoffAndWait();\n    }\n}\nexports.Transaction = Transaction;\n/**\n * Parses the arguments for the `getAll()` call supported by both the Firestore\n * and Transaction class.\n *\n * @private\n * @param documentRefsOrReadOptions An array of document references followed by\n * an optional ReadOptions object.\n */\nfunction parseGetAllArguments(documentRefsOrReadOptions) {\n    let documents;\n    let readOptions = undefined;\n    if (Array.isArray(documentRefsOrReadOptions[0])) {\n        throw new Error('getAll() no longer accepts an array as its first argument. ' +\n            'Please unpack your array and call getAll() with individual arguments.');\n    }\n    if (documentRefsOrReadOptions.length > 0 &&\n        util_1.isPlainObject(documentRefsOrReadOptions[documentRefsOrReadOptions.length - 1])) {\n        readOptions = documentRefsOrReadOptions.pop();\n        documents = documentRefsOrReadOptions;\n    }\n    else {\n        documents = documentRefsOrReadOptions;\n    }\n    for (let i = 0; i < documents.length; ++i) {\n        reference_1.validateDocumentReference(i, documents[i]);\n    }\n    validateReadOptions('options', readOptions, { optional: true });\n    const fieldMask = readOptions && readOptions.fieldMask\n        ? readOptions.fieldMask.map(fieldPath => path_1.FieldPath.fromArgument(fieldPath))\n        : null;\n    return { fieldMask, documents };\n}\nexports.parseGetAllArguments = parseGetAllArguments;\n/**\n * Validates the use of 'options' as ReadOptions and enforces that 'fieldMask'\n * is an array of strings or field paths.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The input to validate.\n * @param options Options that specify whether the ReadOptions can be omitted.\n */\nfunction validateReadOptions(arg, value, options) {\n    if (!validate_1.validateOptional(value, options)) {\n        if (!util_1.isObject(value)) {\n            throw new Error(`${validate_1.invalidArgumentMessage(arg, 'read option')} Input is not an object.'`);\n        }\n        const options = value;\n        if (options.fieldMask !== undefined) {\n            if (!Array.isArray(options.fieldMask)) {\n                throw new Error(`${validate_1.invalidArgumentMessage(arg, 'read option')} \"fieldMask\" is not an array.`);\n            }\n            for (let i = 0; i < options.fieldMask.length; ++i) {\n                try {\n                    path_1.validateFieldPath(i, options.fieldMask[i]);\n                }\n                catch (err) {\n                    throw new Error(`${validate_1.invalidArgumentMessage(arg, 'read option')} \"fieldMask\" is not valid: ${err.message}`);\n                }\n            }\n        }\n    }\n}\nfunction isRetryableTransactionError(error) {\n    if (error.code !== undefined) {\n        // This list is based on https://github.com/firebase/firebase-js-sdk/blob/master/packages/firestore/src/core/transaction_runner.ts#L112\n        switch (error.code) {\n            case 10 /* ABORTED */:\n            case 1 /* CANCELLED */:\n            case 2 /* UNKNOWN */:\n            case 4 /* DEADLINE_EXCEEDED */:\n            case 13 /* INTERNAL */:\n            case 14 /* UNAVAILABLE */:\n            case 16 /* UNAUTHENTICATED */:\n            case 8 /* RESOURCE_EXHAUSTED */:\n                return true;\n            case 3 /* INVALID_ARGUMENT */:\n                // The Firestore backend uses \"INVALID_ARGUMENT\" for transactions\n                // IDs that have expired. While INVALID_ARGUMENT is generally not\n                // retryable, we retry this specific case.\n                return !!error.message.match(/transaction has expired/);\n            default:\n                return false;\n        }\n    }\n    return false;\n}\n//# sourceMappingURL=transaction.js.map"]},"metadata":{},"sourceType":"script"}