{"ast":null,"code":"var _objectSpread = require(\"/Users/suryanandsunil/Desktop/proto1-arizon/lyo-test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _defineProperty = require(\"/Users/suryanandsunil/Desktop/proto1-arizon/lyo-test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/defineProperty\");\n\nvar _classCallCheck = require(\"/Users/suryanandsunil/Desktop/proto1-arizon/lyo-test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/suryanandsunil/Desktop/proto1-arizon/lyo-test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _require = require('./runtime_support'),\n    keyObjectSupported = _require.keyObjectSupported;\n\nvar _createPublicKey;\n\nvar _createPrivateKey2;\n\nvar createSecretKey;\nvar KeyObject;\nvar asInput;\n\nif (keyObjectSupported) {\n  var _require2 = require('crypto');\n\n  _createPublicKey = _require2.createPublicKey;\n  _createPrivateKey2 = _require2.createPrivateKey;\n  createSecretKey = _require2.createSecretKey;\n  KeyObject = _require2.KeyObject;\n\n  asInput = function asInput(input) {\n    return input;\n  };\n} else {\n  var _require3 = require('os'),\n      EOL = _require3.EOL;\n\n  var errors = require('../errors');\n\n  var isObject = require('./is_object');\n\n  var asn1 = require('./asn1');\n\n  var toInput = Symbol('toInput');\n  var namedCurve = Symbol('namedCurve');\n\n  asInput = function asInput(keyObject, needsPublic) {\n    if (keyObject instanceof KeyObject) {\n      return keyObject[toInput](needsPublic);\n    }\n\n    return createSecretKey(keyObject)[toInput](needsPublic);\n  };\n\n  var pemToDer = function pemToDer(pem) {\n    return Buffer.from(pem.replace(/(?:-----(?:BEGIN|END)(?: (?:RSA|EC))? (?:PRIVATE|PUBLIC) KEY-----|\\s)/g, ''), 'base64');\n  };\n\n  var derToPem = function derToPem(der, label) {\n    return \"-----BEGIN \".concat(label, \"-----\").concat(EOL).concat((der.toString('base64').match(/.{1,64}/g) || []).join(EOL)).concat(EOL, \"-----END \").concat(label, \"-----\");\n  };\n\n  var unsupported = function unsupported(input) {\n    var label = typeof input === 'string' ? input : \"OID \".concat(input.join('.'));\n    throw new errors.JOSENotSupported(\"\".concat(label, \" is not supported in your Node.js runtime version\"));\n  };\n\n  KeyObject = /*#__PURE__*/function () {\n    \"use strict\";\n\n    function KeyObject() {\n      _classCallCheck(this, KeyObject);\n    }\n\n    _createClass(KeyObject, [{\n      key: \"export\",\n      value: function _export() {\n        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n            cipher = _ref.cipher,\n            passphrase = _ref.passphrase,\n            type = _ref.type,\n            format = _ref.format;\n\n        if (this._type === 'secret') {\n          return this._buffer;\n        }\n\n        if (this._type === 'public') {\n          if (this.asymmetricKeyType === 'rsa') {\n            switch (type) {\n              case 'pkcs1':\n                if (format === 'pem') {\n                  return this._pem;\n                }\n\n                return pemToDer(this._pem);\n\n              case 'spki':\n                {\n                  var PublicKeyInfo = asn1.get('PublicKeyInfo');\n                  var pem = PublicKeyInfo.encode({\n                    algorithm: {\n                      algorithm: 'rsaEncryption',\n                      parameters: {\n                        type: 'null'\n                      }\n                    },\n                    publicKey: {\n                      unused: 0,\n                      data: pemToDer(this._pem)\n                    }\n                  }, 'pem', {\n                    label: 'PUBLIC KEY'\n                  });\n                  return format === 'pem' ? pem : pemToDer(pem);\n                }\n\n              default:\n                throw new TypeError(\"The value \".concat(type, \" is invalid for option \\\"type\\\"\"));\n            }\n          }\n\n          if (this.asymmetricKeyType === 'ec') {\n            if (type !== 'spki') {\n              throw new TypeError(\"The value \".concat(type, \" is invalid for option \\\"type\\\"\"));\n            }\n\n            if (format === 'pem') {\n              return this._pem;\n            }\n\n            return pemToDer(this._pem);\n          }\n        }\n\n        if (this._type === 'private') {\n          if (passphrase !== undefined || cipher !== undefined) {\n            throw new errors.JOSENotSupported('encrypted private keys are not supported in your Node.js runtime version');\n          }\n\n          if (type === 'pkcs8') {\n            if (this._pkcs8) {\n              if (format === 'der' && typeof this._pkcs8 === 'string') {\n                return pemToDer(this._pkcs8);\n              }\n\n              if (format === 'pem' && Buffer.isBuffer(this._pkcs8)) {\n                return derToPem(this._pkcs8, 'PRIVATE KEY');\n              }\n\n              return this._pkcs8;\n            }\n\n            if (this.asymmetricKeyType === 'rsa') {\n              var parsed = this._asn1;\n              var RSAPrivateKey = asn1.get('RSAPrivateKey');\n              var privateKey = RSAPrivateKey.encode(parsed);\n              var PrivateKeyInfo = asn1.get('PrivateKeyInfo');\n              var pkcs8 = PrivateKeyInfo.encode({\n                version: 0,\n                privateKey: privateKey,\n                algorithm: {\n                  algorithm: 'rsaEncryption',\n                  parameters: {\n                    type: 'null'\n                  }\n                }\n              });\n              this._pkcs8 = pkcs8;\n              return this.export({\n                type: type,\n                format: format\n              });\n            }\n\n            if (this.asymmetricKeyType === 'ec') {\n              var _parsed = this._asn1;\n              var ECPrivateKey = asn1.get('ECPrivateKey');\n\n              var _privateKey = ECPrivateKey.encode({\n                version: _parsed.version,\n                privateKey: _parsed.privateKey,\n                publicKey: _parsed.publicKey\n              });\n\n              var _PrivateKeyInfo = asn1.get('PrivateKeyInfo');\n\n              var _pkcs = _PrivateKeyInfo.encode({\n                version: 0,\n                privateKey: _privateKey,\n                algorithm: {\n                  algorithm: 'ecPublicKey',\n                  parameters: this._asn1.parameters\n                }\n              });\n\n              this._pkcs8 = _pkcs;\n              return this.export({\n                type: type,\n                format: format\n              });\n            }\n          }\n\n          if (this.asymmetricKeyType === 'rsa' && type === 'pkcs1') {\n            if (format === 'pem') {\n              return this._pem;\n            }\n\n            return pemToDer(this._pem);\n          } else if (this.asymmetricKeyType === 'ec' && type === 'sec1') {\n            if (format === 'pem') {\n              return this._pem;\n            }\n\n            return pemToDer(this._pem);\n          } else {\n            throw new TypeError(\"The value \".concat(type, \" is invalid for option \\\"type\\\"\"));\n          }\n        }\n      }\n    }, {\n      key: \"type\",\n      get: function get() {\n        return this._type;\n      }\n    }, {\n      key: \"asymmetricKeyType\",\n      get: function get() {\n        return this._asymmetricKeyType;\n      }\n    }, {\n      key: \"symmetricKeySize\",\n      get: function get() {\n        return this._symmetricKeySize;\n      }\n    }, {\n      key: toInput,\n      value: function value(needsPublic) {\n        switch (this._type) {\n          case 'secret':\n            return this._buffer;\n\n          case 'public':\n            return this._pem;\n\n          default:\n            if (needsPublic) {\n              if (!('_pub' in this)) {\n                this._pub = _createPublicKey(this);\n              }\n\n              return this._pub[toInput](false);\n            }\n\n            return this._pem;\n        }\n      }\n    }]);\n\n    return KeyObject;\n  }();\n\n  createSecretKey = function createSecretKey(buffer) {\n    if (!Buffer.isBuffer(buffer) || !buffer.length) {\n      throw new TypeError('input must be a non-empty Buffer instance');\n    }\n\n    var keyObject = new KeyObject();\n    keyObject._buffer = Buffer.from(buffer);\n    keyObject._symmetricKeySize = buffer.length;\n    keyObject._type = 'secret';\n    return keyObject;\n  };\n\n  _createPublicKey = function createPublicKey(input) {\n    if (input instanceof KeyObject) {\n      if (input.type !== 'private') {\n        throw new TypeError(\"Invalid key object type \".concat(input.type, \", expected private.\"));\n      }\n\n      switch (input.asymmetricKeyType) {\n        case 'ec':\n          {\n            var PublicKeyInfo = asn1.get('PublicKeyInfo');\n\n            var _key = PublicKeyInfo.encode({\n              algorithm: {\n                algorithm: 'ecPublicKey',\n                parameters: input._asn1.parameters\n              },\n              publicKey: input._asn1.publicKey\n            });\n\n            return _createPublicKey({\n              key: _key,\n              format: 'der',\n              type: 'spki'\n            });\n          }\n\n        case 'rsa':\n          {\n            var RSAPublicKey = asn1.get('RSAPublicKey');\n\n            var _key2 = RSAPublicKey.encode(input._asn1);\n\n            return _createPublicKey({\n              key: _key2,\n              format: 'der',\n              type: 'pkcs1'\n            });\n          }\n      }\n    }\n\n    if (typeof input === 'string' || Buffer.isBuffer(input)) {\n      input = {\n        key: input,\n        format: 'pem'\n      };\n    }\n\n    if (!isObject(input)) {\n      throw new TypeError('input must be a string, Buffer or an object');\n    }\n\n    var _input = input,\n        format = _input.format,\n        passphrase = _input.passphrase;\n    var _input2 = input,\n        key = _input2.key,\n        type = _input2.type;\n\n    if (typeof key !== 'string' && !Buffer.isBuffer(key)) {\n      throw new TypeError('key must be a string or Buffer');\n    }\n\n    if (format !== 'pem' && format !== 'der') {\n      throw new TypeError('format must be one of \"pem\" or \"der\"');\n    }\n\n    var label;\n\n    if (format === 'pem') {\n      key = key.toString();\n\n      switch (key.split(/\\r?\\n/g)[0].toString()) {\n        case '-----BEGIN PUBLIC KEY-----':\n          type = 'spki';\n          label = 'PUBLIC KEY';\n          break;\n\n        case '-----BEGIN RSA PUBLIC KEY-----':\n          type = 'pkcs1';\n          label = 'RSA PUBLIC KEY';\n          break;\n\n        case '-----BEGIN CERTIFICATE-----':\n          throw new errors.JOSENotSupported('X.509 certificates are not supported in your Node.js runtime version');\n\n        case '-----BEGIN PRIVATE KEY-----':\n        case '-----BEGIN EC PRIVATE KEY-----':\n        case '-----BEGIN RSA PRIVATE KEY-----':\n          return _createPublicKey(_createPrivateKey2(key));\n\n        default:\n          throw new TypeError('unknown/unsupported PEM type');\n      }\n    }\n\n    switch (type) {\n      case 'spki':\n        {\n          var _PublicKeyInfo = asn1.get('PublicKeyInfo');\n\n          var parsed = _PublicKeyInfo.decode(key, format, {\n            label: label\n          });\n\n          var _type, keyObject;\n\n          switch (parsed.algorithm.algorithm) {\n            case 'ecPublicKey':\n              {\n                keyObject = new KeyObject();\n                keyObject._asn1 = parsed;\n                keyObject._asymmetricKeyType = 'ec';\n                keyObject._type = 'public';\n                keyObject._pem = _PublicKeyInfo.encode(parsed, 'pem', {\n                  label: 'PUBLIC KEY'\n                });\n                break;\n              }\n\n            case 'rsaEncryption':\n              {\n                _type = 'pkcs1';\n                keyObject = _createPublicKey({\n                  type: _type,\n                  key: parsed.publicKey.data,\n                  format: 'der'\n                });\n                break;\n              }\n\n            default:\n              unsupported(parsed.algorithm.algorithm);\n          }\n\n          return keyObject;\n        }\n\n      case 'pkcs1':\n        {\n          var _RSAPublicKey = asn1.get('RSAPublicKey');\n\n          var _parsed2 = _RSAPublicKey.decode(key, format, {\n            label: label\n          }); // special case when private pkcs1 PEM / DER is used with createPublicKey\n\n\n          if (_parsed2.n === BigInt(0)) {\n            return _createPublicKey(_createPrivateKey2({\n              key: key,\n              format: format,\n              type: type,\n              passphrase: passphrase\n            }));\n          }\n\n          var _keyObject = new KeyObject();\n\n          _keyObject._asn1 = _parsed2;\n          _keyObject._asymmetricKeyType = 'rsa';\n          _keyObject._type = 'public';\n          _keyObject._pem = _RSAPublicKey.encode(_parsed2, 'pem', {\n            label: 'RSA PUBLIC KEY'\n          });\n          return _keyObject;\n        }\n\n      case 'pkcs8':\n      case 'sec1':\n        return _createPublicKey(_createPrivateKey2({\n          format: format,\n          key: key,\n          type: type,\n          passphrase: passphrase\n        }));\n\n      default:\n        throw new TypeError(\"The value \".concat(type, \" is invalid for option \\\"type\\\"\"));\n    }\n  };\n\n  _createPrivateKey2 = function createPrivateKey(input, hints) {\n    if (typeof input === 'string' || Buffer.isBuffer(input)) {\n      input = {\n        key: input,\n        format: 'pem'\n      };\n    }\n\n    if (!isObject(input)) {\n      throw new TypeError('input must be a string, Buffer or an object');\n    }\n\n    var _input3 = input,\n        format = _input3.format,\n        passphrase = _input3.passphrase;\n    var _input4 = input,\n        key = _input4.key,\n        type = _input4.type;\n\n    if (typeof key !== 'string' && !Buffer.isBuffer(key)) {\n      throw new TypeError('key must be a string or Buffer');\n    }\n\n    if (passphrase !== undefined) {\n      throw new errors.JOSENotSupported('encrypted private keys are not supported in your Node.js runtime version');\n    }\n\n    if (format !== 'pem' && format !== 'der') {\n      throw new TypeError('format must be one of \"pem\" or \"der\"');\n    }\n\n    var label;\n\n    if (format === 'pem') {\n      key = key.toString();\n\n      switch (key.split(/\\r?\\n/g)[0].toString()) {\n        case '-----BEGIN PRIVATE KEY-----':\n          type = 'pkcs8';\n          label = 'PRIVATE KEY';\n          break;\n\n        case '-----BEGIN EC PRIVATE KEY-----':\n          type = 'sec1';\n          label = 'EC PRIVATE KEY';\n          break;\n\n        case '-----BEGIN RSA PRIVATE KEY-----':\n          type = 'pkcs1';\n          label = 'RSA PRIVATE KEY';\n          break;\n\n        default:\n          throw new TypeError('unknown/unsupported PEM type');\n      }\n    }\n\n    switch (type) {\n      case 'pkcs8':\n        {\n          var PrivateKeyInfo = asn1.get('PrivateKeyInfo');\n          var parsed = PrivateKeyInfo.decode(key, format, {\n            label: label\n          });\n\n          var _type2, keyObject;\n\n          switch (parsed.algorithm.algorithm) {\n            case 'ecPublicKey':\n              {\n                _type2 = 'sec1';\n                keyObject = _createPrivateKey2({\n                  type: _type2,\n                  key: parsed.privateKey,\n                  format: 'der'\n                }, _defineProperty({}, namedCurve, parsed.algorithm.parameters.value));\n                break;\n              }\n\n            case 'rsaEncryption':\n              {\n                _type2 = 'pkcs1';\n                keyObject = _createPrivateKey2({\n                  type: _type2,\n                  key: parsed.privateKey,\n                  format: 'der'\n                });\n                break;\n              }\n\n            default:\n              unsupported(parsed.algorithm.algorithm);\n          }\n\n          keyObject._pkcs8 = key;\n          return keyObject;\n        }\n\n      case 'pkcs1':\n        {\n          var RSAPrivateKey = asn1.get('RSAPrivateKey');\n\n          var _parsed3 = RSAPrivateKey.decode(key, format, {\n            label: label\n          });\n\n          var _keyObject2 = new KeyObject();\n\n          _keyObject2._asn1 = _parsed3;\n          _keyObject2._asymmetricKeyType = 'rsa';\n          _keyObject2._type = 'private';\n          _keyObject2._pem = RSAPrivateKey.encode(_parsed3, 'pem', {\n            label: 'RSA PRIVATE KEY'\n          });\n          return _keyObject2;\n        }\n\n      case 'sec1':\n        {\n          var ECPrivateKey = asn1.get('ECPrivateKey');\n\n          var _parsed4 = ECPrivateKey.decode(key, format, {\n            label: label\n          });\n\n          if (!('parameters' in _parsed4) && !hints[namedCurve]) {\n            throw new Error('invalid sec1');\n          } else if (!('parameters' in _parsed4)) {\n            _parsed4 = _objectSpread(_objectSpread({}, _parsed4), {}, {\n              parameters: {\n                type: 'namedCurve',\n                value: hints[namedCurve]\n              }\n            });\n          }\n\n          var _keyObject3 = new KeyObject();\n\n          _keyObject3._asn1 = _parsed4;\n          _keyObject3._asymmetricKeyType = 'ec';\n          _keyObject3._type = 'private';\n          _keyObject3._pem = ECPrivateKey.encode(_parsed4, 'pem', {\n            label: 'EC PRIVATE KEY'\n          });\n          return _keyObject3;\n        }\n\n      default:\n        throw new TypeError(\"The value \".concat(type, \" is invalid for option \\\"type\\\"\"));\n    }\n  };\n}\n\nmodule.exports = {\n  createPublicKey: _createPublicKey,\n  createPrivateKey: _createPrivateKey2,\n  createSecretKey: createSecretKey,\n  KeyObject: KeyObject,\n  asInput: asInput\n};","map":{"version":3,"sources":["/Users/suryanandsunil/Desktop/proto1-arizon/lyo-test/node_modules/jose/lib/help/key_object.js"],"names":["require","keyObjectSupported","createPublicKey","createPrivateKey","createSecretKey","KeyObject","asInput","input","EOL","errors","isObject","asn1","toInput","Symbol","namedCurve","keyObject","needsPublic","pemToDer","pem","Buffer","from","replace","derToPem","der","label","toString","match","join","unsupported","JOSENotSupported","cipher","passphrase","type","format","_type","_buffer","asymmetricKeyType","_pem","PublicKeyInfo","get","encode","algorithm","parameters","publicKey","unused","data","TypeError","undefined","_pkcs8","isBuffer","parsed","_asn1","RSAPrivateKey","privateKey","PrivateKeyInfo","pkcs8","version","export","ECPrivateKey","_asymmetricKeyType","_symmetricKeySize","_pub","buffer","length","key","RSAPublicKey","split","decode","n","BigInt","hints","value","Error","module","exports"],"mappings":"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","sourcesContent":["const { keyObjectSupported } = require('./runtime_support')\n\nlet createPublicKey\nlet createPrivateKey\nlet createSecretKey\nlet KeyObject\nlet asInput\n\nif (keyObjectSupported) {\n  ({ createPublicKey, createPrivateKey, createSecretKey, KeyObject } = require('crypto'))\n  asInput = (input) => input\n} else {\n  const { EOL } = require('os')\n\n  const errors = require('../errors')\n  const isObject = require('./is_object')\n  const asn1 = require('./asn1')\n  const toInput = Symbol('toInput')\n\n  const namedCurve = Symbol('namedCurve')\n\n  asInput = (keyObject, needsPublic) => {\n    if (keyObject instanceof KeyObject) {\n      return keyObject[toInput](needsPublic)\n    }\n\n    return createSecretKey(keyObject)[toInput](needsPublic)\n  }\n\n  const pemToDer = pem => Buffer.from(pem.replace(/(?:-----(?:BEGIN|END)(?: (?:RSA|EC))? (?:PRIVATE|PUBLIC) KEY-----|\\s)/g, ''), 'base64')\n  const derToPem = (der, label) => `-----BEGIN ${label}-----${EOL}${(der.toString('base64').match(/.{1,64}/g) || []).join(EOL)}${EOL}-----END ${label}-----`\n  const unsupported = (input) => {\n    const label = typeof input === 'string' ? input : `OID ${input.join('.')}`\n    throw new errors.JOSENotSupported(`${label} is not supported in your Node.js runtime version`)\n  }\n\n  KeyObject = class KeyObject {\n    export ({ cipher, passphrase, type, format } = {}) {\n      if (this._type === 'secret') {\n        return this._buffer\n      }\n\n      if (this._type === 'public') {\n        if (this.asymmetricKeyType === 'rsa') {\n          switch (type) {\n            case 'pkcs1':\n              if (format === 'pem') {\n                return this._pem\n              }\n\n              return pemToDer(this._pem)\n            case 'spki': {\n              const PublicKeyInfo = asn1.get('PublicKeyInfo')\n              const pem = PublicKeyInfo.encode({\n                algorithm: {\n                  algorithm: 'rsaEncryption',\n                  parameters: { type: 'null' }\n                },\n                publicKey: {\n                  unused: 0,\n                  data: pemToDer(this._pem)\n                }\n              }, 'pem', { label: 'PUBLIC KEY' })\n\n              return format === 'pem' ? pem : pemToDer(pem)\n            }\n            default:\n              throw new TypeError(`The value ${type} is invalid for option \"type\"`)\n          }\n        }\n\n        if (this.asymmetricKeyType === 'ec') {\n          if (type !== 'spki') {\n            throw new TypeError(`The value ${type} is invalid for option \"type\"`)\n          }\n\n          if (format === 'pem') {\n            return this._pem\n          }\n\n          return pemToDer(this._pem)\n        }\n      }\n\n      if (this._type === 'private') {\n        if (passphrase !== undefined || cipher !== undefined) {\n          throw new errors.JOSENotSupported('encrypted private keys are not supported in your Node.js runtime version')\n        }\n\n        if (type === 'pkcs8') {\n          if (this._pkcs8) {\n            if (format === 'der' && typeof this._pkcs8 === 'string') {\n              return pemToDer(this._pkcs8)\n            }\n\n            if (format === 'pem' && Buffer.isBuffer(this._pkcs8)) {\n              return derToPem(this._pkcs8, 'PRIVATE KEY')\n            }\n\n            return this._pkcs8\n          }\n\n          if (this.asymmetricKeyType === 'rsa') {\n            const parsed = this._asn1\n            const RSAPrivateKey = asn1.get('RSAPrivateKey')\n            const privateKey = RSAPrivateKey.encode(parsed)\n            const PrivateKeyInfo = asn1.get('PrivateKeyInfo')\n            const pkcs8 = PrivateKeyInfo.encode({\n              version: 0,\n              privateKey,\n              algorithm: {\n                algorithm: 'rsaEncryption',\n                parameters: { type: 'null' }\n              }\n            })\n\n            this._pkcs8 = pkcs8\n\n            return this.export({ type, format })\n          }\n\n          if (this.asymmetricKeyType === 'ec') {\n            const parsed = this._asn1\n            const ECPrivateKey = asn1.get('ECPrivateKey')\n            const privateKey = ECPrivateKey.encode({\n              version: parsed.version,\n              privateKey: parsed.privateKey,\n              publicKey: parsed.publicKey\n            })\n            const PrivateKeyInfo = asn1.get('PrivateKeyInfo')\n            const pkcs8 = PrivateKeyInfo.encode({\n              version: 0,\n              privateKey,\n              algorithm: {\n                algorithm: 'ecPublicKey',\n                parameters: this._asn1.parameters\n              }\n            })\n\n            this._pkcs8 = pkcs8\n\n            return this.export({ type, format })\n          }\n        }\n\n        if (this.asymmetricKeyType === 'rsa' && type === 'pkcs1') {\n          if (format === 'pem') {\n            return this._pem\n          }\n\n          return pemToDer(this._pem)\n        } else if (this.asymmetricKeyType === 'ec' && type === 'sec1') {\n          if (format === 'pem') {\n            return this._pem\n          }\n\n          return pemToDer(this._pem)\n        } else {\n          throw new TypeError(`The value ${type} is invalid for option \"type\"`)\n        }\n      }\n    }\n\n    get type () {\n      return this._type\n    }\n\n    get asymmetricKeyType () {\n      return this._asymmetricKeyType\n    }\n\n    get symmetricKeySize () {\n      return this._symmetricKeySize\n    }\n\n    [toInput] (needsPublic) {\n      switch (this._type) {\n        case 'secret':\n          return this._buffer\n        case 'public':\n          return this._pem\n        default:\n          if (needsPublic) {\n            if (!('_pub' in this)) {\n              this._pub = createPublicKey(this)\n            }\n\n            return this._pub[toInput](false)\n          }\n\n          return this._pem\n      }\n    }\n  }\n\n  createSecretKey = (buffer) => {\n    if (!Buffer.isBuffer(buffer) || !buffer.length) {\n      throw new TypeError('input must be a non-empty Buffer instance')\n    }\n\n    const keyObject = new KeyObject()\n    keyObject._buffer = Buffer.from(buffer)\n    keyObject._symmetricKeySize = buffer.length\n    keyObject._type = 'secret'\n\n    return keyObject\n  }\n\n  createPublicKey = (input) => {\n    if (input instanceof KeyObject) {\n      if (input.type !== 'private') {\n        throw new TypeError(`Invalid key object type ${input.type}, expected private.`)\n      }\n\n      switch (input.asymmetricKeyType) {\n        case 'ec': {\n          const PublicKeyInfo = asn1.get('PublicKeyInfo')\n          const key = PublicKeyInfo.encode({\n            algorithm: {\n              algorithm: 'ecPublicKey',\n              parameters: input._asn1.parameters\n            },\n            publicKey: input._asn1.publicKey\n          })\n\n          return createPublicKey({ key, format: 'der', type: 'spki' })\n        }\n        case 'rsa': {\n          const RSAPublicKey = asn1.get('RSAPublicKey')\n          const key = RSAPublicKey.encode(input._asn1)\n          return createPublicKey({ key, format: 'der', type: 'pkcs1' })\n        }\n      }\n    }\n\n    if (typeof input === 'string' || Buffer.isBuffer(input)) {\n      input = { key: input, format: 'pem' }\n    }\n\n    if (!isObject(input)) {\n      throw new TypeError('input must be a string, Buffer or an object')\n    }\n\n    const { format, passphrase } = input\n    let { key, type } = input\n\n    if (typeof key !== 'string' && !Buffer.isBuffer(key)) {\n      throw new TypeError('key must be a string or Buffer')\n    }\n\n    if (format !== 'pem' && format !== 'der') {\n      throw new TypeError('format must be one of \"pem\" or \"der\"')\n    }\n\n    let label\n    if (format === 'pem') {\n      key = key.toString()\n      switch (key.split(/\\r?\\n/g)[0].toString()) {\n        case '-----BEGIN PUBLIC KEY-----':\n          type = 'spki'\n          label = 'PUBLIC KEY'\n          break\n        case '-----BEGIN RSA PUBLIC KEY-----':\n          type = 'pkcs1'\n          label = 'RSA PUBLIC KEY'\n          break\n        case '-----BEGIN CERTIFICATE-----':\n          throw new errors.JOSENotSupported('X.509 certificates are not supported in your Node.js runtime version')\n        case '-----BEGIN PRIVATE KEY-----':\n        case '-----BEGIN EC PRIVATE KEY-----':\n        case '-----BEGIN RSA PRIVATE KEY-----':\n          return createPublicKey(createPrivateKey(key))\n        default:\n          throw new TypeError('unknown/unsupported PEM type')\n      }\n    }\n\n    switch (type) {\n      case 'spki': {\n        const PublicKeyInfo = asn1.get('PublicKeyInfo')\n        const parsed = PublicKeyInfo.decode(key, format, { label })\n\n        let type, keyObject\n        switch (parsed.algorithm.algorithm) {\n          case 'ecPublicKey': {\n            keyObject = new KeyObject()\n            keyObject._asn1 = parsed\n            keyObject._asymmetricKeyType = 'ec'\n            keyObject._type = 'public'\n            keyObject._pem = PublicKeyInfo.encode(parsed, 'pem', { label: 'PUBLIC KEY' })\n\n            break\n          }\n          case 'rsaEncryption': {\n            type = 'pkcs1'\n            keyObject = createPublicKey({ type, key: parsed.publicKey.data, format: 'der' })\n            break\n          }\n          default:\n            unsupported(parsed.algorithm.algorithm)\n        }\n\n        return keyObject\n      }\n      case 'pkcs1': {\n        const RSAPublicKey = asn1.get('RSAPublicKey')\n        const parsed = RSAPublicKey.decode(key, format, { label })\n\n        // special case when private pkcs1 PEM / DER is used with createPublicKey\n        if (parsed.n === BigInt(0)) {\n          return createPublicKey(createPrivateKey({ key, format, type, passphrase }))\n        }\n\n        const keyObject = new KeyObject()\n        keyObject._asn1 = parsed\n        keyObject._asymmetricKeyType = 'rsa'\n        keyObject._type = 'public'\n        keyObject._pem = RSAPublicKey.encode(parsed, 'pem', { label: 'RSA PUBLIC KEY' })\n\n        return keyObject\n      }\n      case 'pkcs8':\n      case 'sec1':\n        return createPublicKey(createPrivateKey({ format, key, type, passphrase }))\n      default:\n        throw new TypeError(`The value ${type} is invalid for option \"type\"`)\n    }\n  }\n\n  createPrivateKey = (input, hints) => {\n    if (typeof input === 'string' || Buffer.isBuffer(input)) {\n      input = { key: input, format: 'pem' }\n    }\n\n    if (!isObject(input)) {\n      throw new TypeError('input must be a string, Buffer or an object')\n    }\n\n    const { format, passphrase } = input\n    let { key, type } = input\n\n    if (typeof key !== 'string' && !Buffer.isBuffer(key)) {\n      throw new TypeError('key must be a string or Buffer')\n    }\n\n    if (passphrase !== undefined) {\n      throw new errors.JOSENotSupported('encrypted private keys are not supported in your Node.js runtime version')\n    }\n\n    if (format !== 'pem' && format !== 'der') {\n      throw new TypeError('format must be one of \"pem\" or \"der\"')\n    }\n\n    let label\n    if (format === 'pem') {\n      key = key.toString()\n      switch (key.split(/\\r?\\n/g)[0].toString()) {\n        case '-----BEGIN PRIVATE KEY-----':\n          type = 'pkcs8'\n          label = 'PRIVATE KEY'\n          break\n        case '-----BEGIN EC PRIVATE KEY-----':\n          type = 'sec1'\n          label = 'EC PRIVATE KEY'\n          break\n        case '-----BEGIN RSA PRIVATE KEY-----':\n          type = 'pkcs1'\n          label = 'RSA PRIVATE KEY'\n          break\n        default:\n          throw new TypeError('unknown/unsupported PEM type')\n      }\n    }\n\n    switch (type) {\n      case 'pkcs8': {\n        const PrivateKeyInfo = asn1.get('PrivateKeyInfo')\n        const parsed = PrivateKeyInfo.decode(key, format, { label })\n\n        let type, keyObject\n        switch (parsed.algorithm.algorithm) {\n          case 'ecPublicKey': {\n            type = 'sec1'\n            keyObject = createPrivateKey({ type, key: parsed.privateKey, format: 'der' }, { [namedCurve]: parsed.algorithm.parameters.value })\n            break\n          }\n          case 'rsaEncryption': {\n            type = 'pkcs1'\n            keyObject = createPrivateKey({ type, key: parsed.privateKey, format: 'der' })\n            break\n          }\n          default:\n            unsupported(parsed.algorithm.algorithm)\n        }\n\n        keyObject._pkcs8 = key\n        return keyObject\n      }\n      case 'pkcs1': {\n        const RSAPrivateKey = asn1.get('RSAPrivateKey')\n        const parsed = RSAPrivateKey.decode(key, format, { label })\n\n        const keyObject = new KeyObject()\n        keyObject._asn1 = parsed\n        keyObject._asymmetricKeyType = 'rsa'\n        keyObject._type = 'private'\n        keyObject._pem = RSAPrivateKey.encode(parsed, 'pem', { label: 'RSA PRIVATE KEY' })\n\n        return keyObject\n      }\n      case 'sec1': {\n        const ECPrivateKey = asn1.get('ECPrivateKey')\n        let parsed = ECPrivateKey.decode(key, format, { label })\n\n        if (!('parameters' in parsed) && !hints[namedCurve]) {\n          throw new Error('invalid sec1')\n        } else if (!('parameters' in parsed)) {\n          parsed = { ...parsed, parameters: { type: 'namedCurve', value: hints[namedCurve] } }\n        }\n\n        const keyObject = new KeyObject()\n        keyObject._asn1 = parsed\n        keyObject._asymmetricKeyType = 'ec'\n        keyObject._type = 'private'\n        keyObject._pem = ECPrivateKey.encode(parsed, 'pem', { label: 'EC PRIVATE KEY' })\n\n        return keyObject\n      }\n      default:\n        throw new TypeError(`The value ${type} is invalid for option \"type\"`)\n    }\n  }\n}\n\nmodule.exports = { createPublicKey, createPrivateKey, createSecretKey, KeyObject, asInput }\n"]},"metadata":{},"sourceType":"script"}