{"ast":null,"code":"\"use strict\";\n\nvar _wrapNativeSuper = require(\"/Users/suryanandsunil/Desktop/proto1-arizon/lyo-test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapNativeSuper\");\n\nvar _regeneratorRuntime = require(\"/Users/suryanandsunil/Desktop/proto1-arizon/lyo-test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/suryanandsunil/Desktop/proto1-arizon/lyo-test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _inherits = require(\"/Users/suryanandsunil/Desktop/proto1-arizon/lyo-test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/suryanandsunil/Desktop/proto1-arizon/lyo-test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _classCallCheck = require(\"/Users/suryanandsunil/Desktop/proto1-arizon/lyo-test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/suryanandsunil/Desktop/proto1-arizon/lyo-test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar assert = require(\"assert\");\n\nvar backoff_1 = require(\"./backoff\");\n\nvar rate_limiter_1 = require(\"./rate-limiter\");\n\nvar timestamp_1 = require(\"./timestamp\");\n\nvar util_1 = require(\"./util\");\n\nvar write_batch_1 = require(\"./write-batch\");\n\nvar validate_1 = require(\"./validate\");\n\nvar logger_1 = require(\"./logger\");\n/*!\n * The maximum number of writes that can be in a single batch.\n */\n\n\nvar MAX_BATCH_SIZE = 20;\n/*!\n * The maximum number of writes can be can in a single batch that is being retried.\n */\n\nexports.RETRY_MAX_BATCH_SIZE = 10;\n/*!\n * The starting maximum number of operations per second as allowed by the\n * 500/50/5 rule.\n *\n * https://firebase.google.com/docs/firestore/best-practices#ramping_up_traffic.\n */\n\nexports.DEFAULT_INITIAL_OPS_PER_SECOND_LIMIT = 500;\n/*!\n * The maximum number of operations per second as allowed by the 500/50/5 rule.\n * By default the rate limiter will not exceed this value.\n *\n * https://firebase.google.com/docs/firestore/best-practices#ramping_up_traffic.\n */\n\nexports.DEFAULT_MAXIMUM_OPS_PER_SECOND_LIMIT = 10000;\n/*!\n * The default jitter to apply to the exponential backoff used in retries. For\n * example, a factor of 0.3 means a 30% jitter is applied.\n */\n\nexports.DEFAULT_JITTER_FACTOR = 0.3;\n/*!\n * The rate by which to increase the capacity as specified by the 500/50/5 rule.\n */\n\nvar RATE_LIMITER_MULTIPLIER = 1.5;\n/*!\n * How often the operations per second capacity should increase in milliseconds\n * as specified by the 500/50/5 rule.\n */\n\nvar RATE_LIMITER_MULTIPLIER_MILLIS = 5 * 60 * 1000;\n/*!\n * The default maximum number of pending operations that can be enqueued onto a\n * BulkWriter instance. An operation is considered pending if BulkWriter has\n * sent it via RPC and is awaiting the result. BulkWriter buffers additional\n * writes after this many pending operations in order to avoiding going OOM.\n */\n\nvar DEFAULT_MAXIMUM_PENDING_OPERATIONS_COUNT = 500;\n/**\n * Represents a single write for BulkWriter, encapsulating operation dispatch\n * and error handling.\n * @private\n */\n\nvar BulkWriterOperation = /*#__PURE__*/function () {\n  /**\n   * @param ref The document reference being written to.\n   * @param type The type of operation that created this write.\n   * @param sendFn A callback to invoke when the operation should be sent.\n   * @param errorFn The user provided global error callback.\n   * @param successFn The user provided global success callback.\n   */\n  function BulkWriterOperation(ref, type, sendFn, errorFn, successFn) {\n    _classCallCheck(this, BulkWriterOperation);\n\n    this.ref = ref;\n    this.type = type;\n    this.sendFn = sendFn;\n    this.errorFn = errorFn;\n    this.successFn = successFn;\n    this.deferred = new util_1.Deferred();\n    this.failedAttempts = 0;\n    this._backoffDuration = 0;\n    /** Whether flush() was called when this was the last enqueued operation. */\n\n    this._flushed = false;\n  }\n\n  _createClass(BulkWriterOperation, [{\n    key: \"promise\",\n    get: function get() {\n      return this.deferred.promise;\n    }\n  }, {\n    key: \"backoffDuration\",\n    get: function get() {\n      return this._backoffDuration;\n    }\n  }, {\n    key: \"markFlushed\",\n    value: function markFlushed() {\n      this._flushed = true;\n    }\n  }, {\n    key: \"flushed\",\n    get: function get() {\n      return this._flushed;\n    }\n  }, {\n    key: \"onError\",\n    value: function onError(error) {\n      ++this.failedAttempts;\n\n      try {\n        var bulkWriterError = new BulkWriterError(error.code, error.message, this.ref, this.type, this.failedAttempts);\n        var shouldRetry = this.errorFn(bulkWriterError);\n        logger_1.logger('BulkWriter.errorFn', null, 'Ran error callback on error code:', error.code, ', shouldRetry:', shouldRetry, ' for document:', this.ref.path);\n\n        if (shouldRetry) {\n          this.lastStatus = error.code;\n          this.updateBackoffDuration();\n          this.sendFn(this);\n        } else {\n          this.deferred.reject(bulkWriterError);\n        }\n      } catch (userCallbackError) {\n        this.deferred.reject(userCallbackError);\n      }\n    }\n  }, {\n    key: \"updateBackoffDuration\",\n    value: function updateBackoffDuration() {\n      if (this.lastStatus === 8\n      /* RESOURCE_EXHAUSTED */\n      ) {\n          this._backoffDuration = backoff_1.DEFAULT_BACKOFF_MAX_DELAY_MS;\n        } else if (this._backoffDuration === 0) {\n        this._backoffDuration = backoff_1.DEFAULT_BACKOFF_INITIAL_DELAY_MS;\n      } else {\n        this._backoffDuration *= backoff_1.DEFAULT_BACKOFF_FACTOR;\n      }\n    }\n  }, {\n    key: \"onSuccess\",\n    value: function onSuccess(result) {\n      try {\n        this.successFn(this.ref, result);\n        this.deferred.resolve(result);\n      } catch (userCallbackError) {\n        this.deferred.reject(userCallbackError);\n      }\n    }\n  }]);\n\n  return BulkWriterOperation;\n}();\n/**\n * Used to represent a batch on the BatchQueue.\n *\n * @private\n */\n\n\nvar BulkCommitBatch = /*#__PURE__*/function (_write_batch_1$WriteB) {\n  _inherits(BulkCommitBatch, _write_batch_1$WriteB);\n\n  var _super = _createSuper(BulkCommitBatch);\n\n  function BulkCommitBatch(firestore, maxBatchSize) {\n    var _this;\n\n    _classCallCheck(this, BulkCommitBatch);\n\n    _this = _super.call(this, firestore); // The set of document reference paths present in the WriteBatch.\n\n    _this.docPaths = new Set(); // An array of pending write operations. Only contains writes that have not\n    // been resolved.\n\n    _this.pendingOps = [];\n    _this.maxBatchSize = maxBatchSize;\n    return _this;\n  }\n\n  _createClass(BulkCommitBatch, [{\n    key: \"has\",\n    value: function has(documentRef) {\n      return this.docPaths.has(documentRef.path);\n    }\n  }, {\n    key: \"bulkCommit\",\n    value: function () {\n      var _bulkCommit = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var options,\n            _a,\n            tag,\n            stack,\n            response,\n            retryCodes,\n            ops,\n            i,\n            DELETE_TIMESTAMP_SENTINEL,\n            status,\n            updateTime,\n            error,\n            _args = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                options = _args.length > 0 && _args[0] !== undefined ? _args[0] : {};\n                tag = (_a = options === null || options === void 0 ? void 0 : options.requestTag) !== null && _a !== void 0 ? _a : util_1.requestTag(); // Capture the error stack to preserve stack tracing across async calls.\n\n                stack = Error().stack;\n                _context.prev = 3;\n                logger_1.logger('BulkCommitBatch.bulkCommit', tag, \"Sending next batch with \".concat(this._opCount, \" writes\"));\n                retryCodes = util_1.getRetryCodes('batchWrite');\n                _context.next = 8;\n                return this._commit({\n                  retryCodes: retryCodes,\n                  methodName: 'batchWrite',\n                  requestTag: tag\n                });\n\n              case 8:\n                response = _context.sent;\n                _context.next = 15;\n                break;\n\n              case 11:\n                _context.prev = 11;\n                _context.t0 = _context[\"catch\"](3);\n                // Map the failure to each individual write's result.\n                ops = Array.from({\n                  length: this.pendingOps.length\n                });\n                response = {\n                  writeResults: ops.map(function () {\n                    return {};\n                  }),\n                  status: ops.map(function () {\n                    return _context.t0;\n                  })\n                };\n\n              case 15:\n                for (i = 0; i < (response.writeResults || []).length; ++i) {\n                  // Since delete operations currently do not have write times, use a\n                  // sentinel Timestamp value.\n                  // TODO(b/158502664): Use actual delete timestamp.\n                  DELETE_TIMESTAMP_SENTINEL = timestamp_1.Timestamp.fromMillis(0);\n                  status = (response.status || [])[i];\n\n                  if (status.code === 0\n                  /* OK */\n                  ) {\n                      updateTime = timestamp_1.Timestamp.fromProto(response.writeResults[i].updateTime || DELETE_TIMESTAMP_SENTINEL);\n                      this.pendingOps[i].onSuccess(new write_batch_1.WriteResult(updateTime));\n                    } else {\n                    error = new (require('google-gax').GoogleError)(status.message || undefined);\n                    error.code = status.code;\n                    this.pendingOps[i].onError(util_1.wrapError(error, stack));\n                  }\n                }\n\n              case 16:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[3, 11]]);\n      }));\n\n      function bulkCommit() {\n        return _bulkCommit.apply(this, arguments);\n      }\n\n      return bulkCommit;\n    }()\n    /**\n     * Helper to update data structures associated with the operation and returns\n     * the result.\n     */\n\n  }, {\n    key: \"processLastOperation\",\n    value: function processLastOperation(op) {\n      assert(!this.docPaths.has(op.ref.path), 'Batch should not contain writes to the same document');\n      this.docPaths.add(op.ref.path);\n      this.pendingOps.push(op);\n    }\n  }]);\n\n  return BulkCommitBatch;\n}(write_batch_1.WriteBatch);\n/**\n * Used to represent a buffered BulkWriterOperation.\n *\n * @private\n */\n\n\nvar BufferedOperation = function BufferedOperation(operation, sendFn) {\n  _classCallCheck(this, BufferedOperation);\n\n  this.operation = operation;\n  this.sendFn = sendFn;\n};\n/**\n * The error thrown when a BulkWriter operation fails.\n *\n * @class BulkWriterError\n */\n\n\nvar BulkWriterError = /*#__PURE__*/function (_Error) {\n  _inherits(BulkWriterError, _Error);\n\n  var _super2 = _createSuper(BulkWriterError);\n\n  /** @hideconstructor */\n  function BulkWriterError(\n  /** The status code of the error. */\n  code,\n  /** The error message of the error. */\n  message,\n  /** The document reference the operation was performed on. */\n  documentRef,\n  /** The type of operation performed. */\n  operationType,\n  /** How many times this operation has been attempted unsuccessfully. */\n  failedAttempts) {\n    var _this2;\n\n    _classCallCheck(this, BulkWriterError);\n\n    _this2 = _super2.call(this, message);\n    _this2.code = code;\n    _this2.message = message;\n    _this2.documentRef = documentRef;\n    _this2.operationType = operationType;\n    _this2.failedAttempts = failedAttempts;\n    return _this2;\n  }\n\n  return BulkWriterError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nexports.BulkWriterError = BulkWriterError;\n/**\n * A Firestore BulkWriter that can be used to perform a large number of writes\n * in parallel.\n *\n * @class BulkWriter\n */\n\nvar BulkWriter = /*#__PURE__*/function () {\n  /** @hideconstructor */\n  function BulkWriter(firestore, options) {\n    _classCallCheck(this, BulkWriter);\n\n    var _a, _b;\n\n    this.firestore = firestore;\n    /**\n     * The maximum number of writes that can be in a single batch.\n     * Visible for testing.\n     * @private\n     */\n\n    this._maxBatchSize = MAX_BATCH_SIZE;\n    /**\n     * The batch that is currently used to schedule operations. Once this batch\n     * reaches maximum capacity, a new batch is created.\n     * @private\n     */\n\n    this._bulkCommitBatch = new BulkCommitBatch(this.firestore, this._maxBatchSize);\n    /**\n     * A pointer to the tail of all active BulkWriter operations. This pointer\n     * is advanced every time a new write is enqueued.\n     * @private\n     */\n\n    this._lastOp = Promise.resolve();\n    /**\n     * Whether this BulkWriter instance has started to close. Afterwards, no\n     * new operations can be enqueued, except for retry operations scheduled by\n     * the error handler.\n     * @private\n     */\n\n    this._closing = false;\n    /**\n     * The number of pending operations enqueued on this BulkWriter instance.\n     * An operation is considered pending if BulkWriter has sent it via RPC and\n     * is awaiting the result.\n     * @private\n     */\n\n    this._pendingOpsCount = 0;\n    /**\n     * An array containing buffered BulkWriter operations after the maximum number\n     * of pending operations has been enqueued.\n     * @private\n     */\n\n    this._bufferedOperations = [];\n    /**\n     * The maximum number of pending operations that can be enqueued onto this\n     * BulkWriter instance. Once the this number of writes have been enqueued,\n     * subsequent writes are buffered.\n     * @private\n     */\n\n    this._maxPendingOpCount = DEFAULT_MAXIMUM_PENDING_OPERATIONS_COUNT;\n    /**\n     * The user-provided callback to be run every time a BulkWriter operation\n     * successfully completes.\n     * @private\n     */\n\n    this._successFn = function () {};\n    /**\n     * The user-provided callback to be run every time a BulkWriter operation\n     * fails.\n     * @private\n     */\n\n\n    this._errorFn = function (error) {\n      var isRetryableDeleteError = error.operationType === 'delete' && error.code === 13\n      /* INTERNAL */\n      ;\n      var retryCodes = util_1.getRetryCodes('batchWrite');\n      return (retryCodes.includes(error.code) || isRetryableDeleteError) && error.failedAttempts < backoff_1.MAX_RETRY_ATTEMPTS;\n    };\n\n    this.firestore._incrementBulkWritersCount();\n\n    validateBulkWriterOptions(options);\n\n    if ((options === null || options === void 0 ? void 0 : options.throttling) === false) {\n      this._rateLimiter = new rate_limiter_1.RateLimiter(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);\n    } else {\n      var startingRate = exports.DEFAULT_INITIAL_OPS_PER_SECOND_LIMIT;\n      var maxRate = exports.DEFAULT_MAXIMUM_OPS_PER_SECOND_LIMIT;\n\n      if (typeof (options === null || options === void 0 ? void 0 : options.throttling) !== 'boolean') {\n        if (((_a = options === null || options === void 0 ? void 0 : options.throttling) === null || _a === void 0 ? void 0 : _a.maxOpsPerSecond) !== undefined) {\n          maxRate = options.throttling.maxOpsPerSecond;\n        }\n\n        if (((_b = options === null || options === void 0 ? void 0 : options.throttling) === null || _b === void 0 ? void 0 : _b.initialOpsPerSecond) !== undefined) {\n          startingRate = options.throttling.initialOpsPerSecond;\n        } // The initial validation step ensures that the maxOpsPerSecond is\n        // greater than initialOpsPerSecond. If this inequality is true, that\n        // means initialOpsPerSecond was not set and maxOpsPerSecond is less\n        // than the default starting rate.\n\n\n        if (maxRate < startingRate) {\n          startingRate = maxRate;\n        } // Ensure that the batch size is not larger than the number of allowed\n        // operations per second.\n\n\n        if (startingRate < this._maxBatchSize) {\n          this._maxBatchSize = startingRate;\n        }\n      }\n\n      this._rateLimiter = new rate_limiter_1.RateLimiter(startingRate, RATE_LIMITER_MULTIPLIER, RATE_LIMITER_MULTIPLIER_MILLIS, maxRate);\n    }\n  } // Visible for testing.\n\n\n  _createClass(BulkWriter, [{\n    key: \"_getBufferedOperationsCount\",\n    value: function _getBufferedOperationsCount() {\n      return this._bufferedOperations.length;\n    } // Visible for testing.\n\n  }, {\n    key: \"_setMaxBatchSize\",\n    value: function _setMaxBatchSize(size) {\n      assert(this._bulkCommitBatch.pendingOps.length === 0, 'BulkCommitBatch should be empty');\n      this._maxBatchSize = size;\n      this._bulkCommitBatch = new BulkCommitBatch(this.firestore, size);\n    } // Visible for testing.\n\n  }, {\n    key: \"_setMaxPendingOpCount\",\n    value: function _setMaxPendingOpCount(newMax) {\n      this._maxPendingOpCount = newMax;\n    }\n    /**\n     * Create a document with the provided data. This single operation will fail\n     * if a document exists at its location.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * created.\n     * @param {T} data The object to serialize as the document.\n     * @returns {Promise<WriteResult>} A promise that resolves with the result of\n     * the write. If the write fails, the promise is rejected with a\n     * [BulkWriterError]{@link BulkWriterError}.\n     *\n     * @example\n     * let bulkWriter = firestore.bulkWriter();\n     * let documentRef = firestore.collection('col').doc();\n     *\n     * bulkWriter\n     *  .create(documentRef, {foo: 'bar'})\n     *  .then(result => {\n     *    console.log('Successfully executed write at: ', result);\n     *  })\n     *  .catch(err => {\n     *    console.log('Write failed with: ', err);\n     *  });\n     * });\n     */\n\n  }, {\n    key: \"create\",\n    value: function create(documentRef, data) {\n      this._verifyNotClosed();\n\n      var op = this._enqueue(documentRef, 'create', function (bulkCommitBatch) {\n        return bulkCommitBatch.create(documentRef, data);\n      });\n\n      util_1.silencePromise(op);\n      return op;\n    }\n    /**\n     * Delete a document from the database.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * deleted.\n     * @param {Precondition=} precondition A precondition to enforce for this\n     * delete.\n     * @param {Timestamp=} precondition.lastUpdateTime If set, enforces that the\n     * document was last updated at lastUpdateTime. Fails the batch if the\n     * document doesn't exist or was last updated at a different time.\n     * @returns {Promise<WriteResult>} A promise that resolves with the result of\n     * the delete. If the delete fails, the promise is rejected with a\n     * [BulkWriterError]{@link BulkWriterError}.\n     *\n     * @example\n     * let bulkWriter = firestore.bulkWriter();\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * bulkWriter\n     *  .delete(documentRef)\n     *  .then(result => {\n     *    console.log('Successfully deleted document');\n     *  })\n     *  .catch(err => {\n     *    console.log('Delete failed with: ', err);\n     *  });\n     * });\n     */\n\n  }, {\n    key: \"delete\",\n    value: function _delete(documentRef, precondition) {\n      this._verifyNotClosed();\n\n      var op = this._enqueue(documentRef, 'delete', function (bulkCommitBatch) {\n        return bulkCommitBatch.delete(documentRef, precondition);\n      });\n\n      util_1.silencePromise(op);\n      return op;\n    }\n    /**\n     * Write to the document referred to by the provided\n     * [DocumentReference]{@link DocumentReference}. If the document does not\n     * exist yet, it will be created. If you pass [SetOptions]{@link SetOptions}.,\n     * the provided data can be merged into the existing document.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * set.\n     * @param {T} data The object to serialize as the document.\n     * @param {SetOptions=} options An object to configure the set behavior.\n     * @param {boolean=} options.merge - If true, set() merges the values\n     * specified in its data argument. Fields omitted from this set() call remain\n     * untouched.\n     * @param {Array.<string|FieldPath>=} options.mergeFields - If provided, set()\n     * only replaces the specified field paths. Any field path that is not\n     * specified is ignored and remains untouched.\n     * @returns {Promise<WriteResult>} A promise that resolves with the result of\n     * the write. If the write fails, the promise is rejected with a\n     * [BulkWriterError]{@link BulkWriterError}.\n     *\n     *\n     * @example\n     * let bulkWriter = firestore.bulkWriter();\n     * let documentRef = firestore.collection('col').doc();\n     *\n     * bulkWriter\n     *  .set(documentRef, {foo: 'bar'})\n     *  .then(result => {\n     *    console.log('Successfully executed write at: ', result);\n     *  })\n     *  .catch(err => {\n     *    console.log('Write failed with: ', err);\n     *  });\n     * });\n     */\n\n  }, {\n    key: \"set\",\n    value: function set(documentRef, data, options) {\n      this._verifyNotClosed();\n\n      var op = this._enqueue(documentRef, 'set', function (bulkCommitBatch) {\n        return bulkCommitBatch.set(documentRef, data, options);\n      });\n\n      util_1.silencePromise(op);\n      return op;\n    }\n    /**\n     * Update fields of the document referred to by the provided\n     * [DocumentReference]{@link DocumentReference}. If the document doesn't yet\n     * exist, the update fails and the entire batch will be rejected.\n     *\n     * The update() method accepts either an object with field paths encoded as\n     * keys and field values encoded as values, or a variable number of arguments\n     * that alternate between field paths and field values. Nested fields can be\n     * updated by providing dot-separated field path strings or by providing\n     * FieldPath objects.\n     *\n     *\n     * A Precondition restricting this update can be specified as the last\n     * argument.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * updated.\n     * @param {UpdateData|string|FieldPath} dataOrField An object containing the\n     * fields and values with which to update the document or the path of the\n     * first field to update.\n     * @param {...(Precondition|*|string|FieldPath)} preconditionOrValues - An\n     * alternating list of field paths and values to update or a Precondition to\n     * restrict this update\n     * @returns {Promise<WriteResult>} A promise that resolves with the result of\n     * the write. If the write fails, the promise is rejected with a\n     * [BulkWriterError]{@link BulkWriterError}.\n     *\n     * @example\n     * let bulkWriter = firestore.bulkWriter();\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * bulkWriter\n     *  .update(documentRef, {foo: 'bar'})\n     *  .then(result => {\n     *    console.log('Successfully executed write at: ', result);\n     *  })\n     *  .catch(err => {\n     *    console.log('Write failed with: ', err);\n     *  });\n     * });\n     */\n\n  }, {\n    key: \"update\",\n    value: function update(documentRef, dataOrField) {\n      for (var _len = arguments.length, preconditionOrValues = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n        preconditionOrValues[_key - 2] = arguments[_key];\n      }\n\n      this._verifyNotClosed();\n\n      var op = this._enqueue(documentRef, 'update', function (bulkCommitBatch) {\n        return bulkCommitBatch.update.apply(bulkCommitBatch, [documentRef, dataOrField].concat(preconditionOrValues));\n      });\n\n      util_1.silencePromise(op);\n      return op;\n    }\n    /**\n     * Callback function set by {@link BulkWriter#onWriteResult} that is run\n     * every time a {@link BulkWriter} operation successfully completes.\n     *\n     * @callback BulkWriter~successCallback\n     * @param {DocumentReference} documentRef The document reference the\n     * operation was performed on\n     * @param {WriteResult} result The server write time of the operation.\n     */\n\n    /**\n     * Attaches a listener that is run every time a BulkWriter operation\n     * successfully completes.\n     *\n     * @param {BulkWriter~successCallback} successCallback A callback to be\n     * called every time a BulkWriter operation successfully completes.\n     * @example\n     * let bulkWriter = firestore.bulkWriter();\n     *\n     * bulkWriter\n     *   .onWriteResult((documentRef, result) => {\n     *     console.log(\n     *       'Successfully executed write on document: ',\n     *       documentRef,\n     *       ' at: ',\n     *       result\n     *     );\n     *   });\n     */\n\n  }, {\n    key: \"onWriteResult\",\n    value: function onWriteResult(successCallback) {\n      this._successFn = successCallback;\n    }\n    /**\n     * Callback function set by {@link BulkWriter#onWriteError} that is run when\n     * a write fails in order to determine whether {@link BulkWriter} should\n     * retry the operation.\n     *\n     * @callback BulkWriter~shouldRetryCallback\n     * @param {BulkWriterError} error The error object with information about the\n     * operation and error.\n     * @returns {boolean} Whether or not to retry the failed operation. Returning\n     * `true` retries the operation. Returning `false` will stop the retry loop.\n     */\n\n    /**\n     * Attaches an error handler listener that is run every time a BulkWriter\n     * operation fails.\n     *\n     * BulkWriter has a default error handler that retries UNAVAILABLE and\n     * ABORTED errors up to a maximum of 10 failed attempts. When an error\n     * handler is specified, the default error handler will be overwritten.\n     *\n     * @param shouldRetryCallback {BulkWriter~shouldRetryCallback} A callback to\n     * be called every time a BulkWriter operation fails. Returning `true` will\n     * retry the operation. Returning `false` will stop the retry loop.\n     * @example\n     * let bulkWriter = firestore.bulkWriter();\n     *\n     * bulkWriter\n     *   .onWriteError((error) => {\n     *     if (\n     *       error.code === GrpcStatus.UNAVAILABLE &&\n     *       error.failedAttempts < MAX_RETRY_ATTEMPTS\n     *     ) {\n     *       return true;\n     *     } else {\n     *       console.log('Failed write at document: ', error.documentRef);\n     *       return false;\n     *     }\n     *   });\n     */\n\n  }, {\n    key: \"onWriteError\",\n    value: function onWriteError(shouldRetryCallback) {\n      this._errorFn = shouldRetryCallback;\n    }\n    /**\n     * Commits all writes that have been enqueued up to this point in parallel.\n     *\n     * Returns a Promise that resolves when all currently queued operations have\n     * been committed. The Promise will never be rejected since the results for\n     * each individual operation are conveyed via their individual Promises.\n     *\n     * The Promise resolves immediately if there are no pending writes. Otherwise,\n     * the Promise waits for all previously issued writes, but it does not wait\n     * for writes that were added after the method is called. If you want to wait\n     * for additional writes, call `flush()` again.\n     *\n     * @return {Promise<void>} A promise that resolves when all enqueued writes\n     * up to this point have been committed.\n     *\n     * @example\n     * let bulkWriter = firestore.bulkWriter();\n     *\n     * bulkWriter.create(documentRef, {foo: 'bar'});\n     * bulkWriter.update(documentRef2, {foo: 'bar'});\n     * bulkWriter.delete(documentRef3);\n     * await flush().then(() => {\n     *   console.log('Executed all writes');\n     * });\n     */\n\n  }, {\n    key: \"flush\",\n    value: function flush() {\n      this._verifyNotClosed();\n\n      this._scheduleCurrentBatch(\n      /* flush= */\n      true); // Mark the most recent operation as flushed to ensure that the batch\n      // containing it will be sent once it's popped from the buffer.\n\n\n      if (this._bufferedOperations.length > 0) {\n        this._bufferedOperations[this._bufferedOperations.length - 1].operation.markFlushed();\n      }\n\n      return this._lastOp;\n    }\n    /**\n     * Commits all enqueued writes and marks the BulkWriter instance as closed.\n     *\n     * After calling `close()`, calling any method will throw an error. Any\n     * retries scheduled as part of an `onWriteError()` handler will be run\n     * before the `close()` promise resolves.\n     *\n     * Returns a Promise that resolves when there are no more pending writes. The\n     * Promise will never be rejected. Calling this method will send all requests.\n     * The promise resolves immediately if there are no pending writes.\n     *\n     * @return {Promise<void>} A promise that resolves when all enqueued writes\n     * up to this point have been committed.\n     *\n     * @example\n     * let bulkWriter = firestore.bulkWriter();\n     *\n     * bulkWriter.create(documentRef, {foo: 'bar'});\n     * bulkWriter.update(documentRef2, {foo: 'bar'});\n     * bulkWriter.delete(documentRef3);\n     * await close().then(() => {\n     *   console.log('Executed all writes');\n     * });\n     */\n\n  }, {\n    key: \"close\",\n    value: function close() {\n      this._verifyNotClosed();\n\n      this.firestore._decrementBulkWritersCount();\n\n      var flushPromise = this.flush();\n      this._closing = true;\n      return flushPromise;\n    }\n    /**\n     * Throws an error if the BulkWriter instance has been closed.\n     * @private\n     */\n\n  }, {\n    key: \"_verifyNotClosed\",\n    value: function _verifyNotClosed() {\n      if (this._closing) {\n        throw new Error('BulkWriter has already been closed.');\n      }\n    }\n    /**\n     * Sends the current batch and resets `this._bulkCommitBatch`.\n     *\n     * @param flush If provided, keeps re-sending operations until no more\n     * operations are enqueued. This allows retries to resolve as part of a\n     * `flush()` or `close()` call.\n     * @private\n     */\n\n  }, {\n    key: \"_scheduleCurrentBatch\",\n    value: function _scheduleCurrentBatch() {\n      var _this3 = this;\n\n      var flush = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      if (this._bulkCommitBatch._opCount === 0) return;\n      var pendingBatch = this._bulkCommitBatch; // Use the write with the longest backoff duration when determining backoff.\n\n      var highestBackoffDuration = pendingBatch.pendingOps.reduce(function (prev, cur) {\n        return prev.backoffDuration > cur.backoffDuration ? prev : cur;\n      }).backoffDuration;\n\n      var backoffMsWithJitter = BulkWriter._applyJitter(highestBackoffDuration);\n\n      var delayedExecution = new util_1.Deferred(); // A backoff duration greater than 0 implies that this batch is a retry.\n      // Retried writes are sent with a batch size of 10 in order to guarantee\n      // that the batch is under the 10MiB limit.\n\n      var maxBatchSize = highestBackoffDuration > 0 ? exports.RETRY_MAX_BATCH_SIZE : this._maxBatchSize;\n      this._bulkCommitBatch = new BulkCommitBatch(this.firestore, maxBatchSize);\n\n      if (backoffMsWithJitter > 0) {\n        backoff_1.delayExecution(function () {\n          return delayedExecution.resolve();\n        }, backoffMsWithJitter);\n      } else {\n        delayedExecution.resolve();\n      }\n\n      delayedExecution.promise.then(function () {\n        return _this3._sendBatch(pendingBatch, flush);\n      });\n    }\n    /**\n     * Sends the provided batch once the rate limiter does not require any delay.\n     * @private\n     */\n\n  }, {\n    key: \"_sendBatch\",\n    value: function () {\n      var _sendBatch2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(batch) {\n        var _this4 = this;\n\n        var flush,\n            tag,\n            underRateLimit,\n            delayMs,\n            _args2 = arguments;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                flush = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : false;\n                tag = util_1.requestTag(); // Send the batch if it is does not require any delay, or schedule another\n                // attempt after the appropriate timeout.\n\n                underRateLimit = this._rateLimiter.tryMakeRequest(batch._opCount);\n\n                if (!underRateLimit) {\n                  _context2.next = 9;\n                  break;\n                }\n\n                _context2.next = 6;\n                return batch.bulkCommit({\n                  requestTag: tag\n                });\n\n              case 6:\n                if (flush) this._scheduleCurrentBatch(flush);\n                _context2.next = 12;\n                break;\n\n              case 9:\n                delayMs = this._rateLimiter.getNextRequestDelayMs(batch._opCount);\n                logger_1.logger('BulkWriter._sendBatch', tag, \"Backing off for \".concat(delayMs, \" seconds\"));\n                backoff_1.delayExecution(function () {\n                  return _this4._sendBatch(batch, flush);\n                }, delayMs);\n\n              case 12:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function _sendBatch(_x) {\n        return _sendBatch2.apply(this, arguments);\n      }\n\n      return _sendBatch;\n    }()\n    /**\n     * Adds a 30% jitter to the provided backoff.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_enqueue\",\n    value:\n    /**\n     * Schedules and runs the provided operation on the next available batch.\n     * @private\n     */\n    function _enqueue(ref, type, enqueueOnBatchCallback) {\n      var _this5 = this;\n\n      var bulkWriterOp = new BulkWriterOperation(ref, type, this._sendFn.bind(this, enqueueOnBatchCallback), this._errorFn.bind(this), this._successFn.bind(this)); // Advance the `_lastOp` pointer. This ensures that `_lastOp` only resolves\n      // when both the previous and the current write resolves.\n\n      this._lastOp = this._lastOp.then(function () {\n        return util_1.silencePromise(bulkWriterOp.promise);\n      }); // Schedule the operation if the BulkWriter has fewer than the maximum\n      // number of allowed pending operations, or add the operation to the\n      // buffer.\n\n      if (this._pendingOpsCount < this._maxPendingOpCount) {\n        this._pendingOpsCount++;\n\n        this._sendFn(enqueueOnBatchCallback, bulkWriterOp);\n      } else {\n        this._bufferedOperations.push(new BufferedOperation(bulkWriterOp, function () {\n          _this5._pendingOpsCount++;\n\n          _this5._sendFn(enqueueOnBatchCallback, bulkWriterOp);\n        }));\n      } // Chain the BulkWriter operation promise with the buffer processing logic\n      // in order to ensure that it runs and that subsequent operations are\n      // enqueued before the next batch is scheduled in `_sendBatch()`.\n\n\n      return bulkWriterOp.promise.then(function (res) {\n        _this5._pendingOpsCount--;\n\n        _this5._processBufferedOps();\n\n        return res;\n      }).catch(function (err) {\n        _this5._pendingOpsCount--;\n\n        _this5._processBufferedOps();\n\n        throw err;\n      });\n    }\n    /**\n     * Manages the pending operation counter and schedules the next BulkWriter\n     * operation if we're under the maximum limit.\n     * @private\n     */\n\n  }, {\n    key: \"_processBufferedOps\",\n    value: function _processBufferedOps() {\n      if (this._pendingOpsCount < this._maxPendingOpCount && this._bufferedOperations.length > 0) {\n        var nextOp = this._bufferedOperations.shift();\n\n        nextOp.sendFn();\n      }\n    }\n    /**\n     * Schedules the provided operations on current BulkCommitBatch.\n     * Sends the BulkCommitBatch if it reaches maximum capacity.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_sendFn\",\n    value: function _sendFn(enqueueOnBatchCallback, op) {\n      if (this._bulkCommitBatch.has(op.ref)) {\n        // Create a new batch since the backend doesn't support batches with two\n        // writes to the same document.\n        this._scheduleCurrentBatch();\n      }\n\n      enqueueOnBatchCallback(this._bulkCommitBatch);\n\n      this._bulkCommitBatch.processLastOperation(op);\n\n      if (this._bulkCommitBatch._opCount === this._bulkCommitBatch.maxBatchSize) {\n        this._scheduleCurrentBatch();\n      } else if (op.flushed) {\n        // If flush() was called before this operation was enqueued into a batch,\n        // we still need to schedule it.\n        this._scheduleCurrentBatch(\n        /* flush= */\n        true);\n      }\n    }\n  }], [{\n    key: \"_applyJitter\",\n    value: function _applyJitter(backoffMs) {\n      if (backoffMs === 0) return 0; // Random value in [-0.3, 0.3].\n\n      var jitter = exports.DEFAULT_JITTER_FACTOR * (Math.random() * 2 - 1);\n      return Math.min(backoff_1.DEFAULT_BACKOFF_MAX_DELAY_MS, backoffMs + jitter * backoffMs);\n    }\n  }]);\n\n  return BulkWriter;\n}();\n\nexports.BulkWriter = BulkWriter;\n/**\n * Validates the use of 'value' as BulkWriterOptions.\n *\n * @private\n * @param value The BulkWriterOptions object to validate.\n * @throws if the input is not a valid BulkWriterOptions object.\n */\n\nfunction validateBulkWriterOptions(value) {\n  if (validate_1.validateOptional(value, {\n    optional: true\n  })) {\n    return;\n  }\n\n  var argName = 'options';\n\n  if (!util_1.isObject(value)) {\n    throw new Error(\"\".concat(validate_1.invalidArgumentMessage(argName, 'bulkWriter() options argument'), \" Input is not an object.\"));\n  }\n\n  var options = value;\n\n  if (options.throttling === undefined || typeof options.throttling === 'boolean') {\n    return;\n  }\n\n  if (options.throttling.initialOpsPerSecond !== undefined) {\n    validate_1.validateInteger('initialOpsPerSecond', options.throttling.initialOpsPerSecond, {\n      minValue: 1\n    });\n  }\n\n  if (options.throttling.maxOpsPerSecond !== undefined) {\n    validate_1.validateInteger('maxOpsPerSecond', options.throttling.maxOpsPerSecond, {\n      minValue: 1\n    });\n\n    if (options.throttling.initialOpsPerSecond !== undefined && options.throttling.initialOpsPerSecond > options.throttling.maxOpsPerSecond) {\n      throw new Error(\"\".concat(validate_1.invalidArgumentMessage(argName, 'bulkWriter() options argument'), \" \\\"maxOpsPerSecond\\\" cannot be less than \\\"initialOpsPerSecond\\\".\"));\n    }\n  }\n}","map":{"version":3,"sources":["/Users/suryanandsunil/Desktop/proto1-arizon/lyo-test/node_modules/@google-cloud/firestore/build/src/bulk-writer.js"],"names":["Object","defineProperty","exports","value","assert","require","backoff_1","rate_limiter_1","timestamp_1","util_1","write_batch_1","validate_1","logger_1","MAX_BATCH_SIZE","RETRY_MAX_BATCH_SIZE","DEFAULT_INITIAL_OPS_PER_SECOND_LIMIT","DEFAULT_MAXIMUM_OPS_PER_SECOND_LIMIT","DEFAULT_JITTER_FACTOR","RATE_LIMITER_MULTIPLIER","RATE_LIMITER_MULTIPLIER_MILLIS","DEFAULT_MAXIMUM_PENDING_OPERATIONS_COUNT","BulkWriterOperation","ref","type","sendFn","errorFn","successFn","deferred","Deferred","failedAttempts","_backoffDuration","_flushed","promise","error","bulkWriterError","BulkWriterError","code","message","shouldRetry","logger","path","lastStatus","updateBackoffDuration","reject","userCallbackError","DEFAULT_BACKOFF_MAX_DELAY_MS","DEFAULT_BACKOFF_INITIAL_DELAY_MS","DEFAULT_BACKOFF_FACTOR","result","resolve","BulkCommitBatch","firestore","maxBatchSize","docPaths","Set","pendingOps","documentRef","has","options","tag","_a","requestTag","stack","Error","_opCount","retryCodes","getRetryCodes","_commit","methodName","response","ops","Array","from","length","writeResults","map","status","i","DELETE_TIMESTAMP_SENTINEL","Timestamp","fromMillis","updateTime","fromProto","onSuccess","WriteResult","GoogleError","undefined","onError","wrapError","op","add","push","WriteBatch","BufferedOperation","operation","operationType","BulkWriter","_b","_maxBatchSize","_bulkCommitBatch","_lastOp","Promise","_closing","_pendingOpsCount","_bufferedOperations","_maxPendingOpCount","_successFn","_errorFn","isRetryableDeleteError","includes","MAX_RETRY_ATTEMPTS","_incrementBulkWritersCount","validateBulkWriterOptions","throttling","_rateLimiter","RateLimiter","Number","POSITIVE_INFINITY","startingRate","maxRate","maxOpsPerSecond","initialOpsPerSecond","size","newMax","data","_verifyNotClosed","_enqueue","bulkCommitBatch","create","silencePromise","precondition","delete","set","dataOrField","preconditionOrValues","update","successCallback","shouldRetryCallback","_scheduleCurrentBatch","markFlushed","_decrementBulkWritersCount","flushPromise","flush","pendingBatch","highestBackoffDuration","reduce","prev","cur","backoffDuration","backoffMsWithJitter","_applyJitter","delayedExecution","delayExecution","then","_sendBatch","batch","underRateLimit","tryMakeRequest","bulkCommit","delayMs","getNextRequestDelayMs","enqueueOnBatchCallback","bulkWriterOp","_sendFn","bind","res","_processBufferedOps","catch","err","nextOp","shift","processLastOperation","flushed","backoffMs","jitter","Math","random","min","validateOptional","optional","argName","isObject","invalidArgumentMessage","validateInteger","minValue"],"mappings":"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AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACI,aAAIjC,WAAJ,EAAiBoE,IAAjB,EAAuBlE,OAAvB,EAAgC;AAC5B,WAAKmE,gBAAL;;AACA,UAAMpC,EAAE,GAAG,KAAKqC,QAAL,CAActE,WAAd,EAA2B,KAA3B,EAAkC,UAAAuE,eAAe;AAAA,eAAIA,eAAe,CAACK,GAAhB,CAAoB5E,WAApB,EAAiCoE,IAAjC,EAAuClE,OAAvC,CAAJ;AAAA,OAAjD,CAAX;;AACAjD,MAAAA,MAAM,CAACwH,cAAP,CAAsBxC,EAAtB;AACA,aAAOA,EAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACI,gBAAOjC,WAAP,EAAoB6E,WAApB,EAA0D;AAAA,wCAAtBC,oBAAsB;AAAtBA,QAAAA,oBAAsB;AAAA;;AACtD,WAAKT,gBAAL;;AACA,UAAMpC,EAAE,GAAG,KAAKqC,QAAL,CAActE,WAAd,EAA2B,QAA3B,EAAqC,UAAAuE,eAAe;AAAA,eAAIA,eAAe,CAACQ,MAAhB,OAAAR,eAAe,GAAQvE,WAAR,EAAqB6E,WAArB,SAAqCC,oBAArC,EAAnB;AAAA,OAApD,CAAX;;AACA7H,MAAAA,MAAM,CAACwH,cAAP,CAAsBxC,EAAtB;AACA,aAAOA,EAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;WACI,uBAAc+C,eAAd,EAA+B;AAC3B,WAAK9B,UAAL,GAAkB8B,eAAlB;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AAC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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst assert = require(\"assert\");\nconst backoff_1 = require(\"./backoff\");\nconst rate_limiter_1 = require(\"./rate-limiter\");\nconst timestamp_1 = require(\"./timestamp\");\nconst util_1 = require(\"./util\");\nconst write_batch_1 = require(\"./write-batch\");\nconst validate_1 = require(\"./validate\");\nconst logger_1 = require(\"./logger\");\n/*!\n * The maximum number of writes that can be in a single batch.\n */\nconst MAX_BATCH_SIZE = 20;\n/*!\n * The maximum number of writes can be can in a single batch that is being retried.\n */\nexports.RETRY_MAX_BATCH_SIZE = 10;\n/*!\n * The starting maximum number of operations per second as allowed by the\n * 500/50/5 rule.\n *\n * https://firebase.google.com/docs/firestore/best-practices#ramping_up_traffic.\n */\nexports.DEFAULT_INITIAL_OPS_PER_SECOND_LIMIT = 500;\n/*!\n * The maximum number of operations per second as allowed by the 500/50/5 rule.\n * By default the rate limiter will not exceed this value.\n *\n * https://firebase.google.com/docs/firestore/best-practices#ramping_up_traffic.\n */\nexports.DEFAULT_MAXIMUM_OPS_PER_SECOND_LIMIT = 10000;\n/*!\n * The default jitter to apply to the exponential backoff used in retries. For\n * example, a factor of 0.3 means a 30% jitter is applied.\n */\nexports.DEFAULT_JITTER_FACTOR = 0.3;\n/*!\n * The rate by which to increase the capacity as specified by the 500/50/5 rule.\n */\nconst RATE_LIMITER_MULTIPLIER = 1.5;\n/*!\n * How often the operations per second capacity should increase in milliseconds\n * as specified by the 500/50/5 rule.\n */\nconst RATE_LIMITER_MULTIPLIER_MILLIS = 5 * 60 * 1000;\n/*!\n * The default maximum number of pending operations that can be enqueued onto a\n * BulkWriter instance. An operation is considered pending if BulkWriter has\n * sent it via RPC and is awaiting the result. BulkWriter buffers additional\n * writes after this many pending operations in order to avoiding going OOM.\n */\nconst DEFAULT_MAXIMUM_PENDING_OPERATIONS_COUNT = 500;\n/**\n * Represents a single write for BulkWriter, encapsulating operation dispatch\n * and error handling.\n * @private\n */\nclass BulkWriterOperation {\n    /**\n     * @param ref The document reference being written to.\n     * @param type The type of operation that created this write.\n     * @param sendFn A callback to invoke when the operation should be sent.\n     * @param errorFn The user provided global error callback.\n     * @param successFn The user provided global success callback.\n     */\n    constructor(ref, type, sendFn, errorFn, successFn) {\n        this.ref = ref;\n        this.type = type;\n        this.sendFn = sendFn;\n        this.errorFn = errorFn;\n        this.successFn = successFn;\n        this.deferred = new util_1.Deferred();\n        this.failedAttempts = 0;\n        this._backoffDuration = 0;\n        /** Whether flush() was called when this was the last enqueued operation. */\n        this._flushed = false;\n    }\n    get promise() {\n        return this.deferred.promise;\n    }\n    get backoffDuration() {\n        return this._backoffDuration;\n    }\n    markFlushed() {\n        this._flushed = true;\n    }\n    get flushed() {\n        return this._flushed;\n    }\n    onError(error) {\n        ++this.failedAttempts;\n        try {\n            const bulkWriterError = new BulkWriterError(error.code, error.message, this.ref, this.type, this.failedAttempts);\n            const shouldRetry = this.errorFn(bulkWriterError);\n            logger_1.logger('BulkWriter.errorFn', null, 'Ran error callback on error code:', error.code, ', shouldRetry:', shouldRetry, ' for document:', this.ref.path);\n            if (shouldRetry) {\n                this.lastStatus = error.code;\n                this.updateBackoffDuration();\n                this.sendFn(this);\n            }\n            else {\n                this.deferred.reject(bulkWriterError);\n            }\n        }\n        catch (userCallbackError) {\n            this.deferred.reject(userCallbackError);\n        }\n    }\n    updateBackoffDuration() {\n        if (this.lastStatus === 8 /* RESOURCE_EXHAUSTED */) {\n            this._backoffDuration = backoff_1.DEFAULT_BACKOFF_MAX_DELAY_MS;\n        }\n        else if (this._backoffDuration === 0) {\n            this._backoffDuration = backoff_1.DEFAULT_BACKOFF_INITIAL_DELAY_MS;\n        }\n        else {\n            this._backoffDuration *= backoff_1.DEFAULT_BACKOFF_FACTOR;\n        }\n    }\n    onSuccess(result) {\n        try {\n            this.successFn(this.ref, result);\n            this.deferred.resolve(result);\n        }\n        catch (userCallbackError) {\n            this.deferred.reject(userCallbackError);\n        }\n    }\n}\n/**\n * Used to represent a batch on the BatchQueue.\n *\n * @private\n */\nclass BulkCommitBatch extends write_batch_1.WriteBatch {\n    constructor(firestore, maxBatchSize) {\n        super(firestore);\n        // The set of document reference paths present in the WriteBatch.\n        this.docPaths = new Set();\n        // An array of pending write operations. Only contains writes that have not\n        // been resolved.\n        this.pendingOps = [];\n        this.maxBatchSize = maxBatchSize;\n    }\n    has(documentRef) {\n        return this.docPaths.has(documentRef.path);\n    }\n    async bulkCommit(options = {}) {\n        var _a;\n        const tag = (_a = options === null || options === void 0 ? void 0 : options.requestTag) !== null && _a !== void 0 ? _a : util_1.requestTag();\n        // Capture the error stack to preserve stack tracing across async calls.\n        const stack = Error().stack;\n        let response;\n        try {\n            logger_1.logger('BulkCommitBatch.bulkCommit', tag, `Sending next batch with ${this._opCount} writes`);\n            const retryCodes = util_1.getRetryCodes('batchWrite');\n            response = await this._commit({ retryCodes, methodName: 'batchWrite', requestTag: tag });\n        }\n        catch (err) {\n            // Map the failure to each individual write's result.\n            const ops = Array.from({ length: this.pendingOps.length });\n            response = {\n                writeResults: ops.map(() => {\n                    return {};\n                }),\n                status: ops.map(() => err),\n            };\n        }\n        for (let i = 0; i < (response.writeResults || []).length; ++i) {\n            // Since delete operations currently do not have write times, use a\n            // sentinel Timestamp value.\n            // TODO(b/158502664): Use actual delete timestamp.\n            const DELETE_TIMESTAMP_SENTINEL = timestamp_1.Timestamp.fromMillis(0);\n            const status = (response.status || [])[i];\n            if (status.code === 0 /* OK */) {\n                const updateTime = timestamp_1.Timestamp.fromProto(response.writeResults[i].updateTime || DELETE_TIMESTAMP_SENTINEL);\n                this.pendingOps[i].onSuccess(new write_batch_1.WriteResult(updateTime));\n            }\n            else {\n                const error = new (require('google-gax').GoogleError)(status.message || undefined);\n                error.code = status.code;\n                this.pendingOps[i].onError(util_1.wrapError(error, stack));\n            }\n        }\n    }\n    /**\n     * Helper to update data structures associated with the operation and returns\n     * the result.\n     */\n    processLastOperation(op) {\n        assert(!this.docPaths.has(op.ref.path), 'Batch should not contain writes to the same document');\n        this.docPaths.add(op.ref.path);\n        this.pendingOps.push(op);\n    }\n}\n/**\n * Used to represent a buffered BulkWriterOperation.\n *\n * @private\n */\nclass BufferedOperation {\n    constructor(operation, sendFn) {\n        this.operation = operation;\n        this.sendFn = sendFn;\n    }\n}\n/**\n * The error thrown when a BulkWriter operation fails.\n *\n * @class BulkWriterError\n */\nclass BulkWriterError extends Error {\n    /** @hideconstructor */\n    constructor(\n    /** The status code of the error. */\n    code, \n    /** The error message of the error. */\n    message, \n    /** The document reference the operation was performed on. */\n    documentRef, \n    /** The type of operation performed. */\n    operationType, \n    /** How many times this operation has been attempted unsuccessfully. */\n    failedAttempts) {\n        super(message);\n        this.code = code;\n        this.message = message;\n        this.documentRef = documentRef;\n        this.operationType = operationType;\n        this.failedAttempts = failedAttempts;\n    }\n}\nexports.BulkWriterError = BulkWriterError;\n/**\n * A Firestore BulkWriter that can be used to perform a large number of writes\n * in parallel.\n *\n * @class BulkWriter\n */\nclass BulkWriter {\n    /** @hideconstructor */\n    constructor(firestore, options) {\n        var _a, _b;\n        this.firestore = firestore;\n        /**\n         * The maximum number of writes that can be in a single batch.\n         * Visible for testing.\n         * @private\n         */\n        this._maxBatchSize = MAX_BATCH_SIZE;\n        /**\n         * The batch that is currently used to schedule operations. Once this batch\n         * reaches maximum capacity, a new batch is created.\n         * @private\n         */\n        this._bulkCommitBatch = new BulkCommitBatch(this.firestore, this._maxBatchSize);\n        /**\n         * A pointer to the tail of all active BulkWriter operations. This pointer\n         * is advanced every time a new write is enqueued.\n         * @private\n         */\n        this._lastOp = Promise.resolve();\n        /**\n         * Whether this BulkWriter instance has started to close. Afterwards, no\n         * new operations can be enqueued, except for retry operations scheduled by\n         * the error handler.\n         * @private\n         */\n        this._closing = false;\n        /**\n         * The number of pending operations enqueued on this BulkWriter instance.\n         * An operation is considered pending if BulkWriter has sent it via RPC and\n         * is awaiting the result.\n         * @private\n         */\n        this._pendingOpsCount = 0;\n        /**\n         * An array containing buffered BulkWriter operations after the maximum number\n         * of pending operations has been enqueued.\n         * @private\n         */\n        this._bufferedOperations = [];\n        /**\n         * The maximum number of pending operations that can be enqueued onto this\n         * BulkWriter instance. Once the this number of writes have been enqueued,\n         * subsequent writes are buffered.\n         * @private\n         */\n        this._maxPendingOpCount = DEFAULT_MAXIMUM_PENDING_OPERATIONS_COUNT;\n        /**\n         * The user-provided callback to be run every time a BulkWriter operation\n         * successfully completes.\n         * @private\n         */\n        this._successFn = () => { };\n        /**\n         * The user-provided callback to be run every time a BulkWriter operation\n         * fails.\n         * @private\n         */\n        this._errorFn = error => {\n            const isRetryableDeleteError = error.operationType === 'delete' &&\n                error.code === 13 /* INTERNAL */;\n            const retryCodes = util_1.getRetryCodes('batchWrite');\n            return ((retryCodes.includes(error.code) || isRetryableDeleteError) &&\n                error.failedAttempts < backoff_1.MAX_RETRY_ATTEMPTS);\n        };\n        this.firestore._incrementBulkWritersCount();\n        validateBulkWriterOptions(options);\n        if ((options === null || options === void 0 ? void 0 : options.throttling) === false) {\n            this._rateLimiter = new rate_limiter_1.RateLimiter(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);\n        }\n        else {\n            let startingRate = exports.DEFAULT_INITIAL_OPS_PER_SECOND_LIMIT;\n            let maxRate = exports.DEFAULT_MAXIMUM_OPS_PER_SECOND_LIMIT;\n            if (typeof (options === null || options === void 0 ? void 0 : options.throttling) !== 'boolean') {\n                if (((_a = options === null || options === void 0 ? void 0 : options.throttling) === null || _a === void 0 ? void 0 : _a.maxOpsPerSecond) !== undefined) {\n                    maxRate = options.throttling.maxOpsPerSecond;\n                }\n                if (((_b = options === null || options === void 0 ? void 0 : options.throttling) === null || _b === void 0 ? void 0 : _b.initialOpsPerSecond) !== undefined) {\n                    startingRate = options.throttling.initialOpsPerSecond;\n                }\n                // The initial validation step ensures that the maxOpsPerSecond is\n                // greater than initialOpsPerSecond. If this inequality is true, that\n                // means initialOpsPerSecond was not set and maxOpsPerSecond is less\n                // than the default starting rate.\n                if (maxRate < startingRate) {\n                    startingRate = maxRate;\n                }\n                // Ensure that the batch size is not larger than the number of allowed\n                // operations per second.\n                if (startingRate < this._maxBatchSize) {\n                    this._maxBatchSize = startingRate;\n                }\n            }\n            this._rateLimiter = new rate_limiter_1.RateLimiter(startingRate, RATE_LIMITER_MULTIPLIER, RATE_LIMITER_MULTIPLIER_MILLIS, maxRate);\n        }\n    }\n    // Visible for testing.\n    _getBufferedOperationsCount() {\n        return this._bufferedOperations.length;\n    }\n    // Visible for testing.\n    _setMaxBatchSize(size) {\n        assert(this._bulkCommitBatch.pendingOps.length === 0, 'BulkCommitBatch should be empty');\n        this._maxBatchSize = size;\n        this._bulkCommitBatch = new BulkCommitBatch(this.firestore, size);\n    }\n    // Visible for testing.\n    _setMaxPendingOpCount(newMax) {\n        this._maxPendingOpCount = newMax;\n    }\n    /**\n     * Create a document with the provided data. This single operation will fail\n     * if a document exists at its location.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * created.\n     * @param {T} data The object to serialize as the document.\n     * @returns {Promise<WriteResult>} A promise that resolves with the result of\n     * the write. If the write fails, the promise is rejected with a\n     * [BulkWriterError]{@link BulkWriterError}.\n     *\n     * @example\n     * let bulkWriter = firestore.bulkWriter();\n     * let documentRef = firestore.collection('col').doc();\n     *\n     * bulkWriter\n     *  .create(documentRef, {foo: 'bar'})\n     *  .then(result => {\n     *    console.log('Successfully executed write at: ', result);\n     *  })\n     *  .catch(err => {\n     *    console.log('Write failed with: ', err);\n     *  });\n     * });\n     */\n    create(documentRef, data) {\n        this._verifyNotClosed();\n        const op = this._enqueue(documentRef, 'create', bulkCommitBatch => bulkCommitBatch.create(documentRef, data));\n        util_1.silencePromise(op);\n        return op;\n    }\n    /**\n     * Delete a document from the database.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * deleted.\n     * @param {Precondition=} precondition A precondition to enforce for this\n     * delete.\n     * @param {Timestamp=} precondition.lastUpdateTime If set, enforces that the\n     * document was last updated at lastUpdateTime. Fails the batch if the\n     * document doesn't exist or was last updated at a different time.\n     * @returns {Promise<WriteResult>} A promise that resolves with the result of\n     * the delete. If the delete fails, the promise is rejected with a\n     * [BulkWriterError]{@link BulkWriterError}.\n     *\n     * @example\n     * let bulkWriter = firestore.bulkWriter();\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * bulkWriter\n     *  .delete(documentRef)\n     *  .then(result => {\n     *    console.log('Successfully deleted document');\n     *  })\n     *  .catch(err => {\n     *    console.log('Delete failed with: ', err);\n     *  });\n     * });\n     */\n    delete(documentRef, precondition) {\n        this._verifyNotClosed();\n        const op = this._enqueue(documentRef, 'delete', bulkCommitBatch => bulkCommitBatch.delete(documentRef, precondition));\n        util_1.silencePromise(op);\n        return op;\n    }\n    /**\n     * Write to the document referred to by the provided\n     * [DocumentReference]{@link DocumentReference}. If the document does not\n     * exist yet, it will be created. If you pass [SetOptions]{@link SetOptions}.,\n     * the provided data can be merged into the existing document.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * set.\n     * @param {T} data The object to serialize as the document.\n     * @param {SetOptions=} options An object to configure the set behavior.\n     * @param {boolean=} options.merge - If true, set() merges the values\n     * specified in its data argument. Fields omitted from this set() call remain\n     * untouched.\n     * @param {Array.<string|FieldPath>=} options.mergeFields - If provided, set()\n     * only replaces the specified field paths. Any field path that is not\n     * specified is ignored and remains untouched.\n     * @returns {Promise<WriteResult>} A promise that resolves with the result of\n     * the write. If the write fails, the promise is rejected with a\n     * [BulkWriterError]{@link BulkWriterError}.\n     *\n     *\n     * @example\n     * let bulkWriter = firestore.bulkWriter();\n     * let documentRef = firestore.collection('col').doc();\n     *\n     * bulkWriter\n     *  .set(documentRef, {foo: 'bar'})\n     *  .then(result => {\n     *    console.log('Successfully executed write at: ', result);\n     *  })\n     *  .catch(err => {\n     *    console.log('Write failed with: ', err);\n     *  });\n     * });\n     */\n    set(documentRef, data, options) {\n        this._verifyNotClosed();\n        const op = this._enqueue(documentRef, 'set', bulkCommitBatch => bulkCommitBatch.set(documentRef, data, options));\n        util_1.silencePromise(op);\n        return op;\n    }\n    /**\n     * Update fields of the document referred to by the provided\n     * [DocumentReference]{@link DocumentReference}. If the document doesn't yet\n     * exist, the update fails and the entire batch will be rejected.\n     *\n     * The update() method accepts either an object with field paths encoded as\n     * keys and field values encoded as values, or a variable number of arguments\n     * that alternate between field paths and field values. Nested fields can be\n     * updated by providing dot-separated field path strings or by providing\n     * FieldPath objects.\n     *\n     *\n     * A Precondition restricting this update can be specified as the last\n     * argument.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * updated.\n     * @param {UpdateData|string|FieldPath} dataOrField An object containing the\n     * fields and values with which to update the document or the path of the\n     * first field to update.\n     * @param {...(Precondition|*|string|FieldPath)} preconditionOrValues - An\n     * alternating list of field paths and values to update or a Precondition to\n     * restrict this update\n     * @returns {Promise<WriteResult>} A promise that resolves with the result of\n     * the write. If the write fails, the promise is rejected with a\n     * [BulkWriterError]{@link BulkWriterError}.\n     *\n     * @example\n     * let bulkWriter = firestore.bulkWriter();\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * bulkWriter\n     *  .update(documentRef, {foo: 'bar'})\n     *  .then(result => {\n     *    console.log('Successfully executed write at: ', result);\n     *  })\n     *  .catch(err => {\n     *    console.log('Write failed with: ', err);\n     *  });\n     * });\n     */\n    update(documentRef, dataOrField, ...preconditionOrValues) {\n        this._verifyNotClosed();\n        const op = this._enqueue(documentRef, 'update', bulkCommitBatch => bulkCommitBatch.update(documentRef, dataOrField, ...preconditionOrValues));\n        util_1.silencePromise(op);\n        return op;\n    }\n    /**\n     * Callback function set by {@link BulkWriter#onWriteResult} that is run\n     * every time a {@link BulkWriter} operation successfully completes.\n     *\n     * @callback BulkWriter~successCallback\n     * @param {DocumentReference} documentRef The document reference the\n     * operation was performed on\n     * @param {WriteResult} result The server write time of the operation.\n     */\n    /**\n     * Attaches a listener that is run every time a BulkWriter operation\n     * successfully completes.\n     *\n     * @param {BulkWriter~successCallback} successCallback A callback to be\n     * called every time a BulkWriter operation successfully completes.\n     * @example\n     * let bulkWriter = firestore.bulkWriter();\n     *\n     * bulkWriter\n     *   .onWriteResult((documentRef, result) => {\n     *     console.log(\n     *       'Successfully executed write on document: ',\n     *       documentRef,\n     *       ' at: ',\n     *       result\n     *     );\n     *   });\n     */\n    onWriteResult(successCallback) {\n        this._successFn = successCallback;\n    }\n    /**\n     * Callback function set by {@link BulkWriter#onWriteError} that is run when\n     * a write fails in order to determine whether {@link BulkWriter} should\n     * retry the operation.\n     *\n     * @callback BulkWriter~shouldRetryCallback\n     * @param {BulkWriterError} error The error object with information about the\n     * operation and error.\n     * @returns {boolean} Whether or not to retry the failed operation. Returning\n     * `true` retries the operation. Returning `false` will stop the retry loop.\n     */\n    /**\n     * Attaches an error handler listener that is run every time a BulkWriter\n     * operation fails.\n     *\n     * BulkWriter has a default error handler that retries UNAVAILABLE and\n     * ABORTED errors up to a maximum of 10 failed attempts. When an error\n     * handler is specified, the default error handler will be overwritten.\n     *\n     * @param shouldRetryCallback {BulkWriter~shouldRetryCallback} A callback to\n     * be called every time a BulkWriter operation fails. Returning `true` will\n     * retry the operation. Returning `false` will stop the retry loop.\n     * @example\n     * let bulkWriter = firestore.bulkWriter();\n     *\n     * bulkWriter\n     *   .onWriteError((error) => {\n     *     if (\n     *       error.code === GrpcStatus.UNAVAILABLE &&\n     *       error.failedAttempts < MAX_RETRY_ATTEMPTS\n     *     ) {\n     *       return true;\n     *     } else {\n     *       console.log('Failed write at document: ', error.documentRef);\n     *       return false;\n     *     }\n     *   });\n     */\n    onWriteError(shouldRetryCallback) {\n        this._errorFn = shouldRetryCallback;\n    }\n    /**\n     * Commits all writes that have been enqueued up to this point in parallel.\n     *\n     * Returns a Promise that resolves when all currently queued operations have\n     * been committed. The Promise will never be rejected since the results for\n     * each individual operation are conveyed via their individual Promises.\n     *\n     * The Promise resolves immediately if there are no pending writes. Otherwise,\n     * the Promise waits for all previously issued writes, but it does not wait\n     * for writes that were added after the method is called. If you want to wait\n     * for additional writes, call `flush()` again.\n     *\n     * @return {Promise<void>} A promise that resolves when all enqueued writes\n     * up to this point have been committed.\n     *\n     * @example\n     * let bulkWriter = firestore.bulkWriter();\n     *\n     * bulkWriter.create(documentRef, {foo: 'bar'});\n     * bulkWriter.update(documentRef2, {foo: 'bar'});\n     * bulkWriter.delete(documentRef3);\n     * await flush().then(() => {\n     *   console.log('Executed all writes');\n     * });\n     */\n    flush() {\n        this._verifyNotClosed();\n        this._scheduleCurrentBatch(/* flush= */ true);\n        // Mark the most recent operation as flushed to ensure that the batch\n        // containing it will be sent once it's popped from the buffer.\n        if (this._bufferedOperations.length > 0) {\n            this._bufferedOperations[this._bufferedOperations.length - 1].operation.markFlushed();\n        }\n        return this._lastOp;\n    }\n    /**\n     * Commits all enqueued writes and marks the BulkWriter instance as closed.\n     *\n     * After calling `close()`, calling any method will throw an error. Any\n     * retries scheduled as part of an `onWriteError()` handler will be run\n     * before the `close()` promise resolves.\n     *\n     * Returns a Promise that resolves when there are no more pending writes. The\n     * Promise will never be rejected. Calling this method will send all requests.\n     * The promise resolves immediately if there are no pending writes.\n     *\n     * @return {Promise<void>} A promise that resolves when all enqueued writes\n     * up to this point have been committed.\n     *\n     * @example\n     * let bulkWriter = firestore.bulkWriter();\n     *\n     * bulkWriter.create(documentRef, {foo: 'bar'});\n     * bulkWriter.update(documentRef2, {foo: 'bar'});\n     * bulkWriter.delete(documentRef3);\n     * await close().then(() => {\n     *   console.log('Executed all writes');\n     * });\n     */\n    close() {\n        this._verifyNotClosed();\n        this.firestore._decrementBulkWritersCount();\n        const flushPromise = this.flush();\n        this._closing = true;\n        return flushPromise;\n    }\n    /**\n     * Throws an error if the BulkWriter instance has been closed.\n     * @private\n     */\n    _verifyNotClosed() {\n        if (this._closing) {\n            throw new Error('BulkWriter has already been closed.');\n        }\n    }\n    /**\n     * Sends the current batch and resets `this._bulkCommitBatch`.\n     *\n     * @param flush If provided, keeps re-sending operations until no more\n     * operations are enqueued. This allows retries to resolve as part of a\n     * `flush()` or `close()` call.\n     * @private\n     */\n    _scheduleCurrentBatch(flush = false) {\n        if (this._bulkCommitBatch._opCount === 0)\n            return;\n        const pendingBatch = this._bulkCommitBatch;\n        // Use the write with the longest backoff duration when determining backoff.\n        const highestBackoffDuration = pendingBatch.pendingOps.reduce((prev, cur) => prev.backoffDuration > cur.backoffDuration ? prev : cur).backoffDuration;\n        const backoffMsWithJitter = BulkWriter._applyJitter(highestBackoffDuration);\n        const delayedExecution = new util_1.Deferred();\n        // A backoff duration greater than 0 implies that this batch is a retry.\n        // Retried writes are sent with a batch size of 10 in order to guarantee\n        // that the batch is under the 10MiB limit.\n        const maxBatchSize = highestBackoffDuration > 0 ? exports.RETRY_MAX_BATCH_SIZE : this._maxBatchSize;\n        this._bulkCommitBatch = new BulkCommitBatch(this.firestore, maxBatchSize);\n        if (backoffMsWithJitter > 0) {\n            backoff_1.delayExecution(() => delayedExecution.resolve(), backoffMsWithJitter);\n        }\n        else {\n            delayedExecution.resolve();\n        }\n        delayedExecution.promise.then(() => this._sendBatch(pendingBatch, flush));\n    }\n    /**\n     * Sends the provided batch once the rate limiter does not require any delay.\n     * @private\n     */\n    async _sendBatch(batch, flush = false) {\n        const tag = util_1.requestTag();\n        // Send the batch if it is does not require any delay, or schedule another\n        // attempt after the appropriate timeout.\n        const underRateLimit = this._rateLimiter.tryMakeRequest(batch._opCount);\n        if (underRateLimit) {\n            await batch.bulkCommit({ requestTag: tag });\n            if (flush)\n                this._scheduleCurrentBatch(flush);\n        }\n        else {\n            const delayMs = this._rateLimiter.getNextRequestDelayMs(batch._opCount);\n            logger_1.logger('BulkWriter._sendBatch', tag, `Backing off for ${delayMs} seconds`);\n            backoff_1.delayExecution(() => this._sendBatch(batch, flush), delayMs);\n        }\n    }\n    /**\n     * Adds a 30% jitter to the provided backoff.\n     *\n     * @private\n     */\n    static _applyJitter(backoffMs) {\n        if (backoffMs === 0)\n            return 0;\n        // Random value in [-0.3, 0.3].\n        const jitter = exports.DEFAULT_JITTER_FACTOR * (Math.random() * 2 - 1);\n        return Math.min(backoff_1.DEFAULT_BACKOFF_MAX_DELAY_MS, backoffMs + jitter * backoffMs);\n    }\n    /**\n     * Schedules and runs the provided operation on the next available batch.\n     * @private\n     */\n    _enqueue(ref, type, enqueueOnBatchCallback) {\n        const bulkWriterOp = new BulkWriterOperation(ref, type, this._sendFn.bind(this, enqueueOnBatchCallback), this._errorFn.bind(this), this._successFn.bind(this));\n        // Advance the `_lastOp` pointer. This ensures that `_lastOp` only resolves\n        // when both the previous and the current write resolves.\n        this._lastOp = this._lastOp.then(() => util_1.silencePromise(bulkWriterOp.promise));\n        // Schedule the operation if the BulkWriter has fewer than the maximum\n        // number of allowed pending operations, or add the operation to the\n        // buffer.\n        if (this._pendingOpsCount < this._maxPendingOpCount) {\n            this._pendingOpsCount++;\n            this._sendFn(enqueueOnBatchCallback, bulkWriterOp);\n        }\n        else {\n            this._bufferedOperations.push(new BufferedOperation(bulkWriterOp, () => {\n                this._pendingOpsCount++;\n                this._sendFn(enqueueOnBatchCallback, bulkWriterOp);\n            }));\n        }\n        // Chain the BulkWriter operation promise with the buffer processing logic\n        // in order to ensure that it runs and that subsequent operations are\n        // enqueued before the next batch is scheduled in `_sendBatch()`.\n        return bulkWriterOp.promise\n            .then(res => {\n            this._pendingOpsCount--;\n            this._processBufferedOps();\n            return res;\n        })\n            .catch(err => {\n            this._pendingOpsCount--;\n            this._processBufferedOps();\n            throw err;\n        });\n    }\n    /**\n     * Manages the pending operation counter and schedules the next BulkWriter\n     * operation if we're under the maximum limit.\n     * @private\n     */\n    _processBufferedOps() {\n        if (this._pendingOpsCount < this._maxPendingOpCount &&\n            this._bufferedOperations.length > 0) {\n            const nextOp = this._bufferedOperations.shift();\n            nextOp.sendFn();\n        }\n    }\n    /**\n     * Schedules the provided operations on current BulkCommitBatch.\n     * Sends the BulkCommitBatch if it reaches maximum capacity.\n     *\n     * @private\n     */\n    _sendFn(enqueueOnBatchCallback, op) {\n        if (this._bulkCommitBatch.has(op.ref)) {\n            // Create a new batch since the backend doesn't support batches with two\n            // writes to the same document.\n            this._scheduleCurrentBatch();\n        }\n        enqueueOnBatchCallback(this._bulkCommitBatch);\n        this._bulkCommitBatch.processLastOperation(op);\n        if (this._bulkCommitBatch._opCount === this._bulkCommitBatch.maxBatchSize) {\n            this._scheduleCurrentBatch();\n        }\n        else if (op.flushed) {\n            // If flush() was called before this operation was enqueued into a batch,\n            // we still need to schedule it.\n            this._scheduleCurrentBatch(/* flush= */ true);\n        }\n    }\n}\nexports.BulkWriter = BulkWriter;\n/**\n * Validates the use of 'value' as BulkWriterOptions.\n *\n * @private\n * @param value The BulkWriterOptions object to validate.\n * @throws if the input is not a valid BulkWriterOptions object.\n */\nfunction validateBulkWriterOptions(value) {\n    if (validate_1.validateOptional(value, { optional: true })) {\n        return;\n    }\n    const argName = 'options';\n    if (!util_1.isObject(value)) {\n        throw new Error(`${validate_1.invalidArgumentMessage(argName, 'bulkWriter() options argument')} Input is not an object.`);\n    }\n    const options = value;\n    if (options.throttling === undefined ||\n        typeof options.throttling === 'boolean') {\n        return;\n    }\n    if (options.throttling.initialOpsPerSecond !== undefined) {\n        validate_1.validateInteger('initialOpsPerSecond', options.throttling.initialOpsPerSecond, {\n            minValue: 1,\n        });\n    }\n    if (options.throttling.maxOpsPerSecond !== undefined) {\n        validate_1.validateInteger('maxOpsPerSecond', options.throttling.maxOpsPerSecond, {\n            minValue: 1,\n        });\n        if (options.throttling.initialOpsPerSecond !== undefined &&\n            options.throttling.initialOpsPerSecond >\n                options.throttling.maxOpsPerSecond) {\n            throw new Error(`${validate_1.invalidArgumentMessage(argName, 'bulkWriter() options argument')} \"maxOpsPerSecond\" cannot be less than \"initialOpsPerSecond\".`);\n        }\n    }\n}\n//# sourceMappingURL=bulk-writer.js.map"]},"metadata":{},"sourceType":"script"}