{"ast":null,"code":"var _slicedToArray = require(\"/Users/suryanandsunil/Desktop/proto1-arizon/lyo-test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _createForOfIteratorHelper = require(\"/Users/suryanandsunil/Desktop/proto1-arizon/lyo-test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _toConsumableArray = require(\"/Users/suryanandsunil/Desktop/proto1-arizon/lyo-test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _objectSpread = require(\"/Users/suryanandsunil/Desktop/proto1-arizon/lyo-test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _classCallCheck = require(\"/Users/suryanandsunil/Desktop/proto1-arizon/lyo-test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/suryanandsunil/Desktop/proto1-arizon/lyo-test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _require = require('zlib'),\n    deflateRawSync = _require.deflateRawSync;\n\nvar _require2 = require('../help/consts'),\n    KEYOBJECT = _require2.KEYOBJECT;\n\nvar generateIV = require('../help/generate_iv');\n\nvar base64url = require('../help/base64url');\n\nvar getKey = require('../help/get_key');\n\nvar isObject = require('../help/is_object');\n\nvar _require3 = require('../help/key_object'),\n    createSecretKey = _require3.createSecretKey;\n\nvar deepClone = require('../help/deep_clone');\n\nvar importKey = require('../jwk/import');\n\nvar _require4 = require('../errors'),\n    JWEInvalid = _require4.JWEInvalid;\n\nvar _require5 = require('../jwa'),\n    check = _require5.check,\n    keyManagementEncrypt = _require5.keyManagementEncrypt,\n    _encrypt = _require5.encrypt;\n\nvar serializers = require('./serializers');\n\nvar generateCEK = require('./generate_cek');\n\nvar validateHeaders = require('./validate_headers');\n\nvar PROCESS_RECIPIENT = Symbol('PROCESS_RECIPIENT');\n\nvar Encrypt = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function Encrypt(cleartext, protectedHeader, aad, unprotectedHeader) {\n    _classCallCheck(this, Encrypt);\n\n    if (!Buffer.isBuffer(cleartext) && typeof cleartext !== 'string') {\n      throw new TypeError('cleartext argument must be a Buffer or a string');\n    }\n\n    cleartext = Buffer.from(cleartext);\n\n    if (aad !== undefined && !Buffer.isBuffer(aad) && typeof aad !== 'string') {\n      throw new TypeError('aad argument must be a Buffer or a string when provided');\n    }\n\n    aad = aad ? Buffer.from(aad) : undefined;\n\n    if (protectedHeader !== undefined && !isObject(protectedHeader)) {\n      throw new TypeError('protectedHeader argument must be a plain object when provided');\n    }\n\n    if (unprotectedHeader !== undefined && !isObject(unprotectedHeader)) {\n      throw new TypeError('unprotectedHeader argument must be a plain object when provided');\n    }\n\n    this._recipients = [];\n    this._cleartext = cleartext;\n    this._aad = aad;\n    this._unprotected = unprotectedHeader ? deepClone(unprotectedHeader) : undefined;\n    this._protected = protectedHeader ? deepClone(protectedHeader) : undefined;\n  }\n  /*\n   * @public\n   */\n\n\n  _createClass(Encrypt, [{\n    key: \"recipient\",\n    value: function recipient(key, header) {\n      key = getKey(key);\n\n      if (header !== undefined && !isObject(header)) {\n        throw new TypeError('header argument must be a plain object when provided');\n      }\n\n      this._recipients.push({\n        key: key,\n        header: header ? deepClone(header) : undefined\n      });\n\n      return this;\n    }\n    /*\n     * @private\n     */\n\n  }, {\n    key: PROCESS_RECIPIENT,\n    value: function value(recipient) {\n      var unprotectedHeader = this._unprotected;\n      var protectedHeader = this._protected;\n      var recipientCount = this._recipients.length;\n\n      var jweHeader = _objectSpread(_objectSpread(_objectSpread({}, protectedHeader), unprotectedHeader), recipient.header);\n\n      var key = recipient.key;\n      var enc = jweHeader.enc;\n      var alg = jweHeader.alg;\n\n      if (key.use === 'sig') {\n        throw new TypeError('a key with \"use\":\"sig\" is not usable for encryption');\n      }\n\n      if (alg === 'dir') {\n        check(key, 'encrypt', enc);\n      } else if (alg) {\n        check(key, 'keyManagementEncrypt', alg);\n      } else {\n        alg = key.alg || _toConsumableArray(key.algorithms('wrapKey'))[0] || _toConsumableArray(key.algorithms('deriveKey'))[0];\n\n        if (alg === 'ECDH-ES' && recipientCount !== 1) {\n          alg = _toConsumableArray(key.algorithms('deriveKey'))[1];\n        }\n\n        if (!alg) {\n          throw new JWEInvalid('could not resolve a usable \"alg\" for a recipient');\n        }\n\n        if (recipientCount === 1) {\n          if (protectedHeader) {\n            protectedHeader.alg = alg;\n          } else {\n            this._protected = {\n              alg: alg\n            };\n          }\n        } else {\n          if (recipient.header) {\n            recipient.header.alg = alg;\n          } else {\n            recipient.header = {\n              alg: alg\n            };\n          }\n        }\n      }\n\n      var wrapped;\n      var generatedHeader;\n\n      if (key.kty === 'oct' && alg === 'dir') {\n        this._cek = importKey(key[KEYOBJECT], {\n          use: 'enc',\n          alg: enc\n        });\n      } else {\n        check(this._cek, 'encrypt', enc);\n\n        var _keyManagementEncrypt = keyManagementEncrypt(alg, key, this._cek[KEYOBJECT].export(), {\n          enc: enc,\n          alg: alg\n        });\n\n        wrapped = _keyManagementEncrypt.wrapped;\n        generatedHeader = _keyManagementEncrypt.header;\n\n        if (alg === 'ECDH-ES') {\n          this._cek = importKey(createSecretKey(wrapped), {\n            use: 'enc',\n            alg: enc\n          });\n        }\n      }\n\n      if (alg === 'dir' || alg === 'ECDH-ES') {\n        recipient.encrypted_key = '';\n      } else {\n        recipient.encrypted_key = base64url.encodeBuffer(wrapped);\n      }\n\n      if (generatedHeader) {\n        recipient.generatedHeader = generatedHeader;\n      }\n    }\n    /*\n     * @public\n     */\n\n  }, {\n    key: \"encrypt\",\n    value: function encrypt(serialization) {\n      var serializer = serializers[serialization];\n\n      if (!serializer) {\n        throw new TypeError('serialization must be one of \"compact\", \"flattened\", \"general\"');\n      }\n\n      if (!this._recipients.length) {\n        throw new JWEInvalid('missing recipients');\n      }\n\n      serializer.validate(this._protected, this._unprotected, this._aad, this._recipients);\n      var enc = validateHeaders(this._protected, this._unprotected, this._recipients, false, this._protected ? this._protected.crit : undefined);\n\n      if (!enc) {\n        enc = 'A128CBC-HS256';\n\n        if (this._protected) {\n          this._protected.enc = enc;\n        } else {\n          this._protected = {\n            enc: enc\n          };\n        }\n      }\n\n      var final = {};\n      this._cek = generateCEK(enc);\n\n      var _iterator = _createForOfIteratorHelper(this._recipients),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var recipient = _step.value;\n          this[PROCESS_RECIPIENT](recipient);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      var iv = generateIV(enc);\n      final.iv = base64url.encodeBuffer(iv);\n\n      if (this._recipients.length === 1 && this._recipients[0].generatedHeader) {\n        var _this$_recipients = _slicedToArray(this._recipients, 1),\n            generatedHeader = _this$_recipients[0].generatedHeader;\n\n        delete this._recipients[0].generatedHeader;\n        this._protected = _objectSpread(_objectSpread({}, this._protected), generatedHeader);\n      }\n\n      if (this._protected) {\n        final.protected = base64url.JSON.encode(this._protected);\n      }\n\n      final.unprotected = this._unprotected;\n      var aad;\n\n      if (this._aad) {\n        final.aad = base64url.encode(this._aad);\n        aad = Buffer.concat([Buffer.from(final.protected || ''), Buffer.from('.'), Buffer.from(final.aad)]);\n      } else {\n        aad = Buffer.from(final.protected || '');\n      }\n\n      var cleartext = this._cleartext;\n\n      if (this._protected && 'zip' in this._protected) {\n        cleartext = deflateRawSync(cleartext);\n      }\n\n      var _encrypt2 = _encrypt(enc, this._cek, cleartext, {\n        iv: iv,\n        aad: aad\n      }),\n          ciphertext = _encrypt2.ciphertext,\n          tag = _encrypt2.tag;\n\n      final.tag = base64url.encodeBuffer(tag);\n      final.ciphertext = base64url.encodeBuffer(ciphertext);\n      return serializer(final, this._recipients);\n    }\n  }]);\n\n  return Encrypt;\n}();\n\nmodule.exports = Encrypt;","map":{"version":3,"sources":["/Users/suryanandsunil/Desktop/proto1-arizon/lyo-test/node_modules/jose/lib/jwe/encrypt.js"],"names":["require","deflateRawSync","KEYOBJECT","generateIV","base64url","getKey","isObject","createSecretKey","deepClone","importKey","JWEInvalid","check","keyManagementEncrypt","encrypt","serializers","generateCEK","validateHeaders","PROCESS_RECIPIENT","Symbol","Encrypt","cleartext","protectedHeader","aad","unprotectedHeader","Buffer","isBuffer","TypeError","from","undefined","_recipients","_cleartext","_aad","_unprotected","_protected","key","header","push","recipient","recipientCount","length","jweHeader","enc","alg","use","algorithms","wrapped","generatedHeader","kty","_cek","export","encrypted_key","encodeBuffer","serialization","serializer","validate","crit","final","iv","protected","JSON","encode","unprotected","concat","ciphertext","tag","module","exports"],"mappings":"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","sourcesContent":["const { deflateRawSync } = require('zlib')\n\nconst { KEYOBJECT } = require('../help/consts')\nconst generateIV = require('../help/generate_iv')\nconst base64url = require('../help/base64url')\nconst getKey = require('../help/get_key')\nconst isObject = require('../help/is_object')\nconst { createSecretKey } = require('../help/key_object')\nconst deepClone = require('../help/deep_clone')\nconst importKey = require('../jwk/import')\nconst { JWEInvalid } = require('../errors')\nconst { check, keyManagementEncrypt, encrypt } = require('../jwa')\n\nconst serializers = require('./serializers')\nconst generateCEK = require('./generate_cek')\nconst validateHeaders = require('./validate_headers')\n\nconst PROCESS_RECIPIENT = Symbol('PROCESS_RECIPIENT')\n\nclass Encrypt {\n  constructor (cleartext, protectedHeader, aad, unprotectedHeader) {\n    if (!Buffer.isBuffer(cleartext) && typeof cleartext !== 'string') {\n      throw new TypeError('cleartext argument must be a Buffer or a string')\n    }\n    cleartext = Buffer.from(cleartext)\n\n    if (aad !== undefined && !Buffer.isBuffer(aad) && typeof aad !== 'string') {\n      throw new TypeError('aad argument must be a Buffer or a string when provided')\n    }\n    aad = aad ? Buffer.from(aad) : undefined\n\n    if (protectedHeader !== undefined && !isObject(protectedHeader)) {\n      throw new TypeError('protectedHeader argument must be a plain object when provided')\n    }\n\n    if (unprotectedHeader !== undefined && !isObject(unprotectedHeader)) {\n      throw new TypeError('unprotectedHeader argument must be a plain object when provided')\n    }\n\n    this._recipients = []\n    this._cleartext = cleartext\n    this._aad = aad\n    this._unprotected = unprotectedHeader ? deepClone(unprotectedHeader) : undefined\n    this._protected = protectedHeader ? deepClone(protectedHeader) : undefined\n  }\n\n  /*\n   * @public\n   */\n  recipient (key, header) {\n    key = getKey(key)\n\n    if (header !== undefined && !isObject(header)) {\n      throw new TypeError('header argument must be a plain object when provided')\n    }\n\n    this._recipients.push({\n      key,\n      header: header ? deepClone(header) : undefined\n    })\n\n    return this\n  }\n\n  /*\n   * @private\n   */\n  [PROCESS_RECIPIENT] (recipient) {\n    const unprotectedHeader = this._unprotected\n    const protectedHeader = this._protected\n    const { length: recipientCount } = this._recipients\n\n    const jweHeader = {\n      ...protectedHeader,\n      ...unprotectedHeader,\n      ...recipient.header\n    }\n    const { key } = recipient\n\n    const enc = jweHeader.enc\n    let alg = jweHeader.alg\n\n    if (key.use === 'sig') {\n      throw new TypeError('a key with \"use\":\"sig\" is not usable for encryption')\n    }\n\n    if (alg === 'dir') {\n      check(key, 'encrypt', enc)\n    } else if (alg) {\n      check(key, 'keyManagementEncrypt', alg)\n    } else {\n      alg = key.alg || [...key.algorithms('wrapKey')][0] || [...key.algorithms('deriveKey')][0]\n\n      if (alg === 'ECDH-ES' && recipientCount !== 1) {\n        alg = [...key.algorithms('deriveKey')][1]\n      }\n\n      if (!alg) {\n        throw new JWEInvalid('could not resolve a usable \"alg\" for a recipient')\n      }\n\n      if (recipientCount === 1) {\n        if (protectedHeader) {\n          protectedHeader.alg = alg\n        } else {\n          this._protected = { alg }\n        }\n      } else {\n        if (recipient.header) {\n          recipient.header.alg = alg\n        } else {\n          recipient.header = { alg }\n        }\n      }\n    }\n\n    let wrapped\n    let generatedHeader\n\n    if (key.kty === 'oct' && alg === 'dir') {\n      this._cek = importKey(key[KEYOBJECT], { use: 'enc', alg: enc })\n    } else {\n      check(this._cek, 'encrypt', enc)\n      ;({ wrapped, header: generatedHeader } = keyManagementEncrypt(alg, key, this._cek[KEYOBJECT].export(), { enc, alg }))\n      if (alg === 'ECDH-ES') {\n        this._cek = importKey(createSecretKey(wrapped), { use: 'enc', alg: enc })\n      }\n    }\n\n    if (alg === 'dir' || alg === 'ECDH-ES') {\n      recipient.encrypted_key = ''\n    } else {\n      recipient.encrypted_key = base64url.encodeBuffer(wrapped)\n    }\n\n    if (generatedHeader) {\n      recipient.generatedHeader = generatedHeader\n    }\n  }\n\n  /*\n   * @public\n   */\n  encrypt (serialization) {\n    const serializer = serializers[serialization]\n    if (!serializer) {\n      throw new TypeError('serialization must be one of \"compact\", \"flattened\", \"general\"')\n    }\n\n    if (!this._recipients.length) {\n      throw new JWEInvalid('missing recipients')\n    }\n\n    serializer.validate(this._protected, this._unprotected, this._aad, this._recipients)\n\n    let enc = validateHeaders(this._protected, this._unprotected, this._recipients, false, this._protected ? this._protected.crit : undefined)\n    if (!enc) {\n      enc = 'A128CBC-HS256'\n      if (this._protected) {\n        this._protected.enc = enc\n      } else {\n        this._protected = { enc }\n      }\n    }\n    const final = {}\n    this._cek = generateCEK(enc)\n\n    for (const recipient of this._recipients) {\n      this[PROCESS_RECIPIENT](recipient)\n    }\n\n    const iv = generateIV(enc)\n    final.iv = base64url.encodeBuffer(iv)\n\n    if (this._recipients.length === 1 && this._recipients[0].generatedHeader) {\n      const [{ generatedHeader }] = this._recipients\n      delete this._recipients[0].generatedHeader\n      this._protected = {\n        ...this._protected,\n        ...generatedHeader\n      }\n    }\n\n    if (this._protected) {\n      final.protected = base64url.JSON.encode(this._protected)\n    }\n    final.unprotected = this._unprotected\n\n    let aad\n    if (this._aad) {\n      final.aad = base64url.encode(this._aad)\n      aad = Buffer.concat([\n        Buffer.from(final.protected || ''),\n        Buffer.from('.'),\n        Buffer.from(final.aad)\n      ])\n    } else {\n      aad = Buffer.from(final.protected || '')\n    }\n\n    let cleartext = this._cleartext\n    if (this._protected && 'zip' in this._protected) {\n      cleartext = deflateRawSync(cleartext)\n    }\n\n    const { ciphertext, tag } = encrypt(enc, this._cek, cleartext, { iv, aad })\n    final.tag = base64url.encodeBuffer(tag)\n    final.ciphertext = base64url.encodeBuffer(ciphertext)\n\n    return serializer(final, this._recipients)\n  }\n}\n\nmodule.exports = Encrypt\n"]},"metadata":{},"sourceType":"script"}