{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n/* global OT */\n\n/** Dependencies */\n\n\nvar _require = require('./errors'),\n    CoreError = _require.CoreError;\n\nvar _require2 = require('./util'),\n    dom = _require2.dom,\n    path = _require2.path,\n    pathOr = _require2.pathOr,\n    properCase = _require2.properCase;\n\nvar _require3 = require('./logging'),\n    message = _require3.message,\n    logAction = _require3.logAction,\n    logVariation = _require3.logVariation;\n/**\n * Default UI propties\n * https://tokbox.com/developer/guides/customize-ui/js/\n */\n\n\nvar defaultCallProperties = {\n  insertMode: 'append',\n  width: '100%',\n  height: '100%',\n  showControls: false,\n  style: {\n    buttonDisplayMode: 'off'\n  }\n};\n\nvar Communication = function Communication(options) {\n  _classCallCheck(this, Communication);\n\n  _initialiseProps.call(this);\n\n  this.validateOptions(options);\n  this.setSession();\n  this.createEventListeners();\n}\n/**\n * Trigger an event through the API layer\n * @param {String} event - The name of the event\n * @param {*} [data]\n */\n\n/**\n * Determine whether or not the party is able to join the call based on\n * the specified connection limit, if any.\n * @return {Boolean}\n */\n\n/**\n * Create a camera publisher object\n * @param {Object} publisherProperties\n * @returns {Promise} <resolve: Object, reject: Error>\n */\n\n/**\n * Publish the local camera stream and update state\n * @param {Object} publisherProperties\n * @returns {Promise} <resolve: empty, reject: Error>\n */\n\n/**\n * Subscribe to a stream and update the state\n * @param {Object} stream - An OpenTok stream object\n * @param {Object} [subsriberOptions]\n * @param {Boolean} [networkTest] - Are we subscribing to our own publisher for a network test?\n * @returns {Promise} <resolve: Object, reject: Error >\n */\n\n/**\n * Unsubscribe from a stream and update the state\n * @param {Object} subscriber - An OpenTok subscriber object\n * @returns {Promise} <resolve: empty>\n */\n\n/**\n * Set session in module scope\n */\n\n/**\n * Subscribe to new stream unless autoSubscribe is set to false\n * @param {Object} stream\n */\n\n/**\n * Update state and trigger corresponding event(s) when stream is destroyed\n * @param {Object} stream\n */\n\n/**\n * Listen for API-level events\n */\n\n/**\n * Start publishing the local camera feed and subscribing to streams in the session\n * @param {Object} publisherProperties\n * @returns {Promise} <resolve: Object, reject: Error>\n */\n\n/**\n * Stop publishing and unsubscribe from all streams\n */\n\n/**\n * Enable/disable local audio or video\n * @param {String} source - 'audio' or 'video'\n * @param {Boolean} enable\n */\n\n/**\n * Enable/disable remote audio or video\n * @param {String} subscriberId\n * @param {String} source - 'audio' or 'video'\n * @param {Boolean} enable\n */\n;\n\nvar _initialiseProps = function _initialiseProps() {\n  var _this = this;\n\n  Object.defineProperty(this, 'validateOptions', {\n    enumerable: true,\n    writable: true,\n    value: function value(options) {\n      var requiredOptions = ['core', 'state', 'analytics'];\n      requiredOptions.forEach(function (option) {\n        if (!options[option]) {\n          throw new CoreError(option + ' is a required option.', 'invalidParameters');\n        }\n      });\n      var callProperties = options.callProperties,\n          screenProperties = options.screenProperties,\n          autoSubscribe = options.autoSubscribe,\n          subscribeOnly = options.subscribeOnly;\n      _this.active = false;\n      _this.core = options.core;\n      _this.state = options.state;\n      _this.analytics = options.analytics;\n      _this.streamContainers = options.streamContainers;\n      _this.callProperties = Object.assign({}, defaultCallProperties, callProperties);\n      _this.connectionLimit = options.connectionLimit || null;\n      _this.autoSubscribe = options.hasOwnProperty('autoSubscribe') ? autoSubscribe : true;\n      _this.subscribeOnly = options.hasOwnProperty('subscribeOnly') ? subscribeOnly : false;\n      _this.screenProperties = Object.assign({}, defaultCallProperties, {\n        videoSource: 'window'\n      }, screenProperties);\n    }\n  });\n  Object.defineProperty(this, 'triggerEvent', {\n    enumerable: true,\n    writable: true,\n    value: function value(event, data) {\n      return _this.core.triggerEvent(event, data);\n    }\n  });\n  Object.defineProperty(this, 'ableToJoin', {\n    enumerable: true,\n    writable: true,\n    value: function value() {\n      var connectionLimit = _this.connectionLimit,\n          state = _this.state;\n\n      if (!connectionLimit) {\n        return true;\n      } // Not using the session here since we're concerned with number of active publishers\n\n\n      var connections = Object.values(state.getStreams()).filter(function (s) {\n        return s.videoType === 'camera';\n      });\n      return connections.length < connectionLimit;\n    }\n  });\n  Object.defineProperty(this, 'createPublisher', {\n    enumerable: true,\n    writable: true,\n    value: function value(publisherProperties) {\n      var callProperties = _this.callProperties,\n          streamContainers = _this.streamContainers;\n      return new Promise(function (resolve, reject) {\n        // TODO: Handle adding 'name' option to props\n        var props = Object.assign({}, callProperties, publisherProperties); // TODO: Figure out how to handle common vs package-specific options\n        // ^^^ This may already be available through package options\n\n        var container = dom.element(streamContainers('publisher', 'camera'));\n        var publisher = OT.initPublisher(container, props, function (error) {\n          error ? reject(error) : resolve(publisher);\n        });\n      });\n    }\n  });\n  Object.defineProperty(this, 'publish', {\n    enumerable: true,\n    writable: true,\n    value: function value(publisherProperties) {\n      var analytics = _this.analytics,\n          state = _this.state,\n          createPublisher = _this.createPublisher,\n          session = _this.session,\n          triggerEvent = _this.triggerEvent,\n          subscribeOnly = _this.subscribeOnly;\n      /**\n       * For subscriber tokens or cases where we just don't want to be seen or heard.\n       */\n\n      if (subscribeOnly) {\n        message('Instance is configured with subscribeOnly set to true. Cannot publish to session');\n        return Promise.resolve();\n      }\n\n      return new Promise(function (resolve, reject) {\n        var onPublish = function onPublish(publisher) {\n          return function (error) {\n            if (error) {\n              reject(error);\n              analytics.log(logAction.startCall, logVariation.fail);\n            } else {\n              analytics.log(logAction.startCall, logVariation.success);\n              state.addPublisher('camera', publisher);\n              resolve(publisher);\n            }\n          };\n        };\n\n        var publishToSession = function publishToSession(publisher) {\n          return session.publish(publisher, onPublish(publisher));\n        };\n\n        var handleError = function handleError(error) {\n          analytics.log(logAction.startCall, logVariation.fail);\n          var errorMessage = error.code === 1010 ? 'Check your network connection' : error.message;\n          triggerEvent('error', errorMessage);\n          reject(error);\n        };\n\n        createPublisher(publisherProperties).then(publishToSession).catch(handleError);\n      });\n    }\n  });\n  Object.defineProperty(this, 'subscribe', {\n    enumerable: true,\n    writable: true,\n    value: function value(stream) {\n      var subscriberProperties = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var networkTest = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var analytics = _this.analytics,\n          state = _this.state,\n          streamContainers = _this.streamContainers,\n          session = _this.session,\n          triggerEvent = _this.triggerEvent,\n          callProperties = _this.callProperties,\n          screenProperties = _this.screenProperties;\n      return new Promise(function (resolve, reject) {\n        var connectionData = void 0;\n        analytics.log(logAction.subscribe, logVariation.attempt);\n        var streamMap = state.getStreamMap();\n        var streamId = stream.streamId; // No videoType indicates SIP https://tokbox.com/developer/guides/sip/\n\n        var type = pathOr('sip', 'videoType', stream);\n\n        if (streamMap[streamId] && !networkTest) {\n          // Are we already subscribing to the stream?\n          var _state$all = state.all(),\n              subscribers = _state$all.subscribers;\n\n          resolve(subscribers[type][streamMap[streamId]]);\n        } else {\n          try {\n            connectionData = JSON.parse(path(['connection', 'data'], stream) || null);\n          } catch (e) {\n            connectionData = path(['connection', 'data'], stream);\n          }\n\n          var container = dom.element(streamContainers('subscriber', type, connectionData, stream));\n          var options = Object.assign({}, type === 'camera' || type === 'sip' ? callProperties : screenProperties, subscriberProperties);\n          var subscriber = session.subscribe(stream, container, options, function (error) {\n            if (error) {\n              analytics.log(logAction.subscribe, logVariation.fail);\n              reject(error);\n            } else {\n              state.addSubscriber(subscriber);\n              triggerEvent('subscribeTo' + properCase(type), Object.assign({}, {\n                subscriber: subscriber\n              }, state.all()));\n              type === 'screen' && triggerEvent('startViewingSharedScreen', subscriber); // Legacy event\n\n              analytics.log(logAction.subscribe, logVariation.success);\n              resolve(subscriber);\n            }\n          });\n        }\n      });\n    }\n  });\n  Object.defineProperty(this, 'unsubscribe', {\n    enumerable: true,\n    writable: true,\n    value: function value(subscriber) {\n      var analytics = _this.analytics,\n          session = _this.session,\n          state = _this.state;\n      return new Promise(function (resolve) {\n        analytics.log(logAction.unsubscribe, logVariation.attempt);\n        var type = pathOr('sip', 'stream.videoType', subscriber);\n        state.removeSubscriber(type, subscriber);\n        session.unsubscribe(subscriber);\n        analytics.log(logAction.unsubscribe, logVariation.success);\n        resolve();\n      });\n    }\n  });\n  Object.defineProperty(this, 'setSession', {\n    enumerable: true,\n    writable: true,\n    value: function value() {\n      _this.session = _this.state.getSession();\n    }\n  });\n  Object.defineProperty(this, 'onStreamCreated', {\n    enumerable: true,\n    writable: true,\n    value: function value(_ref) {\n      var stream = _ref.stream;\n      return _this.active && _this.autoSubscribe && _this.subscribe(stream);\n    }\n  });\n  Object.defineProperty(this, 'onStreamDestroyed', {\n    enumerable: true,\n    writable: true,\n    value: function value(_ref2) {\n      var stream = _ref2.stream;\n      var state = _this.state,\n          triggerEvent = _this.triggerEvent;\n      state.removeStream(stream);\n      var type = pathOr('sip', 'videoType', stream);\n      type === 'screen' && triggerEvent('endViewingSharedScreen'); // Legacy event\n\n      triggerEvent('unsubscribeFrom' + properCase(type), state.getPubSub());\n    }\n  });\n  Object.defineProperty(this, 'createEventListeners', {\n    enumerable: true,\n    writable: true,\n    value: function value() {\n      var core = _this.core,\n          onStreamCreated = _this.onStreamCreated,\n          onStreamDestroyed = _this.onStreamDestroyed;\n      core.on('streamCreated', onStreamCreated);\n      core.on('streamDestroyed', onStreamDestroyed);\n    }\n  });\n  Object.defineProperty(this, 'startCall', {\n    enumerable: true,\n    writable: true,\n    value: function value(publisherProperties) {\n      var analytics = _this.analytics,\n          state = _this.state,\n          subscribe = _this.subscribe,\n          ableToJoin = _this.ableToJoin,\n          triggerEvent = _this.triggerEvent,\n          autoSubscribe = _this.autoSubscribe,\n          publish = _this.publish;\n      return new Promise(function (resolve, reject) {\n        // eslint-disable-line consistent-return\n        analytics.log(logAction.startCall, logVariation.attempt);\n        _this.active = true;\n        var initialStreamIds = Object.keys(state.getStreams());\n        /**\n         * Determine if we're able to join the session based on an existing connection limit\n         */\n\n        if (!ableToJoin()) {\n          var errorMessage = 'Session has reached its connection limit';\n          triggerEvent('error', errorMessage);\n          analytics.log(logAction.startCall, logVariation.fail);\n          return reject(new CoreError(errorMessage, 'connectionLimit'));\n        }\n        /**\n         * Subscribe to any streams that existed before we start the call from our side.\n         */\n\n\n        var subscribeToInitialStreams = function subscribeToInitialStreams(publisher) {\n          // Get an array of initial subscription promises\n          var initialSubscriptions = function initialSubscriptions() {\n            if (autoSubscribe) {\n              var streams = state.getStreams();\n              return initialStreamIds.map(function (id) {\n                return subscribe(streams[id]);\n              });\n            }\n\n            return [Promise.resolve()];\n          }; // Handle success\n\n\n          var onSubscribeToAll = function onSubscribeToAll() {\n            var pubSubData = Object.assign({}, state.getPubSub(), {\n              publisher: publisher\n            });\n            triggerEvent('startCall', pubSubData);\n            resolve(pubSubData);\n          }; // Handle error\n\n\n          var onError = function onError(reason) {\n            message('Failed to subscribe to all existing streams: ' + reason); // We do not reject here in case we still successfully publish to the session\n\n            resolve(Object.assign({}, _this.state.getPubSub(), {\n              publisher: publisher\n            }));\n          };\n\n          Promise.all(initialSubscriptions()).then(onSubscribeToAll).catch(onError);\n        };\n\n        publish(publisherProperties).then(subscribeToInitialStreams).catch(reject);\n      });\n    }\n  });\n  Object.defineProperty(this, 'endCall', {\n    enumerable: true,\n    writable: true,\n    value: function value() {\n      var analytics = _this.analytics,\n          state = _this.state,\n          session = _this.session,\n          unsubscribe = _this.unsubscribe,\n          triggerEvent = _this.triggerEvent;\n      analytics.log(logAction.endCall, logVariation.attempt);\n\n      var _state$getPubSub = state.getPubSub(),\n          publishers = _state$getPubSub.publishers,\n          subscribers = _state$getPubSub.subscribers;\n\n      var unpublish = function unpublish(publisher) {\n        return session.unpublish(publisher);\n      };\n\n      Object.values(publishers.camera).forEach(unpublish);\n      Object.values(publishers.screen).forEach(unpublish); // TODO Promise.all for unsubsribing\n\n      Object.values(subscribers.camera).forEach(unsubscribe);\n      Object.values(subscribers.screen).forEach(unsubscribe);\n      state.removeAllPublishers();\n      _this.active = false;\n      triggerEvent('endCall');\n      analytics.log(logAction.endCall, logVariation.success);\n    }\n  });\n  Object.defineProperty(this, 'enableLocalAV', {\n    enumerable: true,\n    writable: true,\n    value: function value(id, source, enable) {\n      var method = 'publish' + properCase(source);\n\n      var _state$getPubSub2 = _this.state.getPubSub(),\n          publishers = _state$getPubSub2.publishers;\n\n      publishers.camera[id][method](enable);\n    }\n  });\n  Object.defineProperty(this, 'enableRemoteAV', {\n    enumerable: true,\n    writable: true,\n    value: function value(subscriberId, source, enable) {\n      var method = 'subscribeTo' + properCase(source);\n\n      var _state$getPubSub3 = _this.state.getPubSub(),\n          subscribers = _state$getPubSub3.subscribers;\n\n      var subscriber = subscribers.camera[subscriberId] || subscribers.sip[subscriberId];\n      subscriber[method](enable);\n    }\n  });\n};\n\nexports.default = Communication;","map":{"version":3,"sources":["/Users/suryanandsunil/Desktop/proto1-arizon/lyo-test/node_modules/opentok-accelerator-core/dist/communication.js"],"names":["Object","defineProperty","exports","value","_classCallCheck","instance","Constructor","TypeError","_require","require","CoreError","_require2","dom","path","pathOr","properCase","_require3","message","logAction","logVariation","defaultCallProperties","insertMode","width","height","showControls","style","buttonDisplayMode","Communication","options","_initialiseProps","call","validateOptions","setSession","createEventListeners","_this","enumerable","writable","requiredOptions","forEach","option","callProperties","screenProperties","autoSubscribe","subscribeOnly","active","core","state","analytics","streamContainers","assign","connectionLimit","hasOwnProperty","videoSource","event","data","triggerEvent","connections","values","getStreams","filter","s","videoType","length","publisherProperties","Promise","resolve","reject","props","container","element","publisher","OT","initPublisher","error","createPublisher","session","onPublish","log","startCall","fail","success","addPublisher","publishToSession","publish","handleError","errorMessage","code","then","catch","stream","subscriberProperties","arguments","undefined","networkTest","connectionData","subscribe","attempt","streamMap","getStreamMap","streamId","type","_state$all","all","subscribers","JSON","parse","e","subscriber","addSubscriber","unsubscribe","removeSubscriber","getSession","_ref","_ref2","removeStream","getPubSub","onStreamCreated","onStreamDestroyed","on","ableToJoin","initialStreamIds","keys","subscribeToInitialStreams","initialSubscriptions","streams","map","id","onSubscribeToAll","pubSubData","onError","reason","endCall","_state$getPubSub","publishers","unpublish","camera","screen","removeAllPublishers","source","enable","method","_state$getPubSub2","subscriberId","_state$getPubSub3","sip","default"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;;AAIA,SAASC,eAAT,CAAyBC,QAAzB,EAAmCC,WAAnC,EAAgD;AAAE,MAAI,EAAED,QAAQ,YAAYC,WAAtB,CAAJ,EAAwC;AAAE,UAAM,IAAIC,SAAJ,CAAc,mCAAd,CAAN;AAA2D;AAAE;AAEzJ;;AAEA;;;AACA,IAAIC,QAAQ,GAAGC,OAAO,CAAC,UAAD,CAAtB;AAAA,IACIC,SAAS,GAAGF,QAAQ,CAACE,SADzB;;AAGA,IAAIC,SAAS,GAAGF,OAAO,CAAC,QAAD,CAAvB;AAAA,IACIG,GAAG,GAAGD,SAAS,CAACC,GADpB;AAAA,IAEIC,IAAI,GAAGF,SAAS,CAACE,IAFrB;AAAA,IAGIC,MAAM,GAAGH,SAAS,CAACG,MAHvB;AAAA,IAIIC,UAAU,GAAGJ,SAAS,CAACI,UAJ3B;;AAMA,IAAIC,SAAS,GAAGP,OAAO,CAAC,WAAD,CAAvB;AAAA,IACIQ,OAAO,GAAGD,SAAS,CAACC,OADxB;AAAA,IAEIC,SAAS,GAAGF,SAAS,CAACE,SAF1B;AAAA,IAGIC,YAAY,GAAGH,SAAS,CAACG,YAH7B;AAKA;AACA;AACA;AACA;;;AAGA,IAAIC,qBAAqB,GAAG;AAC1BC,EAAAA,UAAU,EAAE,QADc;AAE1BC,EAAAA,KAAK,EAAE,MAFmB;AAG1BC,EAAAA,MAAM,EAAE,MAHkB;AAI1BC,EAAAA,YAAY,EAAE,KAJY;AAK1BC,EAAAA,KAAK,EAAE;AACLC,IAAAA,iBAAiB,EAAE;AADd;AALmB,CAA5B;;AAUA,IAAIC,aAAa,GAAG,SAASA,aAAT,CAAuBC,OAAvB,EAAgC;AAClDxB,EAAAA,eAAe,CAAC,IAAD,EAAOuB,aAAP,CAAf;;AAEAE,EAAAA,gBAAgB,CAACC,IAAjB,CAAsB,IAAtB;;AAEA,OAAKC,eAAL,CAAqBH,OAArB;AACA,OAAKI,UAAL;AACA,OAAKC,oBAAL;AACD;AACD;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;;AAGA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;;AAGA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AAnGA;;AAsGA,IAAIJ,gBAAgB,GAAG,SAASA,gBAAT,GAA4B;AACjD,MAAIK,KAAK,GAAG,IAAZ;;AAEAlC,EAAAA,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,iBAA5B,EAA+C;AAC7CkC,IAAAA,UAAU,EAAE,IADiC;AAE7CC,IAAAA,QAAQ,EAAE,IAFmC;AAG7CjC,IAAAA,KAAK,EAAE,SAASA,KAAT,CAAeyB,OAAf,EAAwB;AAC7B,UAAIS,eAAe,GAAG,CAAC,MAAD,EAAS,OAAT,EAAkB,WAAlB,CAAtB;AACAA,MAAAA,eAAe,CAACC,OAAhB,CAAwB,UAAUC,MAAV,EAAkB;AACxC,YAAI,CAACX,OAAO,CAACW,MAAD,CAAZ,EAAsB;AACpB,gBAAM,IAAI7B,SAAJ,CAAc6B,MAAM,GAAG,wBAAvB,EAAiD,mBAAjD,CAAN;AACD;AACF,OAJD;AAKA,UAAIC,cAAc,GAAGZ,OAAO,CAACY,cAA7B;AAAA,UACIC,gBAAgB,GAAGb,OAAO,CAACa,gBAD/B;AAAA,UAEIC,aAAa,GAAGd,OAAO,CAACc,aAF5B;AAAA,UAGIC,aAAa,GAAGf,OAAO,CAACe,aAH5B;AAKAT,MAAAA,KAAK,CAACU,MAAN,GAAe,KAAf;AACAV,MAAAA,KAAK,CAACW,IAAN,GAAajB,OAAO,CAACiB,IAArB;AACAX,MAAAA,KAAK,CAACY,KAAN,GAAclB,OAAO,CAACkB,KAAtB;AACAZ,MAAAA,KAAK,CAACa,SAAN,GAAkBnB,OAAO,CAACmB,SAA1B;AACAb,MAAAA,KAAK,CAACc,gBAAN,GAAyBpB,OAAO,CAACoB,gBAAjC;AACAd,MAAAA,KAAK,CAACM,cAAN,GAAuBxC,MAAM,CAACiD,MAAP,CAAc,EAAd,EAAkB7B,qBAAlB,EAAyCoB,cAAzC,CAAvB;AACAN,MAAAA,KAAK,CAACgB,eAAN,GAAwBtB,OAAO,CAACsB,eAAR,IAA2B,IAAnD;AACAhB,MAAAA,KAAK,CAACQ,aAAN,GAAsBd,OAAO,CAACuB,cAAR,CAAuB,eAAvB,IAA0CT,aAA1C,GAA0D,IAAhF;AACAR,MAAAA,KAAK,CAACS,aAAN,GAAsBf,OAAO,CAACuB,cAAR,CAAuB,eAAvB,IAA0CR,aAA1C,GAA0D,KAAhF;AACAT,MAAAA,KAAK,CAACO,gBAAN,GAAyBzC,MAAM,CAACiD,MAAP,CAAc,EAAd,EAAkB7B,qBAAlB,EAAyC;AAAEgC,QAAAA,WAAW,EAAE;AAAf,OAAzC,EAAoEX,gBAApE,CAAzB;AACD;AAzB4C,GAA/C;AA2BAzC,EAAAA,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,cAA5B,EAA4C;AAC1CkC,IAAAA,UAAU,EAAE,IAD8B;AAE1CC,IAAAA,QAAQ,EAAE,IAFgC;AAG1CjC,IAAAA,KAAK,EAAE,SAASA,KAAT,CAAekD,KAAf,EAAsBC,IAAtB,EAA4B;AACjC,aAAOpB,KAAK,CAACW,IAAN,CAAWU,YAAX,CAAwBF,KAAxB,EAA+BC,IAA/B,CAAP;AACD;AALyC,GAA5C;AAOAtD,EAAAA,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,YAA5B,EAA0C;AACxCkC,IAAAA,UAAU,EAAE,IAD4B;AAExCC,IAAAA,QAAQ,EAAE,IAF8B;AAGxCjC,IAAAA,KAAK,EAAE,SAASA,KAAT,GAAiB;AACtB,UAAI+C,eAAe,GAAGhB,KAAK,CAACgB,eAA5B;AAAA,UACIJ,KAAK,GAAGZ,KAAK,CAACY,KADlB;;AAGA,UAAI,CAACI,eAAL,EAAsB;AACpB,eAAO,IAAP;AACD,OANqB,CAOtB;;;AACA,UAAIM,WAAW,GAAGxD,MAAM,CAACyD,MAAP,CAAcX,KAAK,CAACY,UAAN,EAAd,EAAkCC,MAAlC,CAAyC,UAAUC,CAAV,EAAa;AACtE,eAAOA,CAAC,CAACC,SAAF,KAAgB,QAAvB;AACD,OAFiB,CAAlB;AAGA,aAAOL,WAAW,CAACM,MAAZ,GAAqBZ,eAA5B;AACD;AAfuC,GAA1C;AAiBAlD,EAAAA,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,iBAA5B,EAA+C;AAC7CkC,IAAAA,UAAU,EAAE,IADiC;AAE7CC,IAAAA,QAAQ,EAAE,IAFmC;AAG7CjC,IAAAA,KAAK,EAAE,SAASA,KAAT,CAAe4D,mBAAf,EAAoC;AACzC,UAAIvB,cAAc,GAAGN,KAAK,CAACM,cAA3B;AAAA,UACIQ,gBAAgB,GAAGd,KAAK,CAACc,gBAD7B;AAGA,aAAO,IAAIgB,OAAJ,CAAY,UAAUC,OAAV,EAAmBC,MAAnB,EAA2B;AAC5C;AACA,YAAIC,KAAK,GAAGnE,MAAM,CAACiD,MAAP,CAAc,EAAd,EAAkBT,cAAlB,EAAkCuB,mBAAlC,CAAZ,CAF4C,CAG5C;AACA;;AACA,YAAIK,SAAS,GAAGxD,GAAG,CAACyD,OAAJ,CAAYrB,gBAAgB,CAAC,WAAD,EAAc,QAAd,CAA5B,CAAhB;AACA,YAAIsB,SAAS,GAAGC,EAAE,CAACC,aAAH,CAAiBJ,SAAjB,EAA4BD,KAA5B,EAAmC,UAAUM,KAAV,EAAiB;AAClEA,UAAAA,KAAK,GAAGP,MAAM,CAACO,KAAD,CAAT,GAAmBR,OAAO,CAACK,SAAD,CAA/B;AACD,SAFe,CAAhB;AAGD,OATM,CAAP;AAUD;AAjB4C,GAA/C;AAmBAtE,EAAAA,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,SAA5B,EAAuC;AACrCkC,IAAAA,UAAU,EAAE,IADyB;AAErCC,IAAAA,QAAQ,EAAE,IAF2B;AAGrCjC,IAAAA,KAAK,EAAE,SAASA,KAAT,CAAe4D,mBAAf,EAAoC;AACzC,UAAIhB,SAAS,GAAGb,KAAK,CAACa,SAAtB;AAAA,UACID,KAAK,GAAGZ,KAAK,CAACY,KADlB;AAAA,UAEI4B,eAAe,GAAGxC,KAAK,CAACwC,eAF5B;AAAA,UAGIC,OAAO,GAAGzC,KAAK,CAACyC,OAHpB;AAAA,UAIIpB,YAAY,GAAGrB,KAAK,CAACqB,YAJzB;AAAA,UAKIZ,aAAa,GAAGT,KAAK,CAACS,aAL1B;AAOA;AACN;AACA;;AAEM,UAAIA,aAAJ,EAAmB;AACjB1B,QAAAA,OAAO,CAAC,kFAAD,CAAP;AACA,eAAO+C,OAAO,CAACC,OAAR,EAAP;AACD;;AAED,aAAO,IAAID,OAAJ,CAAY,UAAUC,OAAV,EAAmBC,MAAnB,EAA2B;AAC5C,YAAIU,SAAS,GAAG,SAASA,SAAT,CAAmBN,SAAnB,EAA8B;AAC5C,iBAAO,UAAUG,KAAV,EAAiB;AACtB,gBAAIA,KAAJ,EAAW;AACTP,cAAAA,MAAM,CAACO,KAAD,CAAN;AACA1B,cAAAA,SAAS,CAAC8B,GAAV,CAAc3D,SAAS,CAAC4D,SAAxB,EAAmC3D,YAAY,CAAC4D,IAAhD;AACD,aAHD,MAGO;AACLhC,cAAAA,SAAS,CAAC8B,GAAV,CAAc3D,SAAS,CAAC4D,SAAxB,EAAmC3D,YAAY,CAAC6D,OAAhD;AACAlC,cAAAA,KAAK,CAACmC,YAAN,CAAmB,QAAnB,EAA6BX,SAA7B;AACAL,cAAAA,OAAO,CAACK,SAAD,CAAP;AACD;AACF,WATD;AAUD,SAXD;;AAaA,YAAIY,gBAAgB,GAAG,SAASA,gBAAT,CAA0BZ,SAA1B,EAAqC;AAC1D,iBAAOK,OAAO,CAACQ,OAAR,CAAgBb,SAAhB,EAA2BM,SAAS,CAACN,SAAD,CAApC,CAAP;AACD,SAFD;;AAIA,YAAIc,WAAW,GAAG,SAASA,WAAT,CAAqBX,KAArB,EAA4B;AAC5C1B,UAAAA,SAAS,CAAC8B,GAAV,CAAc3D,SAAS,CAAC4D,SAAxB,EAAmC3D,YAAY,CAAC4D,IAAhD;AACA,cAAIM,YAAY,GAAGZ,KAAK,CAACa,IAAN,KAAe,IAAf,GAAsB,+BAAtB,GAAwDb,KAAK,CAACxD,OAAjF;AACAsC,UAAAA,YAAY,CAAC,OAAD,EAAU8B,YAAV,CAAZ;AACAnB,UAAAA,MAAM,CAACO,KAAD,CAAN;AACD,SALD;;AAOAC,QAAAA,eAAe,CAACX,mBAAD,CAAf,CAAqCwB,IAArC,CAA0CL,gBAA1C,EAA4DM,KAA5D,CAAkEJ,WAAlE;AACD,OA1BM,CAAP;AA2BD;AA/CoC,GAAvC;AAiDApF,EAAAA,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,WAA5B,EAAyC;AACvCkC,IAAAA,UAAU,EAAE,IAD2B;AAEvCC,IAAAA,QAAQ,EAAE,IAF6B;AAGvCjC,IAAAA,KAAK,EAAE,SAASA,KAAT,CAAesF,MAAf,EAAuB;AAC5B,UAAIC,oBAAoB,GAAGC,SAAS,CAAC7B,MAAV,GAAmB,CAAnB,IAAwB6B,SAAS,CAAC,CAAD,CAAT,KAAiBC,SAAzC,GAAqDD,SAAS,CAAC,CAAD,CAA9D,GAAoE,EAA/F;AACA,UAAIE,WAAW,GAAGF,SAAS,CAAC7B,MAAV,GAAmB,CAAnB,IAAwB6B,SAAS,CAAC,CAAD,CAAT,KAAiBC,SAAzC,GAAqDD,SAAS,CAAC,CAAD,CAA9D,GAAoE,KAAtF;AACA,UAAI5C,SAAS,GAAGb,KAAK,CAACa,SAAtB;AAAA,UACID,KAAK,GAAGZ,KAAK,CAACY,KADlB;AAAA,UAEIE,gBAAgB,GAAGd,KAAK,CAACc,gBAF7B;AAAA,UAGI2B,OAAO,GAAGzC,KAAK,CAACyC,OAHpB;AAAA,UAIIpB,YAAY,GAAGrB,KAAK,CAACqB,YAJzB;AAAA,UAKIf,cAAc,GAAGN,KAAK,CAACM,cAL3B;AAAA,UAMIC,gBAAgB,GAAGP,KAAK,CAACO,gBAN7B;AAQA,aAAO,IAAIuB,OAAJ,CAAY,UAAUC,OAAV,EAAmBC,MAAnB,EAA2B;AAC5C,YAAI4B,cAAc,GAAG,KAAK,CAA1B;AACA/C,QAAAA,SAAS,CAAC8B,GAAV,CAAc3D,SAAS,CAAC6E,SAAxB,EAAmC5E,YAAY,CAAC6E,OAAhD;AACA,YAAIC,SAAS,GAAGnD,KAAK,CAACoD,YAAN,EAAhB;AACA,YAAIC,QAAQ,GAAGV,MAAM,CAACU,QAAtB,CAJ4C,CAK5C;;AAEA,YAAIC,IAAI,GAAGtF,MAAM,CAAC,KAAD,EAAQ,WAAR,EAAqB2E,MAArB,CAAjB;;AACA,YAAIQ,SAAS,CAACE,QAAD,CAAT,IAAuB,CAACN,WAA5B,EAAyC;AACvC;AACA,cAAIQ,UAAU,GAAGvD,KAAK,CAACwD,GAAN,EAAjB;AAAA,cACIC,WAAW,GAAGF,UAAU,CAACE,WAD7B;;AAGAtC,UAAAA,OAAO,CAACsC,WAAW,CAACH,IAAD,CAAX,CAAkBH,SAAS,CAACE,QAAD,CAA3B,CAAD,CAAP;AACD,SAND,MAMO;AACL,cAAI;AACFL,YAAAA,cAAc,GAAGU,IAAI,CAACC,KAAL,CAAW5F,IAAI,CAAC,CAAC,YAAD,EAAe,MAAf,CAAD,EAAyB4E,MAAzB,CAAJ,IAAwC,IAAnD,CAAjB;AACD,WAFD,CAEE,OAAOiB,CAAP,EAAU;AACVZ,YAAAA,cAAc,GAAGjF,IAAI,CAAC,CAAC,YAAD,EAAe,MAAf,CAAD,EAAyB4E,MAAzB,CAArB;AACD;;AACD,cAAIrB,SAAS,GAAGxD,GAAG,CAACyD,OAAJ,CAAYrB,gBAAgB,CAAC,YAAD,EAAeoD,IAAf,EAAqBN,cAArB,EAAqCL,MAArC,CAA5B,CAAhB;AACA,cAAI7D,OAAO,GAAG5B,MAAM,CAACiD,MAAP,CAAc,EAAd,EAAkBmD,IAAI,KAAK,QAAT,IAAqBA,IAAI,KAAK,KAA9B,GAAsC5D,cAAtC,GAAuDC,gBAAzE,EAA2FiD,oBAA3F,CAAd;AACA,cAAIiB,UAAU,GAAGhC,OAAO,CAACoB,SAAR,CAAkBN,MAAlB,EAA0BrB,SAA1B,EAAqCxC,OAArC,EAA8C,UAAU6C,KAAV,EAAiB;AAC9E,gBAAIA,KAAJ,EAAW;AACT1B,cAAAA,SAAS,CAAC8B,GAAV,CAAc3D,SAAS,CAAC6E,SAAxB,EAAmC5E,YAAY,CAAC4D,IAAhD;AACAb,cAAAA,MAAM,CAACO,KAAD,CAAN;AACD,aAHD,MAGO;AACL3B,cAAAA,KAAK,CAAC8D,aAAN,CAAoBD,UAApB;AACApD,cAAAA,YAAY,CAAC,gBAAgBxC,UAAU,CAACqF,IAAD,CAA3B,EAAmCpG,MAAM,CAACiD,MAAP,CAAc,EAAd,EAAkB;AAAE0D,gBAAAA,UAAU,EAAEA;AAAd,eAAlB,EAA8C7D,KAAK,CAACwD,GAAN,EAA9C,CAAnC,CAAZ;AACAF,cAAAA,IAAI,KAAK,QAAT,IAAqB7C,YAAY,CAAC,0BAAD,EAA6BoD,UAA7B,CAAjC,CAHK,CAGsE;;AAC3E5D,cAAAA,SAAS,CAAC8B,GAAV,CAAc3D,SAAS,CAAC6E,SAAxB,EAAmC5E,YAAY,CAAC6D,OAAhD;AACAf,cAAAA,OAAO,CAAC0C,UAAD,CAAP;AACD;AACF,WAXgB,CAAjB;AAYD;AACF,OAnCM,CAAP;AAoCD;AAlDsC,GAAzC;AAoDA3G,EAAAA,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,aAA5B,EAA2C;AACzCkC,IAAAA,UAAU,EAAE,IAD6B;AAEzCC,IAAAA,QAAQ,EAAE,IAF+B;AAGzCjC,IAAAA,KAAK,EAAE,SAASA,KAAT,CAAewG,UAAf,EAA2B;AAChC,UAAI5D,SAAS,GAAGb,KAAK,CAACa,SAAtB;AAAA,UACI4B,OAAO,GAAGzC,KAAK,CAACyC,OADpB;AAAA,UAEI7B,KAAK,GAAGZ,KAAK,CAACY,KAFlB;AAIA,aAAO,IAAIkB,OAAJ,CAAY,UAAUC,OAAV,EAAmB;AACpClB,QAAAA,SAAS,CAAC8B,GAAV,CAAc3D,SAAS,CAAC2F,WAAxB,EAAqC1F,YAAY,CAAC6E,OAAlD;AACA,YAAII,IAAI,GAAGtF,MAAM,CAAC,KAAD,EAAQ,kBAAR,EAA4B6F,UAA5B,CAAjB;AACA7D,QAAAA,KAAK,CAACgE,gBAAN,CAAuBV,IAAvB,EAA6BO,UAA7B;AACAhC,QAAAA,OAAO,CAACkC,WAAR,CAAoBF,UAApB;AACA5D,QAAAA,SAAS,CAAC8B,GAAV,CAAc3D,SAAS,CAAC2F,WAAxB,EAAqC1F,YAAY,CAAC6D,OAAlD;AACAf,QAAAA,OAAO;AACR,OAPM,CAAP;AAQD;AAhBwC,GAA3C;AAkBAjE,EAAAA,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,YAA5B,EAA0C;AACxCkC,IAAAA,UAAU,EAAE,IAD4B;AAExCC,IAAAA,QAAQ,EAAE,IAF8B;AAGxCjC,IAAAA,KAAK,EAAE,SAASA,KAAT,GAAiB;AACtB+B,MAAAA,KAAK,CAACyC,OAAN,GAAgBzC,KAAK,CAACY,KAAN,CAAYiE,UAAZ,EAAhB;AACD;AALuC,GAA1C;AAOA/G,EAAAA,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,iBAA5B,EAA+C;AAC7CkC,IAAAA,UAAU,EAAE,IADiC;AAE7CC,IAAAA,QAAQ,EAAE,IAFmC;AAG7CjC,IAAAA,KAAK,EAAE,SAASA,KAAT,CAAe6G,IAAf,EAAqB;AAC1B,UAAIvB,MAAM,GAAGuB,IAAI,CAACvB,MAAlB;AACA,aAAOvD,KAAK,CAACU,MAAN,IAAgBV,KAAK,CAACQ,aAAtB,IAAuCR,KAAK,CAAC6D,SAAN,CAAgBN,MAAhB,CAA9C;AACD;AAN4C,GAA/C;AAQAzF,EAAAA,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,mBAA5B,EAAiD;AAC/CkC,IAAAA,UAAU,EAAE,IADmC;AAE/CC,IAAAA,QAAQ,EAAE,IAFqC;AAG/CjC,IAAAA,KAAK,EAAE,SAASA,KAAT,CAAe8G,KAAf,EAAsB;AAC3B,UAAIxB,MAAM,GAAGwB,KAAK,CAACxB,MAAnB;AACA,UAAI3C,KAAK,GAAGZ,KAAK,CAACY,KAAlB;AAAA,UACIS,YAAY,GAAGrB,KAAK,CAACqB,YADzB;AAGAT,MAAAA,KAAK,CAACoE,YAAN,CAAmBzB,MAAnB;AACA,UAAIW,IAAI,GAAGtF,MAAM,CAAC,KAAD,EAAQ,WAAR,EAAqB2E,MAArB,CAAjB;AACAW,MAAAA,IAAI,KAAK,QAAT,IAAqB7C,YAAY,CAAC,wBAAD,CAAjC,CAP2B,CAOkC;;AAC7DA,MAAAA,YAAY,CAAC,oBAAoBxC,UAAU,CAACqF,IAAD,CAA/B,EAAuCtD,KAAK,CAACqE,SAAN,EAAvC,CAAZ;AACD;AAZ8C,GAAjD;AAcAnH,EAAAA,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,sBAA5B,EAAoD;AAClDkC,IAAAA,UAAU,EAAE,IADsC;AAElDC,IAAAA,QAAQ,EAAE,IAFwC;AAGlDjC,IAAAA,KAAK,EAAE,SAASA,KAAT,GAAiB;AACtB,UAAI0C,IAAI,GAAGX,KAAK,CAACW,IAAjB;AAAA,UACIuE,eAAe,GAAGlF,KAAK,CAACkF,eAD5B;AAAA,UAEIC,iBAAiB,GAAGnF,KAAK,CAACmF,iBAF9B;AAIAxE,MAAAA,IAAI,CAACyE,EAAL,CAAQ,eAAR,EAAyBF,eAAzB;AACAvE,MAAAA,IAAI,CAACyE,EAAL,CAAQ,iBAAR,EAA2BD,iBAA3B;AACD;AAViD,GAApD;AAYArH,EAAAA,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,WAA5B,EAAyC;AACvCkC,IAAAA,UAAU,EAAE,IAD2B;AAEvCC,IAAAA,QAAQ,EAAE,IAF6B;AAGvCjC,IAAAA,KAAK,EAAE,SAASA,KAAT,CAAe4D,mBAAf,EAAoC;AACzC,UAAIhB,SAAS,GAAGb,KAAK,CAACa,SAAtB;AAAA,UACID,KAAK,GAAGZ,KAAK,CAACY,KADlB;AAAA,UAEIiD,SAAS,GAAG7D,KAAK,CAAC6D,SAFtB;AAAA,UAGIwB,UAAU,GAAGrF,KAAK,CAACqF,UAHvB;AAAA,UAIIhE,YAAY,GAAGrB,KAAK,CAACqB,YAJzB;AAAA,UAKIb,aAAa,GAAGR,KAAK,CAACQ,aAL1B;AAAA,UAMIyC,OAAO,GAAGjD,KAAK,CAACiD,OANpB;AAQA,aAAO,IAAInB,OAAJ,CAAY,UAAUC,OAAV,EAAmBC,MAAnB,EAA2B;AAC5C;AACAnB,QAAAA,SAAS,CAAC8B,GAAV,CAAc3D,SAAS,CAAC4D,SAAxB,EAAmC3D,YAAY,CAAC6E,OAAhD;AAEA9D,QAAAA,KAAK,CAACU,MAAN,GAAe,IAAf;AACA,YAAI4E,gBAAgB,GAAGxH,MAAM,CAACyH,IAAP,CAAY3E,KAAK,CAACY,UAAN,EAAZ,CAAvB;AAEA;AACR;AACA;;AACQ,YAAI,CAAC6D,UAAU,EAAf,EAAmB;AACjB,cAAIlC,YAAY,GAAG,0CAAnB;AACA9B,UAAAA,YAAY,CAAC,OAAD,EAAU8B,YAAV,CAAZ;AACAtC,UAAAA,SAAS,CAAC8B,GAAV,CAAc3D,SAAS,CAAC4D,SAAxB,EAAmC3D,YAAY,CAAC4D,IAAhD;AACA,iBAAOb,MAAM,CAAC,IAAIxD,SAAJ,CAAc2E,YAAd,EAA4B,iBAA5B,CAAD,CAAb;AACD;AAED;AACR;AACA;;;AACQ,YAAIqC,yBAAyB,GAAG,SAASA,yBAAT,CAAmCpD,SAAnC,EAA8C;AAC5E;AACA,cAAIqD,oBAAoB,GAAG,SAASA,oBAAT,GAAgC;AACzD,gBAAIjF,aAAJ,EAAmB;AACjB,kBAAIkF,OAAO,GAAG9E,KAAK,CAACY,UAAN,EAAd;AACA,qBAAO8D,gBAAgB,CAACK,GAAjB,CAAqB,UAAUC,EAAV,EAAc;AACxC,uBAAO/B,SAAS,CAAC6B,OAAO,CAACE,EAAD,CAAR,CAAhB;AACD,eAFM,CAAP;AAGD;;AACD,mBAAO,CAAC9D,OAAO,CAACC,OAAR,EAAD,CAAP;AACD,WARD,CAF4E,CAY5E;;;AACA,cAAI8D,gBAAgB,GAAG,SAASA,gBAAT,GAA4B;AACjD,gBAAIC,UAAU,GAAGhI,MAAM,CAACiD,MAAP,CAAc,EAAd,EAAkBH,KAAK,CAACqE,SAAN,EAAlB,EAAqC;AAAE7C,cAAAA,SAAS,EAAEA;AAAb,aAArC,CAAjB;AACAf,YAAAA,YAAY,CAAC,WAAD,EAAcyE,UAAd,CAAZ;AACA/D,YAAAA,OAAO,CAAC+D,UAAD,CAAP;AACD,WAJD,CAb4E,CAmB5E;;;AACA,cAAIC,OAAO,GAAG,SAASA,OAAT,CAAiBC,MAAjB,EAAyB;AACrCjH,YAAAA,OAAO,CAAC,kDAAkDiH,MAAnD,CAAP,CADqC,CAErC;;AACAjE,YAAAA,OAAO,CAACjE,MAAM,CAACiD,MAAP,CAAc,EAAd,EAAkBf,KAAK,CAACY,KAAN,CAAYqE,SAAZ,EAAlB,EAA2C;AAAE7C,cAAAA,SAAS,EAAEA;AAAb,aAA3C,CAAD,CAAP;AACD,WAJD;;AAMAN,UAAAA,OAAO,CAACsC,GAAR,CAAYqB,oBAAoB,EAAhC,EAAoCpC,IAApC,CAAyCwC,gBAAzC,EAA2DvC,KAA3D,CAAiEyC,OAAjE;AACD,SA3BD;;AA6BA9C,QAAAA,OAAO,CAACpB,mBAAD,CAAP,CAA6BwB,IAA7B,CAAkCmC,yBAAlC,EAA6DlC,KAA7D,CAAmEtB,MAAnE;AACD,OAlDM,CAAP;AAmDD;AA/DsC,GAAzC;AAiEAlE,EAAAA,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,SAA5B,EAAuC;AACrCkC,IAAAA,UAAU,EAAE,IADyB;AAErCC,IAAAA,QAAQ,EAAE,IAF2B;AAGrCjC,IAAAA,KAAK,EAAE,SAASA,KAAT,GAAiB;AACtB,UAAI4C,SAAS,GAAGb,KAAK,CAACa,SAAtB;AAAA,UACID,KAAK,GAAGZ,KAAK,CAACY,KADlB;AAAA,UAEI6B,OAAO,GAAGzC,KAAK,CAACyC,OAFpB;AAAA,UAGIkC,WAAW,GAAG3E,KAAK,CAAC2E,WAHxB;AAAA,UAIItD,YAAY,GAAGrB,KAAK,CAACqB,YAJzB;AAMAR,MAAAA,SAAS,CAAC8B,GAAV,CAAc3D,SAAS,CAACiH,OAAxB,EAAiChH,YAAY,CAAC6E,OAA9C;;AAEA,UAAIoC,gBAAgB,GAAGtF,KAAK,CAACqE,SAAN,EAAvB;AAAA,UACIkB,UAAU,GAAGD,gBAAgB,CAACC,UADlC;AAAA,UAEI9B,WAAW,GAAG6B,gBAAgB,CAAC7B,WAFnC;;AAIA,UAAI+B,SAAS,GAAG,SAASA,SAAT,CAAmBhE,SAAnB,EAA8B;AAC5C,eAAOK,OAAO,CAAC2D,SAAR,CAAkBhE,SAAlB,CAAP;AACD,OAFD;;AAGAtE,MAAAA,MAAM,CAACyD,MAAP,CAAc4E,UAAU,CAACE,MAAzB,EAAiCjG,OAAjC,CAAyCgG,SAAzC;AACAtI,MAAAA,MAAM,CAACyD,MAAP,CAAc4E,UAAU,CAACG,MAAzB,EAAiClG,OAAjC,CAAyCgG,SAAzC,EAjBsB,CAkBtB;;AACAtI,MAAAA,MAAM,CAACyD,MAAP,CAAc8C,WAAW,CAACgC,MAA1B,EAAkCjG,OAAlC,CAA0CuE,WAA1C;AACA7G,MAAAA,MAAM,CAACyD,MAAP,CAAc8C,WAAW,CAACiC,MAA1B,EAAkClG,OAAlC,CAA0CuE,WAA1C;AACA/D,MAAAA,KAAK,CAAC2F,mBAAN;AACAvG,MAAAA,KAAK,CAACU,MAAN,GAAe,KAAf;AACAW,MAAAA,YAAY,CAAC,SAAD,CAAZ;AACAR,MAAAA,SAAS,CAAC8B,GAAV,CAAc3D,SAAS,CAACiH,OAAxB,EAAiChH,YAAY,CAAC6D,OAA9C;AACD;AA5BoC,GAAvC;AA8BAhF,EAAAA,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,eAA5B,EAA6C;AAC3CkC,IAAAA,UAAU,EAAE,IAD+B;AAE3CC,IAAAA,QAAQ,EAAE,IAFiC;AAG3CjC,IAAAA,KAAK,EAAE,SAASA,KAAT,CAAe2H,EAAf,EAAmBY,MAAnB,EAA2BC,MAA3B,EAAmC;AACxC,UAAIC,MAAM,GAAG,YAAY7H,UAAU,CAAC2H,MAAD,CAAnC;;AAEA,UAAIG,iBAAiB,GAAG3G,KAAK,CAACY,KAAN,CAAYqE,SAAZ,EAAxB;AAAA,UACIkB,UAAU,GAAGQ,iBAAiB,CAACR,UADnC;;AAGAA,MAAAA,UAAU,CAACE,MAAX,CAAkBT,EAAlB,EAAsBc,MAAtB,EAA8BD,MAA9B;AACD;AAV0C,GAA7C;AAYA3I,EAAAA,MAAM,CAACC,cAAP,CAAsB,IAAtB,EAA4B,gBAA5B,EAA8C;AAC5CkC,IAAAA,UAAU,EAAE,IADgC;AAE5CC,IAAAA,QAAQ,EAAE,IAFkC;AAG5CjC,IAAAA,KAAK,EAAE,SAASA,KAAT,CAAe2I,YAAf,EAA6BJ,MAA7B,EAAqCC,MAArC,EAA6C;AAClD,UAAIC,MAAM,GAAG,gBAAgB7H,UAAU,CAAC2H,MAAD,CAAvC;;AAEA,UAAIK,iBAAiB,GAAG7G,KAAK,CAACY,KAAN,CAAYqE,SAAZ,EAAxB;AAAA,UACIZ,WAAW,GAAGwC,iBAAiB,CAACxC,WADpC;;AAGA,UAAII,UAAU,GAAGJ,WAAW,CAACgC,MAAZ,CAAmBO,YAAnB,KAAoCvC,WAAW,CAACyC,GAAZ,CAAgBF,YAAhB,CAArD;AACAnC,MAAAA,UAAU,CAACiC,MAAD,CAAV,CAAmBD,MAAnB;AACD;AAX2C,GAA9C;AAaD,CAjWD;;AAmWAzI,OAAO,CAAC+I,OAAR,GAAkBtH,aAAlB","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\n/* global OT */\n\n/** Dependencies */\nvar _require = require('./errors'),\n    CoreError = _require.CoreError;\n\nvar _require2 = require('./util'),\n    dom = _require2.dom,\n    path = _require2.path,\n    pathOr = _require2.pathOr,\n    properCase = _require2.properCase;\n\nvar _require3 = require('./logging'),\n    message = _require3.message,\n    logAction = _require3.logAction,\n    logVariation = _require3.logVariation;\n\n/**\n * Default UI propties\n * https://tokbox.com/developer/guides/customize-ui/js/\n */\n\n\nvar defaultCallProperties = {\n  insertMode: 'append',\n  width: '100%',\n  height: '100%',\n  showControls: false,\n  style: {\n    buttonDisplayMode: 'off'\n  }\n};\n\nvar Communication = function Communication(options) {\n  _classCallCheck(this, Communication);\n\n  _initialiseProps.call(this);\n\n  this.validateOptions(options);\n  this.setSession();\n  this.createEventListeners();\n}\n/**\n * Trigger an event through the API layer\n * @param {String} event - The name of the event\n * @param {*} [data]\n */\n\n\n/**\n * Determine whether or not the party is able to join the call based on\n * the specified connection limit, if any.\n * @return {Boolean}\n */\n\n\n/**\n * Create a camera publisher object\n * @param {Object} publisherProperties\n * @returns {Promise} <resolve: Object, reject: Error>\n */\n\n\n/**\n * Publish the local camera stream and update state\n * @param {Object} publisherProperties\n * @returns {Promise} <resolve: empty, reject: Error>\n */\n\n\n/**\n * Subscribe to a stream and update the state\n * @param {Object} stream - An OpenTok stream object\n * @param {Object} [subsriberOptions]\n * @param {Boolean} [networkTest] - Are we subscribing to our own publisher for a network test?\n * @returns {Promise} <resolve: Object, reject: Error >\n */\n\n\n/**\n * Unsubscribe from a stream and update the state\n * @param {Object} subscriber - An OpenTok subscriber object\n * @returns {Promise} <resolve: empty>\n */\n\n\n/**\n * Set session in module scope\n */\n\n\n/**\n * Subscribe to new stream unless autoSubscribe is set to false\n * @param {Object} stream\n */\n\n\n/**\n * Update state and trigger corresponding event(s) when stream is destroyed\n * @param {Object} stream\n */\n\n\n/**\n * Listen for API-level events\n */\n\n\n/**\n * Start publishing the local camera feed and subscribing to streams in the session\n * @param {Object} publisherProperties\n * @returns {Promise} <resolve: Object, reject: Error>\n */\n\n\n/**\n * Stop publishing and unsubscribe from all streams\n */\n\n\n/**\n * Enable/disable local audio or video\n * @param {String} source - 'audio' or 'video'\n * @param {Boolean} enable\n */\n\n\n/**\n * Enable/disable remote audio or video\n * @param {String} subscriberId\n * @param {String} source - 'audio' or 'video'\n * @param {Boolean} enable\n */\n;\n\nvar _initialiseProps = function _initialiseProps() {\n  var _this = this;\n\n  Object.defineProperty(this, 'validateOptions', {\n    enumerable: true,\n    writable: true,\n    value: function value(options) {\n      var requiredOptions = ['core', 'state', 'analytics'];\n      requiredOptions.forEach(function (option) {\n        if (!options[option]) {\n          throw new CoreError(option + ' is a required option.', 'invalidParameters');\n        }\n      });\n      var callProperties = options.callProperties,\n          screenProperties = options.screenProperties,\n          autoSubscribe = options.autoSubscribe,\n          subscribeOnly = options.subscribeOnly;\n\n      _this.active = false;\n      _this.core = options.core;\n      _this.state = options.state;\n      _this.analytics = options.analytics;\n      _this.streamContainers = options.streamContainers;\n      _this.callProperties = Object.assign({}, defaultCallProperties, callProperties);\n      _this.connectionLimit = options.connectionLimit || null;\n      _this.autoSubscribe = options.hasOwnProperty('autoSubscribe') ? autoSubscribe : true;\n      _this.subscribeOnly = options.hasOwnProperty('subscribeOnly') ? subscribeOnly : false;\n      _this.screenProperties = Object.assign({}, defaultCallProperties, { videoSource: 'window' }, screenProperties);\n    }\n  });\n  Object.defineProperty(this, 'triggerEvent', {\n    enumerable: true,\n    writable: true,\n    value: function value(event, data) {\n      return _this.core.triggerEvent(event, data);\n    }\n  });\n  Object.defineProperty(this, 'ableToJoin', {\n    enumerable: true,\n    writable: true,\n    value: function value() {\n      var connectionLimit = _this.connectionLimit,\n          state = _this.state;\n\n      if (!connectionLimit) {\n        return true;\n      }\n      // Not using the session here since we're concerned with number of active publishers\n      var connections = Object.values(state.getStreams()).filter(function (s) {\n        return s.videoType === 'camera';\n      });\n      return connections.length < connectionLimit;\n    }\n  });\n  Object.defineProperty(this, 'createPublisher', {\n    enumerable: true,\n    writable: true,\n    value: function value(publisherProperties) {\n      var callProperties = _this.callProperties,\n          streamContainers = _this.streamContainers;\n\n      return new Promise(function (resolve, reject) {\n        // TODO: Handle adding 'name' option to props\n        var props = Object.assign({}, callProperties, publisherProperties);\n        // TODO: Figure out how to handle common vs package-specific options\n        // ^^^ This may already be available through package options\n        var container = dom.element(streamContainers('publisher', 'camera'));\n        var publisher = OT.initPublisher(container, props, function (error) {\n          error ? reject(error) : resolve(publisher);\n        });\n      });\n    }\n  });\n  Object.defineProperty(this, 'publish', {\n    enumerable: true,\n    writable: true,\n    value: function value(publisherProperties) {\n      var analytics = _this.analytics,\n          state = _this.state,\n          createPublisher = _this.createPublisher,\n          session = _this.session,\n          triggerEvent = _this.triggerEvent,\n          subscribeOnly = _this.subscribeOnly;\n\n      /**\n       * For subscriber tokens or cases where we just don't want to be seen or heard.\n       */\n\n      if (subscribeOnly) {\n        message('Instance is configured with subscribeOnly set to true. Cannot publish to session');\n        return Promise.resolve();\n      }\n\n      return new Promise(function (resolve, reject) {\n        var onPublish = function onPublish(publisher) {\n          return function (error) {\n            if (error) {\n              reject(error);\n              analytics.log(logAction.startCall, logVariation.fail);\n            } else {\n              analytics.log(logAction.startCall, logVariation.success);\n              state.addPublisher('camera', publisher);\n              resolve(publisher);\n            }\n          };\n        };\n\n        var publishToSession = function publishToSession(publisher) {\n          return session.publish(publisher, onPublish(publisher));\n        };\n\n        var handleError = function handleError(error) {\n          analytics.log(logAction.startCall, logVariation.fail);\n          var errorMessage = error.code === 1010 ? 'Check your network connection' : error.message;\n          triggerEvent('error', errorMessage);\n          reject(error);\n        };\n\n        createPublisher(publisherProperties).then(publishToSession).catch(handleError);\n      });\n    }\n  });\n  Object.defineProperty(this, 'subscribe', {\n    enumerable: true,\n    writable: true,\n    value: function value(stream) {\n      var subscriberProperties = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var networkTest = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var analytics = _this.analytics,\n          state = _this.state,\n          streamContainers = _this.streamContainers,\n          session = _this.session,\n          triggerEvent = _this.triggerEvent,\n          callProperties = _this.callProperties,\n          screenProperties = _this.screenProperties;\n\n      return new Promise(function (resolve, reject) {\n        var connectionData = void 0;\n        analytics.log(logAction.subscribe, logVariation.attempt);\n        var streamMap = state.getStreamMap();\n        var streamId = stream.streamId;\n        // No videoType indicates SIP https://tokbox.com/developer/guides/sip/\n\n        var type = pathOr('sip', 'videoType', stream);\n        if (streamMap[streamId] && !networkTest) {\n          // Are we already subscribing to the stream?\n          var _state$all = state.all(),\n              subscribers = _state$all.subscribers;\n\n          resolve(subscribers[type][streamMap[streamId]]);\n        } else {\n          try {\n            connectionData = JSON.parse(path(['connection', 'data'], stream) || null);\n          } catch (e) {\n            connectionData = path(['connection', 'data'], stream);\n          }\n          var container = dom.element(streamContainers('subscriber', type, connectionData, stream));\n          var options = Object.assign({}, type === 'camera' || type === 'sip' ? callProperties : screenProperties, subscriberProperties);\n          var subscriber = session.subscribe(stream, container, options, function (error) {\n            if (error) {\n              analytics.log(logAction.subscribe, logVariation.fail);\n              reject(error);\n            } else {\n              state.addSubscriber(subscriber);\n              triggerEvent('subscribeTo' + properCase(type), Object.assign({}, { subscriber: subscriber }, state.all()));\n              type === 'screen' && triggerEvent('startViewingSharedScreen', subscriber); // Legacy event\n              analytics.log(logAction.subscribe, logVariation.success);\n              resolve(subscriber);\n            }\n          });\n        }\n      });\n    }\n  });\n  Object.defineProperty(this, 'unsubscribe', {\n    enumerable: true,\n    writable: true,\n    value: function value(subscriber) {\n      var analytics = _this.analytics,\n          session = _this.session,\n          state = _this.state;\n\n      return new Promise(function (resolve) {\n        analytics.log(logAction.unsubscribe, logVariation.attempt);\n        var type = pathOr('sip', 'stream.videoType', subscriber);\n        state.removeSubscriber(type, subscriber);\n        session.unsubscribe(subscriber);\n        analytics.log(logAction.unsubscribe, logVariation.success);\n        resolve();\n      });\n    }\n  });\n  Object.defineProperty(this, 'setSession', {\n    enumerable: true,\n    writable: true,\n    value: function value() {\n      _this.session = _this.state.getSession();\n    }\n  });\n  Object.defineProperty(this, 'onStreamCreated', {\n    enumerable: true,\n    writable: true,\n    value: function value(_ref) {\n      var stream = _ref.stream;\n      return _this.active && _this.autoSubscribe && _this.subscribe(stream);\n    }\n  });\n  Object.defineProperty(this, 'onStreamDestroyed', {\n    enumerable: true,\n    writable: true,\n    value: function value(_ref2) {\n      var stream = _ref2.stream;\n      var state = _this.state,\n          triggerEvent = _this.triggerEvent;\n\n      state.removeStream(stream);\n      var type = pathOr('sip', 'videoType', stream);\n      type === 'screen' && triggerEvent('endViewingSharedScreen'); // Legacy event\n      triggerEvent('unsubscribeFrom' + properCase(type), state.getPubSub());\n    }\n  });\n  Object.defineProperty(this, 'createEventListeners', {\n    enumerable: true,\n    writable: true,\n    value: function value() {\n      var core = _this.core,\n          onStreamCreated = _this.onStreamCreated,\n          onStreamDestroyed = _this.onStreamDestroyed;\n\n      core.on('streamCreated', onStreamCreated);\n      core.on('streamDestroyed', onStreamDestroyed);\n    }\n  });\n  Object.defineProperty(this, 'startCall', {\n    enumerable: true,\n    writable: true,\n    value: function value(publisherProperties) {\n      var analytics = _this.analytics,\n          state = _this.state,\n          subscribe = _this.subscribe,\n          ableToJoin = _this.ableToJoin,\n          triggerEvent = _this.triggerEvent,\n          autoSubscribe = _this.autoSubscribe,\n          publish = _this.publish;\n\n      return new Promise(function (resolve, reject) {\n        // eslint-disable-line consistent-return\n        analytics.log(logAction.startCall, logVariation.attempt);\n\n        _this.active = true;\n        var initialStreamIds = Object.keys(state.getStreams());\n\n        /**\n         * Determine if we're able to join the session based on an existing connection limit\n         */\n        if (!ableToJoin()) {\n          var errorMessage = 'Session has reached its connection limit';\n          triggerEvent('error', errorMessage);\n          analytics.log(logAction.startCall, logVariation.fail);\n          return reject(new CoreError(errorMessage, 'connectionLimit'));\n        }\n\n        /**\n         * Subscribe to any streams that existed before we start the call from our side.\n         */\n        var subscribeToInitialStreams = function subscribeToInitialStreams(publisher) {\n          // Get an array of initial subscription promises\n          var initialSubscriptions = function initialSubscriptions() {\n            if (autoSubscribe) {\n              var streams = state.getStreams();\n              return initialStreamIds.map(function (id) {\n                return subscribe(streams[id]);\n              });\n            }\n            return [Promise.resolve()];\n          };\n\n          // Handle success\n          var onSubscribeToAll = function onSubscribeToAll() {\n            var pubSubData = Object.assign({}, state.getPubSub(), { publisher: publisher });\n            triggerEvent('startCall', pubSubData);\n            resolve(pubSubData);\n          };\n\n          // Handle error\n          var onError = function onError(reason) {\n            message('Failed to subscribe to all existing streams: ' + reason);\n            // We do not reject here in case we still successfully publish to the session\n            resolve(Object.assign({}, _this.state.getPubSub(), { publisher: publisher }));\n          };\n\n          Promise.all(initialSubscriptions()).then(onSubscribeToAll).catch(onError);\n        };\n\n        publish(publisherProperties).then(subscribeToInitialStreams).catch(reject);\n      });\n    }\n  });\n  Object.defineProperty(this, 'endCall', {\n    enumerable: true,\n    writable: true,\n    value: function value() {\n      var analytics = _this.analytics,\n          state = _this.state,\n          session = _this.session,\n          unsubscribe = _this.unsubscribe,\n          triggerEvent = _this.triggerEvent;\n\n      analytics.log(logAction.endCall, logVariation.attempt);\n\n      var _state$getPubSub = state.getPubSub(),\n          publishers = _state$getPubSub.publishers,\n          subscribers = _state$getPubSub.subscribers;\n\n      var unpublish = function unpublish(publisher) {\n        return session.unpublish(publisher);\n      };\n      Object.values(publishers.camera).forEach(unpublish);\n      Object.values(publishers.screen).forEach(unpublish);\n      // TODO Promise.all for unsubsribing\n      Object.values(subscribers.camera).forEach(unsubscribe);\n      Object.values(subscribers.screen).forEach(unsubscribe);\n      state.removeAllPublishers();\n      _this.active = false;\n      triggerEvent('endCall');\n      analytics.log(logAction.endCall, logVariation.success);\n    }\n  });\n  Object.defineProperty(this, 'enableLocalAV', {\n    enumerable: true,\n    writable: true,\n    value: function value(id, source, enable) {\n      var method = 'publish' + properCase(source);\n\n      var _state$getPubSub2 = _this.state.getPubSub(),\n          publishers = _state$getPubSub2.publishers;\n\n      publishers.camera[id][method](enable);\n    }\n  });\n  Object.defineProperty(this, 'enableRemoteAV', {\n    enumerable: true,\n    writable: true,\n    value: function value(subscriberId, source, enable) {\n      var method = 'subscribeTo' + properCase(source);\n\n      var _state$getPubSub3 = _this.state.getPubSub(),\n          subscribers = _state$getPubSub3.subscribers;\n\n      var subscriber = subscribers.camera[subscriberId] || subscribers.sip[subscriberId];\n      subscriber[method](enable);\n    }\n  });\n};\n\nexports.default = Communication;"]},"metadata":{},"sourceType":"script"}