{"ast":null,"code":"var MAX_OCTET = 0x80;\nvar CLASS_UNIVERSAL = 0;\nvar PRIMITIVE_BIT = 0x20;\nvar TAG_SEQ = 0x10;\nvar TAG_INT = 0x02;\nvar ENCODED_TAG_SEQ = TAG_SEQ | PRIMITIVE_BIT | CLASS_UNIVERSAL << 6;\nvar ENCODED_TAG_INT = TAG_INT | CLASS_UNIVERSAL << 6;\n\nvar getParamSize = function getParamSize(keySize) {\n  return (keySize / 8 | 0) + (keySize % 8 === 0 ? 0 : 1);\n};\n\nvar paramBytesForAlg = {\n  ES256: getParamSize(256),\n  ES256K: getParamSize(256),\n  ES384: getParamSize(384),\n  ES512: getParamSize(521)\n};\n\nvar countPadding = function countPadding(buf, start, stop) {\n  var padding = 0;\n\n  while (start + padding < stop && buf[start + padding] === 0) {\n    ++padding;\n  }\n\n  var needsSign = buf[start + padding] >= MAX_OCTET;\n\n  if (needsSign) {\n    --padding;\n  }\n\n  return padding;\n};\n\nmodule.exports.derToJose = function (signature, alg) {\n  if (!Buffer.isBuffer(signature)) {\n    throw new TypeError('ECDSA signature must be a Buffer');\n  }\n\n  if (!paramBytesForAlg[alg]) {\n    throw new Error(\"Unknown algorithm \\\"\".concat(alg, \"\\\"\"));\n  }\n\n  var paramBytes = paramBytesForAlg[alg]; // the DER encoded param should at most be the param size, plus a padding\n  // zero, since due to being a signed integer\n\n  var maxEncodedParamLength = paramBytes + 1;\n  var inputLength = signature.length;\n  var offset = 0;\n\n  if (signature[offset++] !== ENCODED_TAG_SEQ) {\n    throw new Error('Could not find expected \"seq\"');\n  }\n\n  var seqLength = signature[offset++];\n\n  if (seqLength === (MAX_OCTET | 1)) {\n    seqLength = signature[offset++];\n  }\n\n  if (inputLength - offset < seqLength) {\n    throw new Error(\"\\\"seq\\\" specified length of \".concat(seqLength, \"\\\", only \").concat(inputLength - offset, \"\\\" remaining\"));\n  }\n\n  if (signature[offset++] !== ENCODED_TAG_INT) {\n    throw new Error('Could not find expected \"int\" for \"r\"');\n  }\n\n  var rLength = signature[offset++];\n\n  if (inputLength - offset - 2 < rLength) {\n    throw new Error(\"\\\"r\\\" specified length of \\\"\".concat(rLength, \"\\\", only \\\"\").concat(inputLength - offset - 2, \"\\\" available\"));\n  }\n\n  if (maxEncodedParamLength < rLength) {\n    throw new Error(\"\\\"r\\\" specified length of \\\"\".concat(rLength, \"\\\", max of \\\"\").concat(maxEncodedParamLength, \"\\\" is acceptable\"));\n  }\n\n  var rOffset = offset;\n  offset += rLength;\n\n  if (signature[offset++] !== ENCODED_TAG_INT) {\n    throw new Error('Could not find expected \"int\" for \"s\"');\n  }\n\n  var sLength = signature[offset++];\n\n  if (inputLength - offset !== sLength) {\n    throw new Error(\"\\\"s\\\" specified length of \\\"\".concat(sLength, \"\\\", expected \\\"\").concat(inputLength - offset, \"\\\"\"));\n  }\n\n  if (maxEncodedParamLength < sLength) {\n    throw new Error(\"\\\"s\\\" specified length of \\\"\".concat(sLength, \"\\\", max of \\\"\").concat(maxEncodedParamLength, \"\\\" is acceptable\"));\n  }\n\n  var sOffset = offset;\n  offset += sLength;\n\n  if (offset !== inputLength) {\n    throw new Error(\"Expected to consume entire buffer, but \\\"\".concat(inputLength - offset, \"\\\" bytes remain\"));\n  }\n\n  var rPadding = paramBytes - rLength;\n  var sPadding = paramBytes - sLength;\n  var dst = Buffer.allocUnsafe(rPadding + rLength + sPadding + sLength);\n\n  for (offset = 0; offset < rPadding; ++offset) {\n    dst[offset] = 0;\n  }\n\n  signature.copy(dst, offset, rOffset + Math.max(-rPadding, 0), rOffset + rLength);\n  offset = paramBytes;\n\n  for (var o = offset; offset < o + sPadding; ++offset) {\n    dst[offset] = 0;\n  }\n\n  signature.copy(dst, offset, sOffset + Math.max(-sPadding, 0), sOffset + sLength);\n  return dst;\n};\n\nmodule.exports.joseToDer = function (signature, alg) {\n  if (!Buffer.isBuffer(signature)) {\n    throw new TypeError('ECDSA signature must be a Buffer');\n  }\n\n  if (!paramBytesForAlg[alg]) {\n    throw new TypeError(\"Unknown algorithm \\\"\".concat(alg, \"\\\"\"));\n  }\n\n  var paramBytes = paramBytesForAlg[alg];\n  var signatureBytes = signature.length;\n\n  if (signatureBytes !== paramBytes * 2) {\n    throw new Error(\"\\\"\".concat(alg, \"\\\" signatures must be \\\"\").concat(paramBytes * 2, \"\\\" bytes, saw \\\"\").concat(signatureBytes, \"\\\"\"));\n  }\n\n  var rPadding = countPadding(signature, 0, paramBytes);\n  var sPadding = countPadding(signature, paramBytes, signature.length);\n  var rLength = paramBytes - rPadding;\n  var sLength = paramBytes - sPadding;\n  var rsBytes = 1 + 1 + rLength + 1 + 1 + sLength;\n  var shortLength = rsBytes < MAX_OCTET;\n  var dst = Buffer.allocUnsafe((shortLength ? 2 : 3) + rsBytes);\n  var offset = 0;\n  dst[offset++] = ENCODED_TAG_SEQ;\n\n  if (shortLength) {\n    // Bit 8 has value \"0\"\n    // bits 7-1 give the length.\n    dst[offset++] = rsBytes;\n  } else {\n    // Bit 8 of first octet has value \"1\"\n    // bits 7-1 give the number of additional length octets.\n    dst[offset++] = MAX_OCTET | 1; // eslint-disable-line no-tabs\n    // length, base 256\n\n    dst[offset++] = rsBytes & 0xff;\n  }\n\n  dst[offset++] = ENCODED_TAG_INT;\n  dst[offset++] = rLength;\n\n  if (rPadding < 0) {\n    dst[offset++] = 0;\n    offset += signature.copy(dst, offset, 0, paramBytes);\n  } else {\n    offset += signature.copy(dst, offset, rPadding, paramBytes);\n  }\n\n  dst[offset++] = ENCODED_TAG_INT;\n  dst[offset++] = sLength;\n\n  if (sPadding < 0) {\n    dst[offset++] = 0;\n    signature.copy(dst, offset, paramBytes);\n  } else {\n    signature.copy(dst, offset, paramBytes + sPadding);\n  }\n\n  return dst;\n};","map":{"version":3,"sources":["/Users/suryanandsunil/Desktop/proto1-arizon/lyo-test/node_modules/jose/lib/help/ecdsa_signatures.js"],"names":["MAX_OCTET","CLASS_UNIVERSAL","PRIMITIVE_BIT","TAG_SEQ","TAG_INT","ENCODED_TAG_SEQ","ENCODED_TAG_INT","getParamSize","keySize","paramBytesForAlg","ES256","ES256K","ES384","ES512","countPadding","buf","start","stop","padding","needsSign","module","exports","derToJose","signature","alg","Buffer","isBuffer","TypeError","Error","paramBytes","maxEncodedParamLength","inputLength","length","offset","seqLength","rLength","rOffset","sLength","sOffset","rPadding","sPadding","dst","allocUnsafe","copy","Math","max","o","joseToDer","signatureBytes","rsBytes","shortLength"],"mappings":"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","sourcesContent":["const MAX_OCTET = 0x80\nconst CLASS_UNIVERSAL = 0\nconst PRIMITIVE_BIT = 0x20\nconst TAG_SEQ = 0x10\nconst TAG_INT = 0x02\nconst ENCODED_TAG_SEQ = (TAG_SEQ | PRIMITIVE_BIT) | (CLASS_UNIVERSAL << 6)\nconst ENCODED_TAG_INT = TAG_INT | (CLASS_UNIVERSAL << 6)\n\nconst getParamSize = keySize => ((keySize / 8) | 0) + (keySize % 8 === 0 ? 0 : 1)\n\nconst paramBytesForAlg = {\n  ES256: getParamSize(256),\n  ES256K: getParamSize(256),\n  ES384: getParamSize(384),\n  ES512: getParamSize(521)\n}\n\nconst countPadding = (buf, start, stop) => {\n  let padding = 0\n  while (start + padding < stop && buf[start + padding] === 0) {\n    ++padding\n  }\n\n  const needsSign = buf[start + padding] >= MAX_OCTET\n  if (needsSign) {\n    --padding\n  }\n\n  return padding\n}\n\nmodule.exports.derToJose = (signature, alg) => {\n  if (!Buffer.isBuffer(signature)) {\n    throw new TypeError('ECDSA signature must be a Buffer')\n  }\n\n  if (!paramBytesForAlg[alg]) {\n    throw new Error(`Unknown algorithm \"${alg}\"`)\n  }\n\n  const paramBytes = paramBytesForAlg[alg]\n\n  // the DER encoded param should at most be the param size, plus a padding\n  // zero, since due to being a signed integer\n  const maxEncodedParamLength = paramBytes + 1\n\n  const inputLength = signature.length\n\n  let offset = 0\n  if (signature[offset++] !== ENCODED_TAG_SEQ) {\n    throw new Error('Could not find expected \"seq\"')\n  }\n\n  let seqLength = signature[offset++]\n  if (seqLength === (MAX_OCTET | 1)) {\n    seqLength = signature[offset++]\n  }\n\n  if (inputLength - offset < seqLength) {\n    throw new Error(`\"seq\" specified length of ${seqLength}\", only ${inputLength - offset}\" remaining`)\n  }\n\n  if (signature[offset++] !== ENCODED_TAG_INT) {\n    throw new Error('Could not find expected \"int\" for \"r\"')\n  }\n\n  const rLength = signature[offset++]\n\n  if (inputLength - offset - 2 < rLength) {\n    throw new Error(`\"r\" specified length of \"${rLength}\", only \"${inputLength - offset - 2}\" available`)\n  }\n\n  if (maxEncodedParamLength < rLength) {\n    throw new Error(`\"r\" specified length of \"${rLength}\", max of \"${maxEncodedParamLength}\" is acceptable`)\n  }\n\n  const rOffset = offset\n  offset += rLength\n\n  if (signature[offset++] !== ENCODED_TAG_INT) {\n    throw new Error('Could not find expected \"int\" for \"s\"')\n  }\n\n  const sLength = signature[offset++]\n\n  if (inputLength - offset !== sLength) {\n    throw new Error(`\"s\" specified length of \"${sLength}\", expected \"${inputLength - offset}\"`)\n  }\n\n  if (maxEncodedParamLength < sLength) {\n    throw new Error(`\"s\" specified length of \"${sLength}\", max of \"${maxEncodedParamLength}\" is acceptable`)\n  }\n\n  const sOffset = offset\n  offset += sLength\n\n  if (offset !== inputLength) {\n    throw new Error(`Expected to consume entire buffer, but \"${inputLength - offset}\" bytes remain`)\n  }\n\n  const rPadding = paramBytes - rLength\n\n  const sPadding = paramBytes - sLength\n\n  const dst = Buffer.allocUnsafe(rPadding + rLength + sPadding + sLength)\n\n  for (offset = 0; offset < rPadding; ++offset) {\n    dst[offset] = 0\n  }\n  signature.copy(dst, offset, rOffset + Math.max(-rPadding, 0), rOffset + rLength)\n\n  offset = paramBytes\n\n  for (const o = offset; offset < o + sPadding; ++offset) {\n    dst[offset] = 0\n  }\n  signature.copy(dst, offset, sOffset + Math.max(-sPadding, 0), sOffset + sLength)\n\n  return dst\n}\n\nmodule.exports.joseToDer = (signature, alg) => {\n  if (!Buffer.isBuffer(signature)) {\n    throw new TypeError('ECDSA signature must be a Buffer')\n  }\n\n  if (!paramBytesForAlg[alg]) {\n    throw new TypeError(`Unknown algorithm \"${alg}\"`)\n  }\n\n  const paramBytes = paramBytesForAlg[alg]\n\n  const signatureBytes = signature.length\n  if (signatureBytes !== paramBytes * 2) {\n    throw new Error(`\"${alg}\" signatures must be \"${paramBytes * 2}\" bytes, saw \"${signatureBytes}\"`)\n  }\n\n  const rPadding = countPadding(signature, 0, paramBytes)\n  const sPadding = countPadding(signature, paramBytes, signature.length)\n  const rLength = paramBytes - rPadding\n  const sLength = paramBytes - sPadding\n\n  const rsBytes = 1 + 1 + rLength + 1 + 1 + sLength\n\n  const shortLength = rsBytes < MAX_OCTET\n\n  const dst = Buffer.allocUnsafe((shortLength ? 2 : 3) + rsBytes)\n\n  let offset = 0\n  dst[offset++] = ENCODED_TAG_SEQ\n  if (shortLength) {\n    // Bit 8 has value \"0\"\n    // bits 7-1 give the length.\n    dst[offset++] = rsBytes\n  } else {\n    // Bit 8 of first octet has value \"1\"\n    // bits 7-1 give the number of additional length octets.\n    dst[offset++] = MAX_OCTET\t| 1 // eslint-disable-line no-tabs\n    // length, base 256\n    dst[offset++] = rsBytes & 0xff\n  }\n  dst[offset++] = ENCODED_TAG_INT\n  dst[offset++] = rLength\n  if (rPadding < 0) {\n    dst[offset++] = 0\n    offset += signature.copy(dst, offset, 0, paramBytes)\n  } else {\n    offset += signature.copy(dst, offset, rPadding, paramBytes)\n  }\n  dst[offset++] = ENCODED_TAG_INT\n  dst[offset++] = sLength\n  if (sPadding < 0) {\n    dst[offset++] = 0\n    signature.copy(dst, offset, paramBytes)\n  } else {\n    signature.copy(dst, offset, paramBytes + sPadding)\n  }\n\n  return dst\n}\n"]},"metadata":{},"sourceType":"script"}