{"ast":null,"code":"var _toConsumableArray = require(\"/Users/suryanandsunil/Desktop/proto1-arizon/lyo-test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _createForOfIteratorHelper = require(\"/Users/suryanandsunil/Desktop/proto1-arizon/lyo-test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _slicedToArray = require(\"/Users/suryanandsunil/Desktop/proto1-arizon/lyo-test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _objectWithoutProperties = require(\"/Users/suryanandsunil/Desktop/proto1-arizon/lyo-test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectWithoutProperties\");\n\nvar _objectSpread = require(\"/Users/suryanandsunil/Desktop/proto1-arizon/lyo-test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _require = require('zlib'),\n    inflateRawSync = _require.inflateRawSync;\n\nvar base64url = require('../help/base64url');\n\nvar getKey = require('../help/get_key');\n\nvar _require2 = require('../jwks'),\n    KeyStore = _require2.KeyStore;\n\nvar errors = require('../errors');\n\nvar _require3 = require('../jwa'),\n    check = _require3.check,\n    decrypt = _require3.decrypt,\n    keyManagementDecrypt = _require3.keyManagementDecrypt;\n\nvar JWK = require('../jwk');\n\nvar _require4 = require('../help/key_object'),\n    createSecretKey = _require4.createSecretKey;\n\nvar generateCEK = require('./generate_cek');\n\nvar validateHeaders = require('./validate_headers');\n\nvar _require5 = require('./serializers'),\n    resolveSerialization = _require5.detect;\n\nvar SINGLE_RECIPIENT = new Set(['compact', 'flattened']);\n\nvar combineHeader = function combineHeader() {\n  var prot = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var unprotected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var header = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (typeof prot === 'string') {\n    prot = base64url.JSON.decode(prot);\n  }\n\n  var p2s = prot.p2s || unprotected.p2s || header.p2s;\n  var apu = prot.apu || unprotected.apu || header.apu;\n  var apv = prot.apv || unprotected.apv || header.apv;\n  var iv = prot.iv || unprotected.iv || header.iv;\n  var tag = prot.tag || unprotected.tag || header.tag;\n  return _objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, prot), unprotected), header), typeof p2s === 'string' ? {\n    p2s: base64url.decodeToBuffer(p2s)\n  } : undefined), typeof apu === 'string' ? {\n    apu: base64url.decodeToBuffer(apu)\n  } : undefined), typeof apv === 'string' ? {\n    apv: base64url.decodeToBuffer(apv)\n  } : undefined), typeof iv === 'string' ? {\n    iv: base64url.decodeToBuffer(iv)\n  } : undefined), typeof tag === 'string' ? {\n    tag: base64url.decodeToBuffer(tag)\n  } : undefined);\n};\n\nvar validateAlgorithms = function validateAlgorithms(algorithms, option) {\n  if (algorithms !== undefined && (!Array.isArray(algorithms) || algorithms.some(function (s) {\n    return typeof s !== 'string' || !s;\n  }))) {\n    throw new TypeError(\"\\\"\".concat(option, \"\\\" option must be an array of non-empty strings\"));\n  }\n\n  if (!algorithms) {\n    return undefined;\n  }\n\n  return new Set(algorithms);\n};\n/*\n * @public\n */\n\n\nvar jweDecrypt = function jweDecrypt(skipValidateHeaders, serialization, jwe, key) {\n  var _ref = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {},\n      _ref$crit = _ref.crit,\n      crit = _ref$crit === void 0 ? [] : _ref$crit,\n      _ref$complete = _ref.complete,\n      complete = _ref$complete === void 0 ? false : _ref$complete,\n      keyManagementAlgorithms = _ref.keyManagementAlgorithms,\n      contentEncryptionAlgorithms = _ref.contentEncryptionAlgorithms;\n\n  key = getKey(key, true);\n  keyManagementAlgorithms = validateAlgorithms(keyManagementAlgorithms, 'keyManagementAlgorithms');\n  contentEncryptionAlgorithms = validateAlgorithms(contentEncryptionAlgorithms, 'contentEncryptionAlgorithms');\n\n  if (!Array.isArray(crit) || crit.some(function (s) {\n    return typeof s !== 'string' || !s;\n  })) {\n    throw new TypeError('\"crit\" option must be an array of non-empty strings');\n  }\n\n  if (!serialization) {\n    serialization = resolveSerialization(jwe);\n  }\n\n  var alg, ciphertext, enc, encryptedKey, iv, opts, prot, tag, unprotected, cek, aad, header; // treat general format with one recipient as flattened\n  // skips iteration and avoids multi errors in this case\n\n  if (serialization === 'general' && jwe.recipients.length === 1) {\n    serialization = 'flattened';\n\n    var _jwe = jwe,\n        _recipients = _jwe.recipients,\n        _root = _objectWithoutProperties(_jwe, [\"recipients\"]);\n\n    jwe = _objectSpread(_objectSpread({}, _root), _recipients[0]);\n  }\n\n  if (SINGLE_RECIPIENT.has(serialization)) {\n    if (serialization === 'compact') {\n      // compact serialization format\n      var _jwe$split = jwe.split('.');\n\n      var _jwe$split2 = _slicedToArray(_jwe$split, 5);\n\n      prot = _jwe$split2[0];\n      encryptedKey = _jwe$split2[1];\n      iv = _jwe$split2[2];\n      ciphertext = _jwe$split2[3];\n      tag = _jwe$split2[4];\n    } else {\n      // flattened serialization format\n      var _jwe2 = jwe;\n      prot = _jwe2.protected;\n      encryptedKey = _jwe2.encrypted_key;\n      iv = _jwe2.iv;\n      ciphertext = _jwe2.ciphertext;\n      tag = _jwe2.tag;\n      unprotected = _jwe2.unprotected;\n      aad = _jwe2.aad;\n      header = _jwe2.header;\n    }\n\n    if (!skipValidateHeaders) {\n      validateHeaders(prot, unprotected, [{\n        header: header\n      }], true, crit);\n    }\n\n    opts = combineHeader(prot, unprotected, header);\n    var _opts = opts;\n    alg = _opts.alg;\n    enc = _opts.enc;\n\n    if (keyManagementAlgorithms && !keyManagementAlgorithms.has(alg)) {\n      throw new errors.JOSEAlgNotWhitelisted('key management algorithm not whitelisted');\n    }\n\n    if (contentEncryptionAlgorithms && !contentEncryptionAlgorithms.has(enc)) {\n      throw new errors.JOSEAlgNotWhitelisted('content encryption algorithm not whitelisted');\n    }\n\n    if (key instanceof KeyStore) {\n      var keystore = key;\n      var keys;\n\n      if (opts.alg === 'dir') {\n        keys = keystore.all({\n          kid: opts.kid,\n          alg: opts.enc,\n          key_ops: ['decrypt']\n        });\n      } else {\n        keys = keystore.all({\n          kid: opts.kid,\n          alg: opts.alg,\n          key_ops: ['unwrapKey']\n        });\n      }\n\n      switch (keys.length) {\n        case 0:\n          throw new errors.JWKSNoMatchingKey();\n\n        case 1:\n          // treat the call as if a Key instance was passed in\n          // skips iteration and avoids multi errors in this case\n          key = keys[0];\n          break;\n\n        default:\n          {\n            var _errs = [];\n\n            var _iterator = _createForOfIteratorHelper(keys),\n                _step;\n\n            try {\n              for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                var _key = _step.value;\n\n                try {\n                  return jweDecrypt(true, serialization, jwe, _key, {\n                    crit: crit,\n                    complete: complete,\n                    contentEncryptionAlgorithms: contentEncryptionAlgorithms ? _toConsumableArray(contentEncryptionAlgorithms) : undefined,\n                    keyManagementAlgorithms: keyManagementAlgorithms ? _toConsumableArray(keyManagementAlgorithms) : undefined\n                  });\n                } catch (err) {\n                  _errs.push(err);\n\n                  continue;\n                }\n              }\n            } catch (err) {\n              _iterator.e(err);\n            } finally {\n              _iterator.f();\n            }\n\n            var _multi = new errors.JOSEMultiError(_errs);\n\n            if (_toConsumableArray(_multi).some(function (e) {\n              return e instanceof errors.JWEDecryptionFailed;\n            })) {\n              throw new errors.JWEDecryptionFailed();\n            }\n\n            throw _multi;\n          }\n      }\n    }\n\n    check.apply(void 0, [key].concat(_toConsumableArray(alg === 'dir' ? ['decrypt', enc] : ['keyManagementDecrypt', alg])));\n\n    try {\n      if (alg === 'dir') {\n        cek = JWK.asKey(key, {\n          alg: enc,\n          use: 'enc'\n        });\n      } else if (alg === 'ECDH-ES') {\n        var unwrapped = keyManagementDecrypt(alg, key, undefined, opts);\n        cek = JWK.asKey(createSecretKey(unwrapped), {\n          alg: enc,\n          use: 'enc'\n        });\n      } else {\n        var _unwrapped = keyManagementDecrypt(alg, key, base64url.decodeToBuffer(encryptedKey), opts);\n\n        cek = JWK.asKey(createSecretKey(_unwrapped), {\n          alg: enc,\n          use: 'enc'\n        });\n      }\n    } catch (err) {\n      // To mitigate the attacks described in RFC 3218, the\n      // recipient MUST NOT distinguish between format, padding, and length\n      // errors of encrypted keys.  It is strongly recommended, in the event\n      // of receiving an improperly formatted key, that the recipient\n      // substitute a randomly generated CEK and proceed to the next step, to\n      // mitigate timing attacks.\n      cek = generateCEK(enc);\n    }\n\n    var adata;\n\n    if (aad) {\n      adata = Buffer.concat([Buffer.from(prot || ''), Buffer.from('.'), Buffer.from(aad)]);\n    } else {\n      adata = Buffer.from(prot || '');\n    }\n\n    try {\n      iv = base64url.decodeToBuffer(iv);\n    } catch (err) {}\n\n    try {\n      tag = base64url.decodeToBuffer(tag);\n    } catch (err) {}\n\n    var cleartext = decrypt(enc, cek, base64url.decodeToBuffer(ciphertext), {\n      iv: iv,\n      tag: tag,\n      aad: adata\n    });\n\n    if (opts.zip) {\n      cleartext = inflateRawSync(cleartext);\n    }\n\n    if (complete) {\n      var result = {\n        cleartext: cleartext,\n        key: key,\n        cek: cek\n      };\n      if (aad) result.aad = aad;\n      if (header) result.header = header;\n      if (unprotected) result.unprotected = unprotected;\n      if (prot) result.protected = base64url.JSON.decode(prot);\n      return result;\n    }\n\n    return cleartext;\n  }\n\n  validateHeaders(jwe.protected, jwe.unprotected, jwe.recipients.map(function (_ref2) {\n    var header = _ref2.header;\n    return {\n      header: header\n    };\n  }), true, crit); // general serialization format\n\n  var _jwe3 = jwe,\n      recipients = _jwe3.recipients,\n      root = _objectWithoutProperties(_jwe3, [\"recipients\"]);\n\n  var errs = [];\n\n  var _iterator2 = _createForOfIteratorHelper(recipients),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var recipient = _step2.value;\n\n      try {\n        return jweDecrypt(true, 'flattened', _objectSpread(_objectSpread({}, root), recipient), key, {\n          crit: crit,\n          complete: complete,\n          contentEncryptionAlgorithms: contentEncryptionAlgorithms ? _toConsumableArray(contentEncryptionAlgorithms) : undefined,\n          keyManagementAlgorithms: keyManagementAlgorithms ? _toConsumableArray(keyManagementAlgorithms) : undefined\n        });\n      } catch (err) {\n        errs.push(err);\n        continue;\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  var multi = new errors.JOSEMultiError(errs);\n\n  if (_toConsumableArray(multi).some(function (e) {\n    return e instanceof errors.JWEDecryptionFailed;\n  })) {\n    throw new errors.JWEDecryptionFailed();\n  } else if (_toConsumableArray(multi).every(function (e) {\n    return e instanceof errors.JWKSNoMatchingKey;\n  })) {\n    throw new errors.JWKSNoMatchingKey();\n  }\n\n  throw multi;\n};\n\nmodule.exports = jweDecrypt.bind(undefined, false, undefined);","map":{"version":3,"sources":["/Users/suryanandsunil/Desktop/proto1-arizon/lyo-test/node_modules/jose/lib/jwe/decrypt.js"],"names":["require","inflateRawSync","base64url","getKey","KeyStore","errors","check","decrypt","keyManagementDecrypt","JWK","createSecretKey","generateCEK","validateHeaders","resolveSerialization","detect","SINGLE_RECIPIENT","Set","combineHeader","prot","unprotected","header","JSON","decode","p2s","apu","apv","iv","tag","decodeToBuffer","undefined","validateAlgorithms","algorithms","option","Array","isArray","some","s","TypeError","jweDecrypt","skipValidateHeaders","serialization","jwe","key","crit","complete","keyManagementAlgorithms","contentEncryptionAlgorithms","alg","ciphertext","enc","encryptedKey","opts","cek","aad","recipients","length","root","has","split","protected","encrypted_key","JOSEAlgNotWhitelisted","keystore","keys","all","kid","key_ops","JWKSNoMatchingKey","errs","err","push","multi","JOSEMultiError","e","JWEDecryptionFailed","asKey","use","unwrapped","adata","Buffer","concat","from","cleartext","zip","result","map","recipient","every","module","exports","bind"],"mappings":"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","sourcesContent":["const { inflateRawSync } = require('zlib')\n\nconst base64url = require('../help/base64url')\nconst getKey = require('../help/get_key')\nconst { KeyStore } = require('../jwks')\nconst errors = require('../errors')\nconst { check, decrypt, keyManagementDecrypt } = require('../jwa')\nconst JWK = require('../jwk')\n\nconst { createSecretKey } = require('../help/key_object')\nconst generateCEK = require('./generate_cek')\nconst validateHeaders = require('./validate_headers')\nconst { detect: resolveSerialization } = require('./serializers')\n\nconst SINGLE_RECIPIENT = new Set(['compact', 'flattened'])\n\nconst combineHeader = (prot = {}, unprotected = {}, header = {}) => {\n  if (typeof prot === 'string') {\n    prot = base64url.JSON.decode(prot)\n  }\n\n  const p2s = prot.p2s || unprotected.p2s || header.p2s\n  const apu = prot.apu || unprotected.apu || header.apu\n  const apv = prot.apv || unprotected.apv || header.apv\n  const iv = prot.iv || unprotected.iv || header.iv\n  const tag = prot.tag || unprotected.tag || header.tag\n\n  return {\n    ...prot,\n    ...unprotected,\n    ...header,\n    ...(typeof p2s === 'string' ? { p2s: base64url.decodeToBuffer(p2s) } : undefined),\n    ...(typeof apu === 'string' ? { apu: base64url.decodeToBuffer(apu) } : undefined),\n    ...(typeof apv === 'string' ? { apv: base64url.decodeToBuffer(apv) } : undefined),\n    ...(typeof iv === 'string' ? { iv: base64url.decodeToBuffer(iv) } : undefined),\n    ...(typeof tag === 'string' ? { tag: base64url.decodeToBuffer(tag) } : undefined)\n  }\n}\n\nconst validateAlgorithms = (algorithms, option) => {\n  if (algorithms !== undefined && (!Array.isArray(algorithms) || algorithms.some(s => typeof s !== 'string' || !s))) {\n    throw new TypeError(`\"${option}\" option must be an array of non-empty strings`)\n  }\n\n  if (!algorithms) {\n    return undefined\n  }\n\n  return new Set(algorithms)\n}\n\n/*\n * @public\n */\nconst jweDecrypt = (skipValidateHeaders, serialization, jwe, key, { crit = [], complete = false, keyManagementAlgorithms, contentEncryptionAlgorithms } = {}) => {\n  key = getKey(key, true)\n\n  keyManagementAlgorithms = validateAlgorithms(keyManagementAlgorithms, 'keyManagementAlgorithms')\n  contentEncryptionAlgorithms = validateAlgorithms(contentEncryptionAlgorithms, 'contentEncryptionAlgorithms')\n\n  if (!Array.isArray(crit) || crit.some(s => typeof s !== 'string' || !s)) {\n    throw new TypeError('\"crit\" option must be an array of non-empty strings')\n  }\n\n  if (!serialization) {\n    serialization = resolveSerialization(jwe)\n  }\n\n  let alg, ciphertext, enc, encryptedKey, iv, opts, prot, tag, unprotected, cek, aad, header\n\n  // treat general format with one recipient as flattened\n  // skips iteration and avoids multi errors in this case\n  if (serialization === 'general' && jwe.recipients.length === 1) {\n    serialization = 'flattened'\n    const { recipients, ...root } = jwe\n    jwe = { ...root, ...recipients[0] }\n  }\n\n  if (SINGLE_RECIPIENT.has(serialization)) {\n    if (serialization === 'compact') { // compact serialization format\n      ([prot, encryptedKey, iv, ciphertext, tag] = jwe.split('.'))\n    } else { // flattened serialization format\n      ({ protected: prot, encrypted_key: encryptedKey, iv, ciphertext, tag, unprotected, aad, header } = jwe)\n    }\n\n    if (!skipValidateHeaders) {\n      validateHeaders(prot, unprotected, [{ header }], true, crit)\n    }\n\n    opts = combineHeader(prot, unprotected, header)\n\n    ;({ alg, enc } = opts)\n\n    if (keyManagementAlgorithms && !keyManagementAlgorithms.has(alg)) {\n      throw new errors.JOSEAlgNotWhitelisted('key management algorithm not whitelisted')\n    }\n\n    if (contentEncryptionAlgorithms && !contentEncryptionAlgorithms.has(enc)) {\n      throw new errors.JOSEAlgNotWhitelisted('content encryption algorithm not whitelisted')\n    }\n\n    if (key instanceof KeyStore) {\n      const keystore = key\n      let keys\n      if (opts.alg === 'dir') {\n        keys = keystore.all({ kid: opts.kid, alg: opts.enc, key_ops: ['decrypt'] })\n      } else {\n        keys = keystore.all({ kid: opts.kid, alg: opts.alg, key_ops: ['unwrapKey'] })\n      }\n      switch (keys.length) {\n        case 0:\n          throw new errors.JWKSNoMatchingKey()\n        case 1:\n          // treat the call as if a Key instance was passed in\n          // skips iteration and avoids multi errors in this case\n          key = keys[0]\n          break\n        default: {\n          const errs = []\n          for (const key of keys) {\n            try {\n              return jweDecrypt(true, serialization, jwe, key, {\n                crit,\n                complete,\n                contentEncryptionAlgorithms: contentEncryptionAlgorithms ? [...contentEncryptionAlgorithms] : undefined,\n                keyManagementAlgorithms: keyManagementAlgorithms ? [...keyManagementAlgorithms] : undefined\n              })\n            } catch (err) {\n              errs.push(err)\n              continue\n            }\n          }\n\n          const multi = new errors.JOSEMultiError(errs)\n          if ([...multi].some(e => e instanceof errors.JWEDecryptionFailed)) {\n            throw new errors.JWEDecryptionFailed()\n          }\n          throw multi\n        }\n      }\n    }\n\n    check(key, ...(alg === 'dir' ? ['decrypt', enc] : ['keyManagementDecrypt', alg]))\n\n    try {\n      if (alg === 'dir') {\n        cek = JWK.asKey(key, { alg: enc, use: 'enc' })\n      } else if (alg === 'ECDH-ES') {\n        const unwrapped = keyManagementDecrypt(alg, key, undefined, opts)\n        cek = JWK.asKey(createSecretKey(unwrapped), { alg: enc, use: 'enc' })\n      } else {\n        const unwrapped = keyManagementDecrypt(alg, key, base64url.decodeToBuffer(encryptedKey), opts)\n        cek = JWK.asKey(createSecretKey(unwrapped), { alg: enc, use: 'enc' })\n      }\n    } catch (err) {\n      // To mitigate the attacks described in RFC 3218, the\n      // recipient MUST NOT distinguish between format, padding, and length\n      // errors of encrypted keys.  It is strongly recommended, in the event\n      // of receiving an improperly formatted key, that the recipient\n      // substitute a randomly generated CEK and proceed to the next step, to\n      // mitigate timing attacks.\n      cek = generateCEK(enc)\n    }\n\n    let adata\n    if (aad) {\n      adata = Buffer.concat([\n        Buffer.from(prot || ''),\n        Buffer.from('.'),\n        Buffer.from(aad)\n      ])\n    } else {\n      adata = Buffer.from(prot || '')\n    }\n\n    try {\n      iv = base64url.decodeToBuffer(iv)\n    } catch (err) {}\n    try {\n      tag = base64url.decodeToBuffer(tag)\n    } catch (err) {}\n\n    let cleartext = decrypt(enc, cek, base64url.decodeToBuffer(ciphertext), { iv, tag, aad: adata })\n\n    if (opts.zip) {\n      cleartext = inflateRawSync(cleartext)\n    }\n\n    if (complete) {\n      const result = { cleartext, key, cek }\n      if (aad) result.aad = aad\n      if (header) result.header = header\n      if (unprotected) result.unprotected = unprotected\n      if (prot) result.protected = base64url.JSON.decode(prot)\n      return result\n    }\n\n    return cleartext\n  }\n\n  validateHeaders(jwe.protected, jwe.unprotected, jwe.recipients.map(({ header }) => ({ header })), true, crit)\n\n  // general serialization format\n  const { recipients, ...root } = jwe\n  const errs = []\n  for (const recipient of recipients) {\n    try {\n      return jweDecrypt(true, 'flattened', { ...root, ...recipient }, key, {\n        crit,\n        complete,\n        contentEncryptionAlgorithms: contentEncryptionAlgorithms ? [...contentEncryptionAlgorithms] : undefined,\n        keyManagementAlgorithms: keyManagementAlgorithms ? [...keyManagementAlgorithms] : undefined\n      })\n    } catch (err) {\n      errs.push(err)\n      continue\n    }\n  }\n\n  const multi = new errors.JOSEMultiError(errs)\n  if ([...multi].some(e => e instanceof errors.JWEDecryptionFailed)) {\n    throw new errors.JWEDecryptionFailed()\n  } else if ([...multi].every(e => e instanceof errors.JWKSNoMatchingKey)) {\n    throw new errors.JWKSNoMatchingKey()\n  }\n  throw multi\n}\n\nmodule.exports = jweDecrypt.bind(undefined, false, undefined)\n"]},"metadata":{},"sourceType":"script"}