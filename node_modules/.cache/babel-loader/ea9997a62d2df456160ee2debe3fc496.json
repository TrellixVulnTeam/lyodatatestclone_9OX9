{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/suryanandsunil/Desktop/proto1-arizon/lyo-test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/suryanandsunil/Desktop/proto1-arizon/lyo-test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/suryanandsunil/Desktop/proto1-arizon/lyo-test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/suryanandsunil/Desktop/proto1-arizon/lyo-test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar assert = require(\"assert\");\n\nvar _1 = require(\".\");\n\nvar util_1 = require(\"./util\");\n\nvar reference_1 = require(\"./reference\");\n/*!\n * Datastore allowed numeric IDs where Firestore only allows strings. Numeric\n * IDs are exposed to Firestore as __idNUM__, so this is the lowest possible\n * negative numeric value expressed in that format.\n *\n * This constant is used to specify startAt/endAt values when querying for all\n * descendants in a single collection.\n */\n\n\nexports.REFERENCE_NAME_MIN_ID = '__id-9223372036854775808__';\n/*!\n * The query limit used for recursive deletes when fetching all descendants of\n * the specified reference to delete. This is done to prevent the query stream\n * from streaming documents faster than Firestore can delete.\n */\n// Visible for testing.\n\nexports.RECURSIVE_DELETE_MAX_PENDING_OPS = 5000;\n/*!\n * The number of pending BulkWriter operations at which RecursiveDelete\n * starts the next limit query to fetch descendants. By starting the query\n * while there are pending operations, Firestore can improve BulkWriter\n * throughput. This helps prevent BulkWriter from idling while Firestore\n * fetches the next query.\n */\n\nexports.RECURSIVE_DELETE_MIN_PENDING_OPS = 1000;\n/**\n * Class used to store state required for running a recursive delete operation.\n * Each recursive delete call should use a new instance of the class.\n * @private\n */\n\nvar RecursiveDelete = /*#__PURE__*/function () {\n  /**\n   *\n   * @param firestore The Firestore instance to use.\n   * @param writer The BulkWriter instance to use for delete operations.\n   * @param ref The document or collection reference to recursively delete.\n   * @param maxLimit The query limit to use when fetching descendants\n   * @param minLimit The number of pending BulkWriter operations at which\n   * RecursiveDelete starts the next limit query to fetch descendants.\n   */\n  function RecursiveDelete(firestore, writer, ref, maxLimit, minLimit) {\n    _classCallCheck(this, RecursiveDelete);\n\n    this.firestore = firestore;\n    this.writer = writer;\n    this.ref = ref;\n    this.maxLimit = maxLimit;\n    this.minLimit = minLimit;\n    /**\n     * The number of deletes that failed with a permanent error.\n     * @private\n     */\n\n    this.errorCount = 0;\n    /**\n     * Whether there are still documents to delete that still need to be fetched.\n     * @private\n     */\n\n    this.documentsPending = true;\n    /**\n     * Whether run() has been called.\n     * @private\n     */\n\n    this.started = false;\n    /**\n     * A deferred promise that resolves when the recursive delete operation\n     * is completed.\n     * @private\n     */\n\n    this.completionDeferred = new util_1.Deferred();\n    /**\n     * Whether a query stream is currently in progress. Only one stream can be\n     * run at a time.\n     * @private\n     */\n\n    this.streamInProgress = false;\n    /**\n     * The number of pending BulkWriter operations. Used to determine when the\n     * next query can be run.\n     * @private\n     */\n\n    this.pendingOpsCount = 0;\n    this.errorStack = '';\n    this.maxPendingOps = maxLimit;\n    this.minPendingOps = minLimit;\n  }\n  /**\n   * Recursively deletes the reference provided in the class constructor.\n   * Returns a promise that resolves when all descendants have been deleted, or\n   * if an error occurs.\n   */\n\n\n  _createClass(RecursiveDelete, [{\n    key: \"run\",\n    value: function run() {\n      assert(!this.started, 'RecursiveDelete.run() should only be called once.'); // Capture the error stack to preserve stack tracing across async calls.\n\n      this.errorStack = Error().stack;\n\n      this.writer._verifyNotClosed();\n\n      this.setupStream();\n      return this.completionDeferred.promise;\n    }\n    /**\n     * Creates a query stream and attaches event handlers to it.\n     * @private\n     */\n\n  }, {\n    key: \"setupStream\",\n    value: function setupStream() {\n      var _this = this;\n\n      var stream = this.getAllDescendants(this.ref instanceof _1.CollectionReference ? this.ref : this.ref);\n      this.streamInProgress = true;\n      var streamedDocsCount = 0;\n      stream.on('error', function (err) {\n        err.code = 14\n        /* UNAVAILABLE */\n        ;\n        err.stack = 'Failed to fetch children documents: ' + err.stack;\n        _this.lastError = err;\n\n        _this.onQueryEnd();\n      }).on('data', function (snap) {\n        streamedDocsCount++;\n        _this.lastDocumentSnap = snap;\n\n        _this.deleteRef(snap.ref);\n      }).on('end', function () {\n        _this.streamInProgress = false; // If there are fewer than the number of documents specified in the\n        // limit() field, we know that the query is complete.\n\n        if (streamedDocsCount < _this.minPendingOps) {\n          _this.onQueryEnd();\n        } else if (_this.pendingOpsCount === 0) {\n          _this.setupStream();\n        }\n      });\n    }\n    /**\n     * Retrieves all descendant documents nested under the provided reference.\n     * @param ref The reference to fetch all descendants for.\n     * @private\n     * @return {Stream<QueryDocumentSnapshot>} Stream of descendant documents.\n     */\n\n  }, {\n    key: \"getAllDescendants\",\n    value: function getAllDescendants(ref) {\n      // The parent is the closest ancestor document to the location we're\n      // deleting. If we are deleting a document, the parent is the path of that\n      // document. If we are deleting a collection, the parent is the path of the\n      // document containing that collection (or the database root, if it is a\n      // root collection).\n      var parentPath = ref._resourcePath;\n\n      if (ref instanceof _1.CollectionReference) {\n        parentPath = parentPath.popLast();\n      }\n\n      var collectionId = ref instanceof _1.CollectionReference ? ref.id : ref.parent.id;\n      var query = new _1.Query(this.firestore, reference_1.QueryOptions.forKindlessAllDescendants(parentPath, collectionId,\n      /* requireConsistency= */\n      false)); // Query for names only to fetch empty snapshots.\n\n      query = query.select(_1.FieldPath.documentId()).limit(this.maxPendingOps);\n\n      if (ref instanceof _1.CollectionReference) {\n        // To find all descendants of a collection reference, we need to use a\n        // composite filter that captures all documents that start with the\n        // collection prefix. The MIN_KEY constant represents the minimum key in\n        // this collection, and a null byte + the MIN_KEY represents the minimum\n        // key is the next possible collection.\n        var nullChar = String.fromCharCode(0);\n        var startAt = collectionId + '/' + exports.REFERENCE_NAME_MIN_ID;\n        var endAt = collectionId + nullChar + '/' + exports.REFERENCE_NAME_MIN_ID;\n        query = query.where(_1.FieldPath.documentId(), '>=', startAt).where(_1.FieldPath.documentId(), '<', endAt);\n      }\n\n      if (this.lastDocumentSnap) {\n        query = query.startAfter(this.lastDocumentSnap);\n      }\n\n      return query.stream();\n    }\n    /**\n     * Called when all descendants of the provided reference have been streamed\n     * or if a permanent error occurs during the stream. Deletes the developer\n     * provided reference and wraps any errors that occurred.\n     * @private\n     */\n\n  }, {\n    key: \"onQueryEnd\",\n    value: function onQueryEnd() {\n      var _this2 = this;\n\n      this.documentsPending = false;\n\n      if (this.ref instanceof _1.DocumentReference) {\n        this.writer.delete(this.ref).catch(function (err) {\n          return _this2.incrementErrorCount(err);\n        });\n      }\n\n      this.writer.flush().then( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var _a, error;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (_this2.lastError === undefined) {\n                  _this2.completionDeferred.resolve();\n                } else {\n                  error = new (require('google-gax').GoogleError)(\"\".concat(_this2.errorCount, \" \") + \"\".concat(_this2.errorCount !== 1 ? 'deletes' : 'delete', \" \") + 'failed. The last delete failed with: ');\n\n                  if (_this2.lastError.code !== undefined) {\n                    error.code = _this2.lastError.code;\n                  }\n\n                  error = util_1.wrapError(error, _this2.errorStack); // Wrap the BulkWriter error last to provide the full stack trace.\n\n                  _this2.completionDeferred.reject(_this2.lastError.stack ? util_1.wrapError(error, (_a = _this2.lastError.stack) !== null && _a !== void 0 ? _a : '') : error);\n                }\n\n              case 1:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      })));\n    }\n    /**\n     * Deletes the provided reference and starts the next stream if conditions\n     * are met.\n     * @private\n     */\n\n  }, {\n    key: \"deleteRef\",\n    value: function deleteRef(docRef) {\n      var _this3 = this;\n\n      this.pendingOpsCount++;\n      this.writer.delete(docRef).catch(function (err) {\n        _this3.incrementErrorCount(err);\n      }).then(function () {\n        _this3.pendingOpsCount--; // We wait until the previous stream has ended in order to sure the\n        // startAfter document is correct. Starting the next stream while\n        // there are pending operations allows Firestore to maximize\n        // BulkWriter throughput.\n\n        if (_this3.documentsPending && !_this3.streamInProgress && _this3.pendingOpsCount < _this3.minPendingOps) {\n          _this3.setupStream();\n        }\n      });\n    }\n  }, {\n    key: \"incrementErrorCount\",\n    value: function incrementErrorCount(err) {\n      this.errorCount++;\n      this.lastError = err;\n    }\n  }]);\n\n  return RecursiveDelete;\n}();\n\nexports.RecursiveDelete = RecursiveDelete;","map":{"version":3,"sources":["/Users/suryanandsunil/Desktop/proto1-arizon/lyo-test/node_modules/@google-cloud/firestore/build/src/recursive-delete.js"],"names":["Object","defineProperty","exports","value","assert","require","_1","util_1","reference_1","REFERENCE_NAME_MIN_ID","RECURSIVE_DELETE_MAX_PENDING_OPS","RECURSIVE_DELETE_MIN_PENDING_OPS","RecursiveDelete","firestore","writer","ref","maxLimit","minLimit","errorCount","documentsPending","started","completionDeferred","Deferred","streamInProgress","pendingOpsCount","errorStack","maxPendingOps","minPendingOps","Error","stack","_verifyNotClosed","setupStream","promise","stream","getAllDescendants","CollectionReference","streamedDocsCount","on","err","code","lastError","onQueryEnd","snap","lastDocumentSnap","deleteRef","parentPath","_resourcePath","popLast","collectionId","id","parent","query","Query","QueryOptions","forKindlessAllDescendants","select","FieldPath","documentId","limit","nullChar","String","fromCharCode","startAt","endAt","where","startAfter","DocumentReference","delete","catch","incrementErrorCount","flush","then","undefined","resolve","error","GoogleError","wrapError","reject","_a","docRef"],"mappings":"AAAA;;;;;;;;;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AACA,IAAMC,MAAM,GAAGC,OAAO,CAAC,QAAD,CAAtB;;AACA,IAAMC,EAAE,GAAGD,OAAO,CAAC,GAAD,CAAlB;;AACA,IAAME,MAAM,GAAGF,OAAO,CAAC,QAAD,CAAtB;;AACA,IAAMG,WAAW,GAAGH,OAAO,CAAC,aAAD,CAA3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAH,OAAO,CAACO,qBAAR,GAAgC,4BAAhC;AACA;AACA;AACA;AACA;AACA;AACA;;AACAP,OAAO,CAACQ,gCAAR,GAA2C,IAA3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACAR,OAAO,CAACS,gCAAR,GAA2C,IAA3C;AACA;AACA;AACA;AACA;AACA;;IACMC,e;AACF;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACI,2BAAYC,SAAZ,EAAuBC,MAAvB,EAA+BC,GAA/B,EAAoCC,QAApC,EAA8CC,QAA9C,EAAwD;AAAA;;AACpD,SAAKJ,SAAL,GAAiBA,SAAjB;AACA,SAAKC,MAAL,GAAcA,MAAd;AACA,SAAKC,GAAL,GAAWA,GAAX;AACA,SAAKC,QAAL,GAAgBA,QAAhB;AACA,SAAKC,QAAL,GAAgBA,QAAhB;AACA;AACR;AACA;AACA;;AACQ,SAAKC,UAAL,GAAkB,CAAlB;AACA;AACR;AACA;AACA;;AACQ,SAAKC,gBAAL,GAAwB,IAAxB;AACA;AACR;AACA;AACA;;AACQ,SAAKC,OAAL,GAAe,KAAf;AACA;AACR;AACA;AACA;AACA;;AACQ,SAAKC,kBAAL,GAA0B,IAAId,MAAM,CAACe,QAAX,EAA1B;AACA;AACR;AACA;AACA;AACA;;AACQ,SAAKC,gBAAL,GAAwB,KAAxB;AACA;AACR;AACA;AACA;AACA;;AACQ,SAAKC,eAAL,GAAuB,CAAvB;AACA,SAAKC,UAAL,GAAkB,EAAlB;AACA,SAAKC,aAAL,GAAqBV,QAArB;AACA,SAAKW,aAAL,GAAqBV,QAArB;AACH;AACD;AACJ;AACA;AACA;AACA;;;;;WACI,eAAM;AACFb,MAAAA,MAAM,CAAC,CAAC,KAAKgB,OAAP,EAAgB,mDAAhB,CAAN,CADE,CAEF;;AACA,WAAKK,UAAL,GAAkBG,KAAK,GAAGC,KAA1B;;AACA,WAAKf,MAAL,CAAYgB,gBAAZ;;AACA,WAAKC,WAAL;AACA,aAAO,KAAKV,kBAAL,CAAwBW,OAA/B;AACH;AACD;AACJ;AACA;AACA;;;;WACI,uBAAc;AAAA;;AACV,UAAMC,MAAM,GAAG,KAAKC,iBAAL,CAAuB,KAAKnB,GAAL,YAAoBT,EAAE,CAAC6B,mBAAvB,GAChC,KAAKpB,GAD2B,GAEhC,KAAKA,GAFI,CAAf;AAGA,WAAKQ,gBAAL,GAAwB,IAAxB;AACA,UAAIa,iBAAiB,GAAG,CAAxB;AACAH,MAAAA,MAAM,CACDI,EADL,CACQ,OADR,EACiB,UAAAC,GAAG,EAAI;AACpBA,QAAAA,GAAG,CAACC,IAAJ,GAAW;AAAG;AAAd;AACAD,QAAAA,GAAG,CAACT,KAAJ,GAAY,yCAAyCS,GAAG,CAACT,KAAzD;AACA,QAAA,KAAI,CAACW,SAAL,GAAiBF,GAAjB;;AACA,QAAA,KAAI,CAACG,UAAL;AACH,OAND,EAOKJ,EAPL,CAOQ,MAPR,EAOgB,UAACK,IAAD,EAAU;AACtBN,QAAAA,iBAAiB;AACjB,QAAA,KAAI,CAACO,gBAAL,GAAwBD,IAAxB;;AACA,QAAA,KAAI,CAACE,SAAL,CAAeF,IAAI,CAAC3B,GAApB;AACH,OAXD,EAYKsB,EAZL,CAYQ,KAZR,EAYe,YAAM;AACjB,QAAA,KAAI,CAACd,gBAAL,GAAwB,KAAxB,CADiB,CAEjB;AACA;;AACA,YAAIa,iBAAiB,GAAG,KAAI,CAACT,aAA7B,EAA4C;AACxC,UAAA,KAAI,CAACc,UAAL;AACH,SAFD,MAGK,IAAI,KAAI,CAACjB,eAAL,KAAyB,CAA7B,EAAgC;AACjC,UAAA,KAAI,CAACO,WAAL;AACH;AACJ,OAtBD;AAuBH;AACD;AACJ;AACA;AACA;AACA;AACA;;;;WACI,2BAAkBhB,GAAlB,EAAuB;AACnB;AACA;AACA;AACA;AACA;AACA,UAAI8B,UAAU,GAAG9B,GAAG,CAAC+B,aAArB;;AACA,UAAI/B,GAAG,YAAYT,EAAE,CAAC6B,mBAAtB,EAA2C;AACvCU,QAAAA,UAAU,GAAGA,UAAU,CAACE,OAAX,EAAb;AACH;;AACD,UAAMC,YAAY,GAAGjC,GAAG,YAAYT,EAAE,CAAC6B,mBAAlB,GACfpB,GAAG,CAACkC,EADW,GAEflC,GAAG,CAACmC,MAAJ,CAAWD,EAFjB;AAGA,UAAIE,KAAK,GAAG,IAAI7C,EAAE,CAAC8C,KAAP,CAAa,KAAKvC,SAAlB,EAA6BL,WAAW,CAAC6C,YAAZ,CAAyBC,yBAAzB,CAAmDT,UAAnD,EAA+DG,YAA/D;AACzC;AAA0B,WADe,CAA7B,CAAZ,CAbmB,CAenB;;AACAG,MAAAA,KAAK,GAAGA,KAAK,CAACI,MAAN,CAAajD,EAAE,CAACkD,SAAH,CAAaC,UAAb,EAAb,EAAwCC,KAAxC,CAA8C,KAAKhC,aAAnD,CAAR;;AACA,UAAIX,GAAG,YAAYT,EAAE,CAAC6B,mBAAtB,EAA2C;AACvC;AACA;AACA;AACA;AACA;AACA,YAAMwB,QAAQ,GAAGC,MAAM,CAACC,YAAP,CAAoB,CAApB,CAAjB;AACA,YAAMC,OAAO,GAAGd,YAAY,GAAG,GAAf,GAAqB9C,OAAO,CAACO,qBAA7C;AACA,YAAMsD,KAAK,GAAGf,YAAY,GAAGW,QAAf,GAA0B,GAA1B,GAAgCzD,OAAO,CAACO,qBAAtD;AACA0C,QAAAA,KAAK,GAAGA,KAAK,CACRa,KADG,CACG1D,EAAE,CAACkD,SAAH,CAAaC,UAAb,EADH,EAC8B,IAD9B,EACoCK,OADpC,EAEHE,KAFG,CAEG1D,EAAE,CAACkD,SAAH,CAAaC,UAAb,EAFH,EAE8B,GAF9B,EAEmCM,KAFnC,CAAR;AAGH;;AACD,UAAI,KAAKpB,gBAAT,EAA2B;AACvBQ,QAAAA,KAAK,GAAGA,KAAK,CAACc,UAAN,CAAiB,KAAKtB,gBAAtB,CAAR;AACH;;AACD,aAAOQ,KAAK,CAAClB,MAAN,EAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;;;;WACI,sBAAa;AAAA;;AACT,WAAKd,gBAAL,GAAwB,KAAxB;;AACA,UAAI,KAAKJ,GAAL,YAAoBT,EAAE,CAAC4D,iBAA3B,EAA8C;AAC1C,aAAKpD,MAAL,CAAYqD,MAAZ,CAAmB,KAAKpD,GAAxB,EAA6BqD,KAA7B,CAAmC,UAAA9B,GAAG;AAAA,iBAAI,MAAI,CAAC+B,mBAAL,CAAyB/B,GAAzB,CAAJ;AAAA,SAAtC;AACH;;AACD,WAAKxB,MAAL,CAAYwD,KAAZ,GAAoBC,IAApB,wEAAyB;AAAA;;AAAA;AAAA;AAAA;AAAA;AAErB,oBAAI,MAAI,CAAC/B,SAAL,KAAmBgC,SAAvB,EAAkC;AAC9B,kBAAA,MAAI,CAACnD,kBAAL,CAAwBoD,OAAxB;AACH,iBAFD,MAGK;AACGC,kBAAAA,KADH,GACW,KAAKrE,OAAO,CAAC,YAAD,CAAP,CAAsBsE,WAA3B,EAAwC,UAAG,MAAI,CAACzD,UAAR,mBAC7C,MAAI,CAACA,UAAL,KAAoB,CAApB,GAAwB,SAAxB,GAAoC,QADS,SAEhD,uCAFQ,CADX;;AAID,sBAAI,MAAI,CAACsB,SAAL,CAAeD,IAAf,KAAwBiC,SAA5B,EAAuC;AACnCE,oBAAAA,KAAK,CAACnC,IAAN,GAAa,MAAI,CAACC,SAAL,CAAeD,IAA5B;AACH;;AACDmC,kBAAAA,KAAK,GAAGnE,MAAM,CAACqE,SAAP,CAAiBF,KAAjB,EAAwB,MAAI,CAACjD,UAA7B,CAAR,CAPC,CAQD;;AACA,kBAAA,MAAI,CAACJ,kBAAL,CAAwBwD,MAAxB,CAA+B,MAAI,CAACrC,SAAL,CAAeX,KAAf,GACzBtB,MAAM,CAACqE,SAAP,CAAiBF,KAAjB,EAAwB,CAACI,EAAE,GAAG,MAAI,CAACtC,SAAL,CAAeX,KAArB,MAAgC,IAAhC,IAAwCiD,EAAE,KAAK,KAAK,CAApD,GAAwDA,EAAxD,GAA6D,EAArF,CADyB,GAEzBJ,KAFN;AAGH;;AAjBoB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,OAAzB;AAmBH;AACD;AACJ;AACA;AACA;AACA;;;;WACI,mBAAUK,MAAV,EAAkB;AAAA;;AACd,WAAKvD,eAAL;AACA,WAAKV,MAAL,CACKqD,MADL,CACYY,MADZ,EAEKX,KAFL,CAEW,UAAA9B,GAAG,EAAI;AACd,QAAA,MAAI,CAAC+B,mBAAL,CAAyB/B,GAAzB;AACH,OAJD,EAKKiC,IALL,CAKU,YAAM;AACZ,QAAA,MAAI,CAAC/C,eAAL,GADY,CAEZ;AACA;AACA;AACA;;AACA,YAAI,MAAI,CAACL,gBAAL,IACA,CAAC,MAAI,CAACI,gBADN,IAEA,MAAI,CAACC,eAAL,GAAuB,MAAI,CAACG,aAFhC,EAE+C;AAC3C,UAAA,MAAI,CAACI,WAAL;AACH;AACJ,OAhBD;AAiBH;;;WACD,6BAAoBO,GAApB,EAAyB;AACrB,WAAKpB,UAAL;AACA,WAAKsB,SAAL,GAAiBF,GAAjB;AACH;;;;;;AAELpC,OAAO,CAACU,eAAR,GAA0BA,eAA1B","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst assert = require(\"assert\");\nconst _1 = require(\".\");\nconst util_1 = require(\"./util\");\nconst reference_1 = require(\"./reference\");\n/*!\n * Datastore allowed numeric IDs where Firestore only allows strings. Numeric\n * IDs are exposed to Firestore as __idNUM__, so this is the lowest possible\n * negative numeric value expressed in that format.\n *\n * This constant is used to specify startAt/endAt values when querying for all\n * descendants in a single collection.\n */\nexports.REFERENCE_NAME_MIN_ID = '__id-9223372036854775808__';\n/*!\n * The query limit used for recursive deletes when fetching all descendants of\n * the specified reference to delete. This is done to prevent the query stream\n * from streaming documents faster than Firestore can delete.\n */\n// Visible for testing.\nexports.RECURSIVE_DELETE_MAX_PENDING_OPS = 5000;\n/*!\n * The number of pending BulkWriter operations at which RecursiveDelete\n * starts the next limit query to fetch descendants. By starting the query\n * while there are pending operations, Firestore can improve BulkWriter\n * throughput. This helps prevent BulkWriter from idling while Firestore\n * fetches the next query.\n */\nexports.RECURSIVE_DELETE_MIN_PENDING_OPS = 1000;\n/**\n * Class used to store state required for running a recursive delete operation.\n * Each recursive delete call should use a new instance of the class.\n * @private\n */\nclass RecursiveDelete {\n    /**\n     *\n     * @param firestore The Firestore instance to use.\n     * @param writer The BulkWriter instance to use for delete operations.\n     * @param ref The document or collection reference to recursively delete.\n     * @param maxLimit The query limit to use when fetching descendants\n     * @param minLimit The number of pending BulkWriter operations at which\n     * RecursiveDelete starts the next limit query to fetch descendants.\n     */\n    constructor(firestore, writer, ref, maxLimit, minLimit) {\n        this.firestore = firestore;\n        this.writer = writer;\n        this.ref = ref;\n        this.maxLimit = maxLimit;\n        this.minLimit = minLimit;\n        /**\n         * The number of deletes that failed with a permanent error.\n         * @private\n         */\n        this.errorCount = 0;\n        /**\n         * Whether there are still documents to delete that still need to be fetched.\n         * @private\n         */\n        this.documentsPending = true;\n        /**\n         * Whether run() has been called.\n         * @private\n         */\n        this.started = false;\n        /**\n         * A deferred promise that resolves when the recursive delete operation\n         * is completed.\n         * @private\n         */\n        this.completionDeferred = new util_1.Deferred();\n        /**\n         * Whether a query stream is currently in progress. Only one stream can be\n         * run at a time.\n         * @private\n         */\n        this.streamInProgress = false;\n        /**\n         * The number of pending BulkWriter operations. Used to determine when the\n         * next query can be run.\n         * @private\n         */\n        this.pendingOpsCount = 0;\n        this.errorStack = '';\n        this.maxPendingOps = maxLimit;\n        this.minPendingOps = minLimit;\n    }\n    /**\n     * Recursively deletes the reference provided in the class constructor.\n     * Returns a promise that resolves when all descendants have been deleted, or\n     * if an error occurs.\n     */\n    run() {\n        assert(!this.started, 'RecursiveDelete.run() should only be called once.');\n        // Capture the error stack to preserve stack tracing across async calls.\n        this.errorStack = Error().stack;\n        this.writer._verifyNotClosed();\n        this.setupStream();\n        return this.completionDeferred.promise;\n    }\n    /**\n     * Creates a query stream and attaches event handlers to it.\n     * @private\n     */\n    setupStream() {\n        const stream = this.getAllDescendants(this.ref instanceof _1.CollectionReference\n            ? this.ref\n            : this.ref);\n        this.streamInProgress = true;\n        let streamedDocsCount = 0;\n        stream\n            .on('error', err => {\n            err.code = 14 /* UNAVAILABLE */;\n            err.stack = 'Failed to fetch children documents: ' + err.stack;\n            this.lastError = err;\n            this.onQueryEnd();\n        })\n            .on('data', (snap) => {\n            streamedDocsCount++;\n            this.lastDocumentSnap = snap;\n            this.deleteRef(snap.ref);\n        })\n            .on('end', () => {\n            this.streamInProgress = false;\n            // If there are fewer than the number of documents specified in the\n            // limit() field, we know that the query is complete.\n            if (streamedDocsCount < this.minPendingOps) {\n                this.onQueryEnd();\n            }\n            else if (this.pendingOpsCount === 0) {\n                this.setupStream();\n            }\n        });\n    }\n    /**\n     * Retrieves all descendant documents nested under the provided reference.\n     * @param ref The reference to fetch all descendants for.\n     * @private\n     * @return {Stream<QueryDocumentSnapshot>} Stream of descendant documents.\n     */\n    getAllDescendants(ref) {\n        // The parent is the closest ancestor document to the location we're\n        // deleting. If we are deleting a document, the parent is the path of that\n        // document. If we are deleting a collection, the parent is the path of the\n        // document containing that collection (or the database root, if it is a\n        // root collection).\n        let parentPath = ref._resourcePath;\n        if (ref instanceof _1.CollectionReference) {\n            parentPath = parentPath.popLast();\n        }\n        const collectionId = ref instanceof _1.CollectionReference\n            ? ref.id\n            : ref.parent.id;\n        let query = new _1.Query(this.firestore, reference_1.QueryOptions.forKindlessAllDescendants(parentPath, collectionId, \n        /* requireConsistency= */ false));\n        // Query for names only to fetch empty snapshots.\n        query = query.select(_1.FieldPath.documentId()).limit(this.maxPendingOps);\n        if (ref instanceof _1.CollectionReference) {\n            // To find all descendants of a collection reference, we need to use a\n            // composite filter that captures all documents that start with the\n            // collection prefix. The MIN_KEY constant represents the minimum key in\n            // this collection, and a null byte + the MIN_KEY represents the minimum\n            // key is the next possible collection.\n            const nullChar = String.fromCharCode(0);\n            const startAt = collectionId + '/' + exports.REFERENCE_NAME_MIN_ID;\n            const endAt = collectionId + nullChar + '/' + exports.REFERENCE_NAME_MIN_ID;\n            query = query\n                .where(_1.FieldPath.documentId(), '>=', startAt)\n                .where(_1.FieldPath.documentId(), '<', endAt);\n        }\n        if (this.lastDocumentSnap) {\n            query = query.startAfter(this.lastDocumentSnap);\n        }\n        return query.stream();\n    }\n    /**\n     * Called when all descendants of the provided reference have been streamed\n     * or if a permanent error occurs during the stream. Deletes the developer\n     * provided reference and wraps any errors that occurred.\n     * @private\n     */\n    onQueryEnd() {\n        this.documentsPending = false;\n        if (this.ref instanceof _1.DocumentReference) {\n            this.writer.delete(this.ref).catch(err => this.incrementErrorCount(err));\n        }\n        this.writer.flush().then(async () => {\n            var _a;\n            if (this.lastError === undefined) {\n                this.completionDeferred.resolve();\n            }\n            else {\n                let error = new (require('google-gax').GoogleError)(`${this.errorCount} ` +\n                    `${this.errorCount !== 1 ? 'deletes' : 'delete'} ` +\n                    'failed. The last delete failed with: ');\n                if (this.lastError.code !== undefined) {\n                    error.code = this.lastError.code;\n                }\n                error = util_1.wrapError(error, this.errorStack);\n                // Wrap the BulkWriter error last to provide the full stack trace.\n                this.completionDeferred.reject(this.lastError.stack\n                    ? util_1.wrapError(error, (_a = this.lastError.stack) !== null && _a !== void 0 ? _a : '')\n                    : error);\n            }\n        });\n    }\n    /**\n     * Deletes the provided reference and starts the next stream if conditions\n     * are met.\n     * @private\n     */\n    deleteRef(docRef) {\n        this.pendingOpsCount++;\n        this.writer\n            .delete(docRef)\n            .catch(err => {\n            this.incrementErrorCount(err);\n        })\n            .then(() => {\n            this.pendingOpsCount--;\n            // We wait until the previous stream has ended in order to sure the\n            // startAfter document is correct. Starting the next stream while\n            // there are pending operations allows Firestore to maximize\n            // BulkWriter throughput.\n            if (this.documentsPending &&\n                !this.streamInProgress &&\n                this.pendingOpsCount < this.minPendingOps) {\n                this.setupStream();\n            }\n        });\n    }\n    incrementErrorCount(err) {\n        this.errorCount++;\n        this.lastError = err;\n    }\n}\nexports.RecursiveDelete = RecursiveDelete;\n//# sourceMappingURL=recursive-delete.js.map"]},"metadata":{},"sourceType":"script"}