{"ast":null,"code":"var _require = require('crypto'),\n    createHash = _require.createHash;\n\nvar ecdhComputeSecret = require('./compute_secret');\n\nvar concat = function concat(key, length, value) {\n  var iterations = Math.ceil(length / 32);\n  var res;\n\n  for (var iter = 1; iter <= iterations; iter++) {\n    var buf = Buffer.allocUnsafe(4 + key.length + value.length);\n    buf.writeUInt32BE(iter, 0);\n    key.copy(buf, 4);\n    value.copy(buf, 4 + key.length);\n\n    if (!res) {\n      res = createHash('sha256').update(buf).digest();\n    } else {\n      res = Buffer.concat([res, createHash('sha256').update(buf).digest()]);\n    }\n  }\n\n  return res.slice(0, length);\n};\n\nvar uint32be = function uint32be(value) {\n  var buf = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Buffer.allocUnsafe(4);\n  buf.writeUInt32BE(value);\n  return buf;\n};\n\nvar lengthAndInput = function lengthAndInput(input) {\n  return Buffer.concat([uint32be(input.length), input]);\n};\n\nmodule.exports = function (alg, keyLen, privKey, pubKey) {\n  var _ref = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {},\n      _ref$apu = _ref.apu,\n      apu = _ref$apu === void 0 ? Buffer.alloc(0) : _ref$apu,\n      _ref$apv = _ref.apv,\n      apv = _ref$apv === void 0 ? Buffer.alloc(0) : _ref$apv;\n\n  var computeSecret = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : ecdhComputeSecret;\n  var value = Buffer.concat([lengthAndInput(Buffer.from(alg)), lengthAndInput(apu), lengthAndInput(apv), uint32be(keyLen)]);\n  var sharedSecret = computeSecret(privKey, pubKey);\n  return concat(sharedSecret, keyLen / 8, value);\n};","map":{"version":3,"sources":["/Users/suryanandsunil/Desktop/proto1-arizon/lyo-test/node_modules/jose/lib/jwa/ecdh/derive.js"],"names":["require","createHash","ecdhComputeSecret","concat","key","length","value","iterations","Math","ceil","res","iter","buf","Buffer","allocUnsafe","writeUInt32BE","copy","update","digest","slice","uint32be","lengthAndInput","input","module","exports","alg","keyLen","privKey","pubKey","apu","alloc","apv","computeSecret","from","sharedSecret"],"mappings":"eAAuBA,OAAO,CAAC,QAAD,C;IAAtBC,U,YAAAA,U;;AACR,IAAMC,iBAAiB,GAAGF,OAAO,CAAC,kBAAD,CAAjC;;AAEA,IAAMG,MAAM,GAAG,SAATA,MAAS,CAACC,GAAD,EAAMC,MAAN,EAAcC,KAAd,EAAwB;AACrC,MAAMC,UAAU,GAAGC,IAAI,CAACC,IAAL,CAAUJ,MAAM,GAAG,EAAnB,CAAnB;AACA,MAAIK,GAAJ;;AAEA,OAAK,IAAIC,IAAI,GAAG,CAAhB,EAAmBA,IAAI,IAAIJ,UAA3B,EAAuCI,IAAI,EAA3C,EAA+C;AAC7C,QAAMC,GAAG,GAAGC,MAAM,CAACC,WAAP,CAAmB,IAAIV,GAAG,CAACC,MAAR,GAAiBC,KAAK,CAACD,MAA1C,CAAZ;AACAO,IAAAA,GAAG,CAACG,aAAJ,CAAkBJ,IAAlB,EAAwB,CAAxB;AACAP,IAAAA,GAAG,CAACY,IAAJ,CAASJ,GAAT,EAAc,CAAd;AACAN,IAAAA,KAAK,CAACU,IAAN,CAAWJ,GAAX,EAAgB,IAAIR,GAAG,CAACC,MAAxB;;AACA,QAAI,CAACK,GAAL,EAAU;AACRA,MAAAA,GAAG,GAAGT,UAAU,CAAC,QAAD,CAAV,CAAqBgB,MAArB,CAA4BL,GAA5B,EAAiCM,MAAjC,EAAN;AACD,KAFD,MAEO;AACLR,MAAAA,GAAG,GAAGG,MAAM,CAACV,MAAP,CAAc,CAACO,GAAD,EAAMT,UAAU,CAAC,QAAD,CAAV,CAAqBgB,MAArB,CAA4BL,GAA5B,EAAiCM,MAAjC,EAAN,CAAd,CAAN;AACD;AACF;;AAED,SAAOR,GAAG,CAACS,KAAJ,CAAU,CAAV,EAAad,MAAb,CAAP;AACD,CAjBD;;AAmBA,IAAMe,QAAQ,GAAG,SAAXA,QAAW,CAACd,KAAD,EAAwC;AAAA,MAAhCM,GAAgC,uEAA1BC,MAAM,CAACC,WAAP,CAAmB,CAAnB,CAA0B;AACvDF,EAAAA,GAAG,CAACG,aAAJ,CAAkBT,KAAlB;AACA,SAAOM,GAAP;AACD,CAHD;;AAKA,IAAMS,cAAc,GAAG,SAAjBA,cAAiB,CAAAC,KAAK;AAAA,SAAIT,MAAM,CAACV,MAAP,CAAc,CAACiB,QAAQ,CAACE,KAAK,CAACjB,MAAP,CAAT,EAAyBiB,KAAzB,CAAd,CAAJ;AAAA,CAA5B;;AAEAC,MAAM,CAACC,OAAP,GAAiB,UAACC,GAAD,EAAMC,MAAN,EAAcC,OAAd,EAAuBC,MAAvB,EAA4H;AAAA,iFAA1C,EAA0C;AAAA,sBAA3FC,GAA2F;AAAA,MAA3FA,GAA2F,yBAArFhB,MAAM,CAACiB,KAAP,CAAa,CAAb,CAAqF;AAAA,sBAApEC,GAAoE;AAAA,MAApEA,GAAoE,yBAA9DlB,MAAM,CAACiB,KAAP,CAAa,CAAb,CAA8D;;AAAA,MAAtCE,aAAsC,uEAAtB9B,iBAAsB;AAC3I,MAAMI,KAAK,GAAGO,MAAM,CAACV,MAAP,CAAc,CAC1BkB,cAAc,CAACR,MAAM,CAACoB,IAAP,CAAYR,GAAZ,CAAD,CADY,EAE1BJ,cAAc,CAACQ,GAAD,CAFY,EAG1BR,cAAc,CAACU,GAAD,CAHY,EAI1BX,QAAQ,CAACM,MAAD,CAJkB,CAAd,CAAd;AAOA,MAAMQ,YAAY,GAAGF,aAAa,CAACL,OAAD,EAAUC,MAAV,CAAlC;AACA,SAAOzB,MAAM,CAAC+B,YAAD,EAAeR,MAAM,GAAG,CAAxB,EAA2BpB,KAA3B,CAAb;AACD,CAVD","sourcesContent":["const { createHash } = require('crypto')\nconst ecdhComputeSecret = require('./compute_secret')\n\nconst concat = (key, length, value) => {\n  const iterations = Math.ceil(length / 32)\n  let res\n\n  for (let iter = 1; iter <= iterations; iter++) {\n    const buf = Buffer.allocUnsafe(4 + key.length + value.length)\n    buf.writeUInt32BE(iter, 0)\n    key.copy(buf, 4)\n    value.copy(buf, 4 + key.length)\n    if (!res) {\n      res = createHash('sha256').update(buf).digest()\n    } else {\n      res = Buffer.concat([res, createHash('sha256').update(buf).digest()])\n    }\n  }\n\n  return res.slice(0, length)\n}\n\nconst uint32be = (value, buf = Buffer.allocUnsafe(4)) => {\n  buf.writeUInt32BE(value)\n  return buf\n}\n\nconst lengthAndInput = input => Buffer.concat([uint32be(input.length), input])\n\nmodule.exports = (alg, keyLen, privKey, pubKey, { apu = Buffer.alloc(0), apv = Buffer.alloc(0) } = {}, computeSecret = ecdhComputeSecret) => {\n  const value = Buffer.concat([\n    lengthAndInput(Buffer.from(alg)),\n    lengthAndInput(apu),\n    lengthAndInput(apv),\n    uint32be(keyLen)\n  ])\n\n  const sharedSecret = computeSecret(privKey, pubKey)\n  return concat(sharedSecret, keyLen / 8, value)\n}\n"]},"metadata":{},"sourceType":"script"}