{"ast":null,"code":"var _toConsumableArray = require(\"/Users/suryanandsunil/Desktop/proto1-arizon/lyo-test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _createForOfIteratorHelper = require(\"/Users/suryanandsunil/Desktop/proto1-arizon/lyo-test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _slicedToArray = require(\"/Users/suryanandsunil/Desktop/proto1-arizon/lyo-test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _objectSpread = require(\"/Users/suryanandsunil/Desktop/proto1-arizon/lyo-test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _objectWithoutProperties = require(\"/Users/suryanandsunil/Desktop/proto1-arizon/lyo-test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectWithoutProperties\");\n\nvar _require = require('os'),\n    EOL = _require.EOL;\n\nvar base64url = require('../help/base64url');\n\nvar isDisjoint = require('../help/is_disjoint');\n\nvar isObject = require('../help/is_object');\n\nvar validateCrit = require('../help/validate_crit');\n\nvar getKey = require('../help/get_key');\n\nvar _require2 = require('../jwks'),\n    KeyStore = _require2.KeyStore;\n\nvar errors = require('../errors');\n\nvar _require3 = require('../jwa'),\n    check = _require3.check,\n    verify = _require3.verify;\n\nvar JWK = require('../jwk');\n\nvar _require4 = require('./serializers'),\n    resolveSerialization = _require4.detect;\n\nvalidateCrit = validateCrit.bind(undefined, errors.JWSInvalid);\nvar SINGLE_RECIPIENT = new Set(['compact', 'flattened', 'preparsed']);\n/*\n * @public\n */\n\nvar jwsVerify = function jwsVerify(skipDisjointCheck, serialization, jws, key) {\n  var _ref = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {},\n      _ref$crit = _ref.crit,\n      crit = _ref$crit === void 0 ? [] : _ref$crit,\n      _ref$complete = _ref.complete,\n      complete = _ref$complete === void 0 ? false : _ref$complete,\n      algorithms = _ref.algorithms;\n\n  key = getKey(key, true);\n\n  if (algorithms !== undefined && (!Array.isArray(algorithms) || algorithms.some(function (s) {\n    return typeof s !== 'string' || !s;\n  }))) {\n    throw new TypeError('\"algorithms\" option must be an array of non-empty strings');\n  } else if (algorithms) {\n    algorithms = new Set(algorithms);\n  }\n\n  if (!Array.isArray(crit) || crit.some(function (s) {\n    return typeof s !== 'string' || !s;\n  })) {\n    throw new TypeError('\"crit\" option must be an array of non-empty strings');\n  }\n\n  if (!serialization) {\n    serialization = resolveSerialization(jws);\n  }\n\n  var prot; // protected header\n\n  var header; // unprotected header\n\n  var payload;\n  var signature;\n  var alg; // treat general format with one recipient as flattened\n  // skips iteration and avoids multi errors in this case\n\n  if (serialization === 'general' && jws.signatures.length === 1) {\n    serialization = 'flattened';\n\n    var _jws = jws,\n        _signatures = _jws.signatures,\n        _root = _objectWithoutProperties(_jws, [\"signatures\"]);\n\n    jws = _objectSpread(_objectSpread({}, _root), _signatures[0]);\n  }\n\n  var decoded;\n\n  if (SINGLE_RECIPIENT.has(serialization)) {\n    var parsedProt = {};\n\n    switch (serialization) {\n      case 'compact':\n        // compact serialization format\n        var _jws$split = jws.split('.');\n\n        var _jws$split2 = _slicedToArray(_jws$split, 3);\n\n        prot = _jws$split2[0];\n        payload = _jws$split2[1];\n        signature = _jws$split2[2];\n        break;\n\n      case 'flattened':\n        // flattened serialization format\n        var _jws2 = jws;\n        prot = _jws2.protected;\n        payload = _jws2.payload;\n        signature = _jws2.signature;\n        header = _jws2.header;\n        break;\n\n      case 'preparsed':\n        {\n          // from the JWT module\n          var _jws3 = jws;\n          decoded = _jws3.decoded;\n\n          var _jws$token$split = jws.token.split('.');\n\n          var _jws$token$split2 = _slicedToArray(_jws$token$split, 3);\n\n          prot = _jws$token$split2[0];\n          payload = _jws$token$split2[1];\n          signature = _jws$token$split2[2];\n          break;\n        }\n    }\n\n    if (!header) {\n      skipDisjointCheck = true;\n    }\n\n    if (decoded) {\n      parsedProt = decoded.header;\n    } else if (prot) {\n      try {\n        parsedProt = base64url.JSON.decode(prot);\n      } catch (err) {\n        throw new errors.JWSInvalid('could not parse JWS protected header');\n      }\n    } else {\n      skipDisjointCheck = skipDisjointCheck || true;\n    }\n\n    if (!skipDisjointCheck && !isDisjoint(parsedProt, header)) {\n      throw new errors.JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint');\n    }\n\n    var combinedHeader = _objectSpread(_objectSpread({}, parsedProt), header);\n\n    validateCrit(parsedProt, header, crit);\n    alg = parsedProt.alg || header && header.alg;\n\n    if (!alg) {\n      throw new errors.JWSInvalid('missing JWS signature algorithm');\n    } else if (algorithms && !algorithms.has(alg)) {\n      throw new errors.JOSEAlgNotWhitelisted('alg not whitelisted');\n    }\n\n    if (key instanceof KeyStore) {\n      var keystore = key;\n      var keys = keystore.all({\n        kid: combinedHeader.kid,\n        alg: combinedHeader.alg,\n        key_ops: ['verify']\n      });\n\n      switch (keys.length) {\n        case 0:\n          throw new errors.JWKSNoMatchingKey();\n\n        case 1:\n          // treat the call as if a Key instance was passed in\n          // skips iteration and avoids multi errors in this case\n          key = keys[0];\n          break;\n\n        default:\n          {\n            var _errs = [];\n\n            var _iterator = _createForOfIteratorHelper(keys),\n                _step;\n\n            try {\n              for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                var _key = _step.value;\n\n                try {\n                  return jwsVerify(true, serialization, jws, _key, {\n                    crit: crit,\n                    complete: complete,\n                    algorithms: algorithms ? _toConsumableArray(algorithms) : undefined\n                  });\n                } catch (err) {\n                  _errs.push(err);\n\n                  continue;\n                }\n              }\n            } catch (err) {\n              _iterator.e(err);\n            } finally {\n              _iterator.f();\n            }\n\n            var _multi = new errors.JOSEMultiError(_errs);\n\n            if (_toConsumableArray(_multi).some(function (e) {\n              return e instanceof errors.JWSVerificationFailed;\n            })) {\n              throw new errors.JWSVerificationFailed();\n            }\n\n            throw _multi;\n          }\n      }\n    }\n\n    if (key === JWK.EmbeddedJWK) {\n      if (!isObject(combinedHeader.jwk)) {\n        throw new errors.JWSInvalid('JWS Header Parameter \"jwk\" must be a JSON object');\n      }\n\n      key = JWK.asKey(combinedHeader.jwk);\n\n      if (key.type !== 'public') {\n        throw new errors.JWSInvalid('JWS Header Parameter \"jwk\" must be a public key');\n      }\n    } else if (key === JWK.EmbeddedX5C) {\n      if (!Array.isArray(combinedHeader.x5c) || !combinedHeader.x5c.length || combinedHeader.x5c.some(function (c) {\n        return typeof c !== 'string' || !c;\n      })) {\n        throw new errors.JWSInvalid('JWS Header Parameter \"x5c\" must be a JSON array of certificate value strings');\n      }\n\n      key = JWK.asKey(\"-----BEGIN CERTIFICATE-----\".concat(EOL).concat((combinedHeader.x5c[0].match(/.{1,64}/g) || []).join(EOL)).concat(EOL, \"-----END CERTIFICATE-----\"), {\n        x5c: combinedHeader.x5c\n      });\n    }\n\n    check(key, 'verify', alg);\n    var toBeVerified = Buffer.concat([Buffer.from(prot || ''), Buffer.from('.'), Buffer.isBuffer(payload) ? payload : Buffer.from(payload)]);\n\n    if (!verify(alg, key, toBeVerified, base64url.decodeToBuffer(signature))) {\n      throw new errors.JWSVerificationFailed();\n    }\n\n    if (combinedHeader.b64 === false) {\n      payload = Buffer.from(payload);\n    } else {\n      payload = base64url.decodeToBuffer(payload);\n    }\n\n    if (complete) {\n      var result = {\n        payload: payload,\n        key: key\n      };\n      if (prot) result.protected = parsedProt;\n      if (header) result.header = header;\n      return result;\n    }\n\n    return payload;\n  } // general serialization format\n\n\n  var _jws4 = jws,\n      signatures = _jws4.signatures,\n      root = _objectWithoutProperties(_jws4, [\"signatures\"]);\n\n  var errs = [];\n\n  var _iterator2 = _createForOfIteratorHelper(signatures),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var recipient = _step2.value;\n\n      try {\n        return jwsVerify(false, 'flattened', _objectSpread(_objectSpread({}, root), recipient), key, {\n          crit: crit,\n          complete: complete,\n          algorithms: algorithms ? _toConsumableArray(algorithms) : undefined\n        });\n      } catch (err) {\n        errs.push(err);\n        continue;\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  var multi = new errors.JOSEMultiError(errs);\n\n  if (_toConsumableArray(multi).some(function (e) {\n    return e instanceof errors.JWSVerificationFailed;\n  })) {\n    throw new errors.JWSVerificationFailed();\n  } else if (_toConsumableArray(multi).every(function (e) {\n    return e instanceof errors.JWKSNoMatchingKey;\n  })) {\n    throw new errors.JWKSNoMatchingKey();\n  }\n\n  throw multi;\n};\n\nmodule.exports = {\n  bare: jwsVerify,\n  verify: jwsVerify.bind(undefined, false, undefined)\n};","map":{"version":3,"sources":["/Users/suryanandsunil/Desktop/proto1-arizon/lyo-test/node_modules/jose/lib/jws/verify.js"],"names":["require","EOL","base64url","isDisjoint","isObject","validateCrit","getKey","KeyStore","errors","check","verify","JWK","resolveSerialization","detect","bind","undefined","JWSInvalid","SINGLE_RECIPIENT","Set","jwsVerify","skipDisjointCheck","serialization","jws","key","crit","complete","algorithms","Array","isArray","some","s","TypeError","prot","header","payload","signature","alg","signatures","length","root","decoded","has","parsedProt","split","protected","token","JSON","decode","err","combinedHeader","JOSEAlgNotWhitelisted","keystore","keys","all","kid","key_ops","JWKSNoMatchingKey","errs","push","multi","JOSEMultiError","e","JWSVerificationFailed","EmbeddedJWK","jwk","asKey","type","EmbeddedX5C","x5c","c","match","join","toBeVerified","Buffer","concat","from","isBuffer","decodeToBuffer","b64","result","recipient","every","module","exports","bare"],"mappings":"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","sourcesContent":["const { EOL } = require('os')\n\nconst base64url = require('../help/base64url')\nconst isDisjoint = require('../help/is_disjoint')\nconst isObject = require('../help/is_object')\nlet validateCrit = require('../help/validate_crit')\nconst getKey = require('../help/get_key')\nconst { KeyStore } = require('../jwks')\nconst errors = require('../errors')\nconst { check, verify } = require('../jwa')\nconst JWK = require('../jwk')\n\nconst { detect: resolveSerialization } = require('./serializers')\n\nvalidateCrit = validateCrit.bind(undefined, errors.JWSInvalid)\nconst SINGLE_RECIPIENT = new Set(['compact', 'flattened', 'preparsed'])\n\n/*\n * @public\n */\nconst jwsVerify = (skipDisjointCheck, serialization, jws, key, { crit = [], complete = false, algorithms } = {}) => {\n  key = getKey(key, true)\n\n  if (algorithms !== undefined && (!Array.isArray(algorithms) || algorithms.some(s => typeof s !== 'string' || !s))) {\n    throw new TypeError('\"algorithms\" option must be an array of non-empty strings')\n  } else if (algorithms) {\n    algorithms = new Set(algorithms)\n  }\n\n  if (!Array.isArray(crit) || crit.some(s => typeof s !== 'string' || !s)) {\n    throw new TypeError('\"crit\" option must be an array of non-empty strings')\n  }\n\n  if (!serialization) {\n    serialization = resolveSerialization(jws)\n  }\n\n  let prot // protected header\n  let header // unprotected header\n  let payload\n  let signature\n  let alg\n\n  // treat general format with one recipient as flattened\n  // skips iteration and avoids multi errors in this case\n  if (serialization === 'general' && jws.signatures.length === 1) {\n    serialization = 'flattened'\n    const { signatures, ...root } = jws\n    jws = { ...root, ...signatures[0] }\n  }\n\n  let decoded\n\n  if (SINGLE_RECIPIENT.has(serialization)) {\n    let parsedProt = {}\n\n    switch (serialization) {\n      case 'compact': // compact serialization format\n        ([prot, payload, signature] = jws.split('.'))\n        break\n      case 'flattened': // flattened serialization format\n        ({ protected: prot, payload, signature, header } = jws)\n        break\n      case 'preparsed': { // from the JWT module\n        ({ decoded } = jws);\n        ([prot, payload, signature] = jws.token.split('.'))\n        break\n      }\n    }\n\n    if (!header) {\n      skipDisjointCheck = true\n    }\n\n    if (decoded) {\n      parsedProt = decoded.header\n    } else if (prot) {\n      try {\n        parsedProt = base64url.JSON.decode(prot)\n      } catch (err) {\n        throw new errors.JWSInvalid('could not parse JWS protected header')\n      }\n    } else {\n      skipDisjointCheck = skipDisjointCheck || true\n    }\n\n    if (!skipDisjointCheck && !isDisjoint(parsedProt, header)) {\n      throw new errors.JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint')\n    }\n\n    const combinedHeader = { ...parsedProt, ...header }\n    validateCrit(parsedProt, header, crit)\n\n    alg = parsedProt.alg || (header && header.alg)\n    if (!alg) {\n      throw new errors.JWSInvalid('missing JWS signature algorithm')\n    } else if (algorithms && !algorithms.has(alg)) {\n      throw new errors.JOSEAlgNotWhitelisted('alg not whitelisted')\n    }\n\n    if (key instanceof KeyStore) {\n      const keystore = key\n      const keys = keystore.all({ kid: combinedHeader.kid, alg: combinedHeader.alg, key_ops: ['verify'] })\n      switch (keys.length) {\n        case 0:\n          throw new errors.JWKSNoMatchingKey()\n        case 1:\n          // treat the call as if a Key instance was passed in\n          // skips iteration and avoids multi errors in this case\n          key = keys[0]\n          break\n        default: {\n          const errs = []\n          for (const key of keys) {\n            try {\n              return jwsVerify(true, serialization, jws, key, { crit, complete, algorithms: algorithms ? [...algorithms] : undefined })\n            } catch (err) {\n              errs.push(err)\n              continue\n            }\n          }\n\n          const multi = new errors.JOSEMultiError(errs)\n          if ([...multi].some(e => e instanceof errors.JWSVerificationFailed)) {\n            throw new errors.JWSVerificationFailed()\n          }\n          throw multi\n        }\n      }\n    }\n\n    if (key === JWK.EmbeddedJWK) {\n      if (!isObject(combinedHeader.jwk)) {\n        throw new errors.JWSInvalid('JWS Header Parameter \"jwk\" must be a JSON object')\n      }\n      key = JWK.asKey(combinedHeader.jwk)\n      if (key.type !== 'public') {\n        throw new errors.JWSInvalid('JWS Header Parameter \"jwk\" must be a public key')\n      }\n    } else if (key === JWK.EmbeddedX5C) {\n      if (!Array.isArray(combinedHeader.x5c) || !combinedHeader.x5c.length || combinedHeader.x5c.some(c => typeof c !== 'string' || !c)) {\n        throw new errors.JWSInvalid('JWS Header Parameter \"x5c\" must be a JSON array of certificate value strings')\n      }\n      key = JWK.asKey(\n        `-----BEGIN CERTIFICATE-----${EOL}${(combinedHeader.x5c[0].match(/.{1,64}/g) || []).join(EOL)}${EOL}-----END CERTIFICATE-----`,\n        { x5c: combinedHeader.x5c }\n      )\n    }\n\n    check(key, 'verify', alg)\n\n    const toBeVerified = Buffer.concat([\n      Buffer.from(prot || ''),\n      Buffer.from('.'),\n      Buffer.isBuffer(payload) ? payload : Buffer.from(payload)\n    ])\n\n    if (!verify(alg, key, toBeVerified, base64url.decodeToBuffer(signature))) {\n      throw new errors.JWSVerificationFailed()\n    }\n\n    if (combinedHeader.b64 === false) {\n      payload = Buffer.from(payload)\n    } else {\n      payload = base64url.decodeToBuffer(payload)\n    }\n\n    if (complete) {\n      const result = { payload, key }\n      if (prot) result.protected = parsedProt\n      if (header) result.header = header\n      return result\n    }\n\n    return payload\n  }\n\n  // general serialization format\n  const { signatures, ...root } = jws\n  const errs = []\n  for (const recipient of signatures) {\n    try {\n      return jwsVerify(false, 'flattened', { ...root, ...recipient }, key, { crit, complete, algorithms: algorithms ? [...algorithms] : undefined })\n    } catch (err) {\n      errs.push(err)\n      continue\n    }\n  }\n\n  const multi = new errors.JOSEMultiError(errs)\n  if ([...multi].some(e => e instanceof errors.JWSVerificationFailed)) {\n    throw new errors.JWSVerificationFailed()\n  } else if ([...multi].every(e => e instanceof errors.JWKSNoMatchingKey)) {\n    throw new errors.JWKSNoMatchingKey()\n  }\n  throw multi\n}\n\nmodule.exports = {\n  bare: jwsVerify,\n  verify: jwsVerify.bind(undefined, false, undefined)\n}\n"]},"metadata":{},"sourceType":"script"}