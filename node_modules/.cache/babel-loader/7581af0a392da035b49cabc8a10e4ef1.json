{"ast":null,"code":"\"use strict\"; // Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nvar _regeneratorRuntime = require(\"/Users/suryanandsunil/Desktop/proto1-arizon/lyo-test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/suryanandsunil/Desktop/proto1-arizon/lyo-test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _createForOfIteratorHelper = require(\"/Users/suryanandsunil/Desktop/proto1-arizon/lyo-test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"/Users/suryanandsunil/Desktop/proto1-arizon/lyo-test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/suryanandsunil/Desktop/proto1-arizon/lyo-test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _get = require(\"/Users/suryanandsunil/Desktop/proto1-arizon/lyo-test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"/Users/suryanandsunil/Desktop/proto1-arizon/lyo-test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"/Users/suryanandsunil/Desktop/proto1-arizon/lyo-test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/suryanandsunil/Desktop/proto1-arizon/lyo-test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DownscopedClient = exports.EXPIRATION_TIME_OFFSET = void 0;\n\nvar authclient_1 = require(\"./authclient\");\n\nvar sts = require(\"./stscredentials\");\n/**\n * The required token exchange grant_type: rfc8693#section-2.1\n */\n\n\nvar STS_GRANT_TYPE = 'urn:ietf:params:oauth:grant-type:token-exchange';\n/**\n * The requested token exchange requested_token_type: rfc8693#section-2.1\n */\n\nvar STS_REQUEST_TOKEN_TYPE = 'urn:ietf:params:oauth:token-type:access_token';\n/**\n * The requested token exchange subject_token_type: rfc8693#section-2.1\n */\n\nvar STS_SUBJECT_TOKEN_TYPE = 'urn:ietf:params:oauth:token-type:access_token';\n/** The STS access token exchange end point. */\n\nvar STS_ACCESS_TOKEN_URL = 'https://sts.googleapis.com/v1beta/token';\n/**\n * Offset to take into account network delays and server clock skews.\n */\n\nexports.EXPIRATION_TIME_OFFSET = 5 * 60 * 1000;\n\nvar DownscopedClient = /*#__PURE__*/function (_authclient_1$AuthCli) {\n  _inherits(DownscopedClient, _authclient_1$AuthCli);\n\n  var _super = _createSuper(DownscopedClient);\n\n  function DownscopedClient(client, cab, additionalOptions) {\n    var _this;\n\n    _classCallCheck(this, DownscopedClient);\n\n    _this = _super.call(this);\n    _this.client = client;\n    _this.cab = cab; // Check a number of 1-10 access boundary rules are defined within credential access boundary.\n\n    if (cab.accessBoundary.accessBoundaryRules.length === 0) {\n      throw new Error('At least one access boundary rule needs to be defined.');\n    } else if (cab.accessBoundary.accessBoundaryRules.length > 10) {\n      throw new Error('Access boundary rule exceeds limit, max 10 allowed.');\n    } // Check at least one permission should be defined in each access boundary rule.\n\n\n    var _iterator = _createForOfIteratorHelper(cab.accessBoundary.accessBoundaryRules),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var rule = _step.value;\n\n        if (rule.availablePermissions.length === 0) {\n          throw new Error('At least one permission should be defined in access boundary rules.');\n        }\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    _this.stsCredential = new sts.StsCredentials(STS_ACCESS_TOKEN_URL); // Default OAuth scope. This could be overridden via public property.\n\n    _this.cachedDownscopedAccessToken = null;\n    _this.credentialAccessBoundary = cab;\n    _this.authClient = client; // As threshold could be zero,\n    // eagerRefreshThresholdMillis || EXPIRATION_TIME_OFFSET will override the\n    // zero value.\n\n    if (typeof (additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.eagerRefreshThresholdMillis) !== 'number') {\n      _this.eagerRefreshThresholdMillis = exports.EXPIRATION_TIME_OFFSET;\n    } else {\n      _this.eagerRefreshThresholdMillis = additionalOptions.eagerRefreshThresholdMillis;\n    }\n\n    _this.forceRefreshOnFailure = !!(additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.forceRefreshOnFailure);\n    return _this;\n  }\n  /**\n   * Provides a mechanism to inject Downscoped access tokens directly.\n   * When the provided credential expires, a new credential, using the\n   * external account options are retrieved.\n   * Notice DownscopedClient is the broker class mainly used for generate\n   * downscoped access tokens, it is unlikely we call this function in real\n   * use case.\n   * We implement to make this a helper function for testing all cases in getAccessToken().\n   * @param credentials The Credentials object to set on the current client.\n   */\n\n\n  _createClass(DownscopedClient, [{\n    key: \"setCredentials\",\n    value: function setCredentials(credentials) {\n      _get(_getPrototypeOf(DownscopedClient.prototype), \"setCredentials\", this).call(this, credentials);\n\n      this.cachedDownscopedAccessToken = credentials;\n    }\n  }, {\n    key: \"getAccessToken\",\n    value: function () {\n      var _getAccessToken = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!(!this.cachedDownscopedAccessToken || this.isExpired(this.cachedDownscopedAccessToken))) {\n                  _context.next = 3;\n                  break;\n                }\n\n                _context.next = 3;\n                return this.refreshAccessTokenAsync();\n\n              case 3:\n                return _context.abrupt(\"return\", {\n                  token: this.cachedDownscopedAccessToken.access_token,\n                  res: this.cachedDownscopedAccessToken.res\n                });\n\n              case 4:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function getAccessToken() {\n        return _getAccessToken.apply(this, arguments);\n      }\n\n      return getAccessToken;\n    }()\n    /**\n     * The main authentication interface. It takes an optional url which when\n     * present is the endpoint> being accessed, and returns a Promise which\n     * resolves with authorization header fields.\n     *\n     * The result has the form:\n     * { Authorization: 'Bearer <access_token_value>' }\n     */\n\n  }, {\n    key: \"getRequestHeaders\",\n    value: function () {\n      var _getRequestHeaders = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                throw new Error('Not implemented.');\n\n              case 1:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2);\n      }));\n\n      function getRequestHeaders() {\n        return _getRequestHeaders.apply(this, arguments);\n      }\n\n      return getRequestHeaders;\n    }()\n  }, {\n    key: \"request\",\n    value: function request(opts, callback) {\n      throw new Error('Not implemented.');\n    }\n    /**\n     * Forces token refresh, even if unexpired tokens are currently cached.\n     * GCP access tokens are retrieved from authclient object/source credential.\n     * Thenm GCP access tokens are exchanged for downscoped access tokens via the\n     * token exchange endpoint.\n     * @return A promise that resolves with the fresh downscoped access token.\n     */\n\n  }, {\n    key: \"refreshAccessTokenAsync\",\n    value: function () {\n      var _refreshAccessTokenAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var subjectToken, stsCredentialsOptions, stsResponse;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return this.authClient.getAccessToken();\n\n              case 2:\n                _context3.next = 4;\n                return _context3.sent.token;\n\n              case 4:\n                subjectToken = _context3.sent;\n                // Construct the STS credentials options.\n                stsCredentialsOptions = {\n                  grantType: STS_GRANT_TYPE,\n                  requestedTokenType: STS_REQUEST_TOKEN_TYPE,\n                  subjectToken: subjectToken,\n                  subjectTokenType: STS_SUBJECT_TOKEN_TYPE\n                }; // Exchange the source access token for a Downscoped access token.\n\n                _context3.next = 8;\n                return this.stsCredential.exchangeToken(stsCredentialsOptions, undefined, this.credentialAccessBoundary);\n\n              case 8:\n                stsResponse = _context3.sent;\n                // Save response in cached access token.\n                this.cachedDownscopedAccessToken = {\n                  access_token: stsResponse.access_token,\n                  expiry_date: new Date().getTime() + stsResponse.expires_in * 1000,\n                  res: stsResponse.res\n                }; // Save credentials.\n\n                this.credentials = {};\n                Object.assign(this.credentials, this.cachedDownscopedAccessToken);\n                delete this.credentials.res; // Trigger tokens event to notify external listeners.\n\n                this.emit('tokens', {\n                  refresh_token: null,\n                  expiry_date: this.cachedDownscopedAccessToken.expiry_date,\n                  access_token: this.cachedDownscopedAccessToken.access_token,\n                  token_type: 'Bearer',\n                  id_token: null\n                }); // Return the cached access token.\n\n                return _context3.abrupt(\"return\", this.cachedDownscopedAccessToken);\n\n              case 15:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function refreshAccessTokenAsync() {\n        return _refreshAccessTokenAsync.apply(this, arguments);\n      }\n\n      return refreshAccessTokenAsync;\n    }()\n    /**\n     * Returns whether the provided credentials are expired or not.\n     * If there is no expiry time, assumes the token is not expired or expiring.\n     * @param downscopedAccessToken The credentials to check for expiration.\n     * @return Whether the credentials are expired or not.\n     */\n\n  }, {\n    key: \"isExpired\",\n    value: function isExpired(downscopedAccessToken) {\n      var now = new Date().getTime();\n      return downscopedAccessToken.expiry_date ? now >= downscopedAccessToken.expiry_date - this.eagerRefreshThresholdMillis : false;\n    }\n  }]);\n\n  return DownscopedClient;\n}(authclient_1.AuthClient);\n\nexports.DownscopedClient = DownscopedClient;","map":{"version":3,"sources":["/Users/suryanandsunil/Desktop/proto1-arizon/lyo-test/node_modules/@google-cloud/common/node_modules/google-auth-library/build/src/auth/downscopedclient.js"],"names":["Object","defineProperty","exports","value","DownscopedClient","EXPIRATION_TIME_OFFSET","authclient_1","require","sts","STS_GRANT_TYPE","STS_REQUEST_TOKEN_TYPE","STS_SUBJECT_TOKEN_TYPE","STS_ACCESS_TOKEN_URL","client","cab","additionalOptions","accessBoundary","accessBoundaryRules","length","Error","rule","availablePermissions","stsCredential","StsCredentials","cachedDownscopedAccessToken","credentialAccessBoundary","authClient","eagerRefreshThresholdMillis","forceRefreshOnFailure","credentials","isExpired","refreshAccessTokenAsync","token","access_token","res","opts","callback","getAccessToken","subjectToken","stsCredentialsOptions","grantType","requestedTokenType","subjectTokenType","exchangeToken","undefined","stsResponse","expiry_date","Date","getTime","expires_in","assign","emit","refresh_token","token_type","id_token","downscopedAccessToken","now","AuthClient"],"mappings":"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","sourcesContent":["\"use strict\";\n// Copyright 2021 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DownscopedClient = exports.EXPIRATION_TIME_OFFSET = void 0;\nconst authclient_1 = require(\"./authclient\");\nconst sts = require(\"./stscredentials\");\n/**\n * The required token exchange grant_type: rfc8693#section-2.1\n */\nconst STS_GRANT_TYPE = 'urn:ietf:params:oauth:grant-type:token-exchange';\n/**\n * The requested token exchange requested_token_type: rfc8693#section-2.1\n */\nconst STS_REQUEST_TOKEN_TYPE = 'urn:ietf:params:oauth:token-type:access_token';\n/**\n * The requested token exchange subject_token_type: rfc8693#section-2.1\n */\nconst STS_SUBJECT_TOKEN_TYPE = 'urn:ietf:params:oauth:token-type:access_token';\n/** The STS access token exchange end point. */\nconst STS_ACCESS_TOKEN_URL = 'https://sts.googleapis.com/v1beta/token';\n/**\n * Offset to take into account network delays and server clock skews.\n */\nexports.EXPIRATION_TIME_OFFSET = 5 * 60 * 1000;\nclass DownscopedClient extends authclient_1.AuthClient {\n    constructor(client, cab, additionalOptions) {\n        super();\n        this.client = client;\n        this.cab = cab;\n        // Check a number of 1-10 access boundary rules are defined within credential access boundary.\n        if (cab.accessBoundary.accessBoundaryRules.length === 0) {\n            throw new Error('At least one access boundary rule needs to be defined.');\n        }\n        else if (cab.accessBoundary.accessBoundaryRules.length > 10) {\n            throw new Error('Access boundary rule exceeds limit, max 10 allowed.');\n        }\n        // Check at least one permission should be defined in each access boundary rule.\n        for (const rule of cab.accessBoundary.accessBoundaryRules) {\n            if (rule.availablePermissions.length === 0) {\n                throw new Error('At least one permission should be defined in access boundary rules.');\n            }\n        }\n        this.stsCredential = new sts.StsCredentials(STS_ACCESS_TOKEN_URL);\n        // Default OAuth scope. This could be overridden via public property.\n        this.cachedDownscopedAccessToken = null;\n        this.credentialAccessBoundary = cab;\n        this.authClient = client;\n        // As threshold could be zero,\n        // eagerRefreshThresholdMillis || EXPIRATION_TIME_OFFSET will override the\n        // zero value.\n        if (typeof (additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.eagerRefreshThresholdMillis) !== 'number') {\n            this.eagerRefreshThresholdMillis = exports.EXPIRATION_TIME_OFFSET;\n        }\n        else {\n            this.eagerRefreshThresholdMillis = additionalOptions\n                .eagerRefreshThresholdMillis;\n        }\n        this.forceRefreshOnFailure = !!(additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.forceRefreshOnFailure);\n    }\n    /**\n     * Provides a mechanism to inject Downscoped access tokens directly.\n     * When the provided credential expires, a new credential, using the\n     * external account options are retrieved.\n     * Notice DownscopedClient is the broker class mainly used for generate\n     * downscoped access tokens, it is unlikely we call this function in real\n     * use case.\n     * We implement to make this a helper function for testing all cases in getAccessToken().\n     * @param credentials The Credentials object to set on the current client.\n     */\n    setCredentials(credentials) {\n        super.setCredentials(credentials);\n        this.cachedDownscopedAccessToken = credentials;\n    }\n    async getAccessToken() {\n        // If the cached access token is unavailable or expired, force refresh.\n        // The Downscoped access token will be returned in GetAccessTokenResponse format.\n        // If cached access token is unavailable or expired, force refresh.\n        if (!this.cachedDownscopedAccessToken ||\n            this.isExpired(this.cachedDownscopedAccessToken)) {\n            await this.refreshAccessTokenAsync();\n        }\n        // Return Downscoped access token in GetAccessTokenResponse format.\n        return {\n            token: this.cachedDownscopedAccessToken.access_token,\n            res: this.cachedDownscopedAccessToken.res,\n        };\n    }\n    /**\n     * The main authentication interface. It takes an optional url which when\n     * present is the endpoint> being accessed, and returns a Promise which\n     * resolves with authorization header fields.\n     *\n     * The result has the form:\n     * { Authorization: 'Bearer <access_token_value>' }\n     */\n    async getRequestHeaders() {\n        throw new Error('Not implemented.');\n    }\n    request(opts, callback) {\n        throw new Error('Not implemented.');\n    }\n    /**\n     * Forces token refresh, even if unexpired tokens are currently cached.\n     * GCP access tokens are retrieved from authclient object/source credential.\n     * Thenm GCP access tokens are exchanged for downscoped access tokens via the\n     * token exchange endpoint.\n     * @return A promise that resolves with the fresh downscoped access token.\n     */\n    async refreshAccessTokenAsync() {\n        // Retrieve GCP access token from source credential.\n        const subjectToken = await (await this.authClient.getAccessToken()).token;\n        // Construct the STS credentials options.\n        const stsCredentialsOptions = {\n            grantType: STS_GRANT_TYPE,\n            requestedTokenType: STS_REQUEST_TOKEN_TYPE,\n            subjectToken: subjectToken,\n            subjectTokenType: STS_SUBJECT_TOKEN_TYPE,\n        };\n        // Exchange the source access token for a Downscoped access token.\n        const stsResponse = await this.stsCredential.exchangeToken(stsCredentialsOptions, undefined, this.credentialAccessBoundary);\n        // Save response in cached access token.\n        this.cachedDownscopedAccessToken = {\n            access_token: stsResponse.access_token,\n            expiry_date: new Date().getTime() + stsResponse.expires_in * 1000,\n            res: stsResponse.res,\n        };\n        // Save credentials.\n        this.credentials = {};\n        Object.assign(this.credentials, this.cachedDownscopedAccessToken);\n        delete this.credentials.res;\n        // Trigger tokens event to notify external listeners.\n        this.emit('tokens', {\n            refresh_token: null,\n            expiry_date: this.cachedDownscopedAccessToken.expiry_date,\n            access_token: this.cachedDownscopedAccessToken.access_token,\n            token_type: 'Bearer',\n            id_token: null,\n        });\n        // Return the cached access token.\n        return this.cachedDownscopedAccessToken;\n    }\n    /**\n     * Returns whether the provided credentials are expired or not.\n     * If there is no expiry time, assumes the token is not expired or expiring.\n     * @param downscopedAccessToken The credentials to check for expiration.\n     * @return Whether the credentials are expired or not.\n     */\n    isExpired(downscopedAccessToken) {\n        const now = new Date().getTime();\n        return downscopedAccessToken.expiry_date\n            ? now >=\n                downscopedAccessToken.expiry_date - this.eagerRefreshThresholdMillis\n            : false;\n    }\n}\nexports.DownscopedClient = DownscopedClient;\n//# sourceMappingURL=downscopedclient.js.map"]},"metadata":{},"sourceType":"script"}