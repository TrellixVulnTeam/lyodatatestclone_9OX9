{"ast":null,"code":"var _objectSpread = require(\"/Users/suryanandsunil/Desktop/proto1-arizon/lyo-test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _slicedToArray = require(\"/Users/suryanandsunil/Desktop/proto1-arizon/lyo-test/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar isObject = require('../help/is_object');\n\nvar validateCrit = require('../help/validate_crit');\n\nvar _require = require('../errors'),\n    JWSInvalid = _require.JWSInvalid;\n\nvalidateCrit = validateCrit.bind(undefined, JWSInvalid);\n\nvar compactSerializer = function compactSerializer(payload, _ref) {\n  var _ref2 = _slicedToArray(_ref, 1),\n      recipient = _ref2[0];\n\n  return \"\".concat(recipient.protected, \".\").concat(payload, \".\").concat(recipient.signature);\n};\n\ncompactSerializer.validate = function (jws, _ref3) {\n  var _ref3$ = _ref3[0],\n      unprotectedHeader = _ref3$.unprotectedHeader,\n      protectedHeader = _ref3$.protectedHeader,\n      length = _ref3.length;\n\n  if (length !== 1 || unprotectedHeader) {\n    throw new JWSInvalid('JWS Compact Serialization doesn\\'t support multiple recipients or JWS unprotected headers');\n  }\n\n  validateCrit(protectedHeader, unprotectedHeader, protectedHeader ? protectedHeader.crit : undefined);\n};\n\nvar flattenedSerializer = function flattenedSerializer(payload, _ref4) {\n  var _ref5 = _slicedToArray(_ref4, 1),\n      recipient = _ref5[0];\n\n  var header = recipient.header,\n      signature = recipient.signature,\n      prot = recipient.protected;\n  return _objectSpread(_objectSpread(_objectSpread({\n    payload: payload\n  }, prot ? {\n    protected: prot\n  } : undefined), header ? {\n    header: header\n  } : undefined), {}, {\n    signature: signature\n  });\n};\n\nflattenedSerializer.validate = function (jws, _ref6) {\n  var _ref6$ = _ref6[0],\n      unprotectedHeader = _ref6$.unprotectedHeader,\n      protectedHeader = _ref6$.protectedHeader,\n      length = _ref6.length;\n\n  if (length !== 1) {\n    throw new JWSInvalid('Flattened JWS JSON Serialization doesn\\'t support multiple recipients');\n  }\n\n  validateCrit(protectedHeader, unprotectedHeader, protectedHeader ? protectedHeader.crit : undefined);\n};\n\nvar generalSerializer = function generalSerializer(payload, recipients) {\n  return {\n    payload: payload,\n    signatures: recipients.map(function (_ref7) {\n      var header = _ref7.header,\n          signature = _ref7.signature,\n          prot = _ref7.protected;\n      return _objectSpread(_objectSpread(_objectSpread({}, prot ? {\n        protected: prot\n      } : undefined), header ? {\n        header: header\n      } : undefined), {}, {\n        signature: signature\n      });\n    })\n  };\n};\n\ngeneralSerializer.validate = function (jws, recipients) {\n  var validateB64 = false;\n  recipients.forEach(function (_ref8) {\n    var protectedHeader = _ref8.protectedHeader,\n        unprotectedHeader = _ref8.unprotectedHeader;\n\n    if (protectedHeader && !validateB64 && 'b64' in protectedHeader) {\n      validateB64 = true;\n    }\n\n    validateCrit(protectedHeader, unprotectedHeader, protectedHeader ? protectedHeader.crit : undefined);\n  });\n\n  if (validateB64) {\n    var values = recipients.map(function (_ref9) {\n      var protectedHeader = _ref9.protectedHeader;\n      return protectedHeader && protectedHeader.b64;\n    });\n\n    if (!values.every(function (actual, i, _ref10) {\n      var _ref11 = _slicedToArray(_ref10, 1),\n          expected = _ref11[0];\n\n      return actual === expected;\n    })) {\n      throw new JWSInvalid('the \"b64\" Header Parameter value MUST be the same for all recipients');\n    }\n  }\n};\n\nvar isJSON = function isJSON(input) {\n  return isObject(input) && (typeof input.payload === 'string' || Buffer.isBuffer(input.payload));\n};\n\nvar isValidRecipient = function isValidRecipient(recipient) {\n  return isObject(recipient) && typeof recipient.signature === 'string' && (recipient.header === undefined || isObject(recipient.header)) && (recipient.protected === undefined || typeof recipient.protected === 'string');\n};\n\nvar isMultiRecipient = function isMultiRecipient(input) {\n  if (Array.isArray(input.signatures) && input.signatures.every(isValidRecipient)) {\n    return true;\n  }\n\n  return false;\n};\n\nvar detect = function detect(input) {\n  if (typeof input === 'string' && input.split('.').length === 3) {\n    return 'compact';\n  }\n\n  if (isJSON(input)) {\n    if (isMultiRecipient(input)) {\n      return 'general';\n    }\n\n    if (isValidRecipient(input)) {\n      return 'flattened';\n    }\n  }\n\n  throw new JWSInvalid('JWS malformed or invalid serialization');\n};\n\nmodule.exports = {\n  compact: compactSerializer,\n  flattened: flattenedSerializer,\n  general: generalSerializer,\n  detect: detect\n};","map":{"version":3,"sources":["/Users/suryanandsunil/Desktop/proto1-arizon/lyo-test/node_modules/jose/lib/jws/serializers.js"],"names":["isObject","require","validateCrit","JWSInvalid","bind","undefined","compactSerializer","payload","recipient","protected","signature","validate","jws","unprotectedHeader","protectedHeader","length","crit","flattenedSerializer","header","prot","generalSerializer","recipients","signatures","map","validateB64","forEach","values","b64","every","actual","i","expected","isJSON","input","Buffer","isBuffer","isValidRecipient","isMultiRecipient","Array","isArray","detect","split","module","exports","compact","flattened","general"],"mappings":"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","sourcesContent":["const isObject = require('../help/is_object')\nlet validateCrit = require('../help/validate_crit')\nconst { JWSInvalid } = require('../errors')\n\nvalidateCrit = validateCrit.bind(undefined, JWSInvalid)\n\nconst compactSerializer = (payload, [recipient]) => {\n  return `${recipient.protected}.${payload}.${recipient.signature}`\n}\ncompactSerializer.validate = (jws, { 0: { unprotectedHeader, protectedHeader }, length }) => {\n  if (length !== 1 || unprotectedHeader) {\n    throw new JWSInvalid('JWS Compact Serialization doesn\\'t support multiple recipients or JWS unprotected headers')\n  }\n  validateCrit(protectedHeader, unprotectedHeader, protectedHeader ? protectedHeader.crit : undefined)\n}\n\nconst flattenedSerializer = (payload, [recipient]) => {\n  const { header, signature, protected: prot } = recipient\n\n  return {\n    payload,\n    ...prot ? { protected: prot } : undefined,\n    ...header ? { header } : undefined,\n    signature\n  }\n}\nflattenedSerializer.validate = (jws, { 0: { unprotectedHeader, protectedHeader }, length }) => {\n  if (length !== 1) {\n    throw new JWSInvalid('Flattened JWS JSON Serialization doesn\\'t support multiple recipients')\n  }\n  validateCrit(protectedHeader, unprotectedHeader, protectedHeader ? protectedHeader.crit : undefined)\n}\n\nconst generalSerializer = (payload, recipients) => {\n  return {\n    payload,\n    signatures: recipients.map(({ header, signature, protected: prot }) => {\n      return {\n        ...prot ? { protected: prot } : undefined,\n        ...header ? { header } : undefined,\n        signature\n      }\n    })\n  }\n}\ngeneralSerializer.validate = (jws, recipients) => {\n  let validateB64 = false\n  recipients.forEach(({ protectedHeader, unprotectedHeader }) => {\n    if (protectedHeader && !validateB64 && 'b64' in protectedHeader) {\n      validateB64 = true\n    }\n    validateCrit(protectedHeader, unprotectedHeader, protectedHeader ? protectedHeader.crit : undefined)\n  })\n\n  if (validateB64) {\n    const values = recipients.map(({ protectedHeader }) => protectedHeader && protectedHeader.b64)\n    if (!values.every((actual, i, [expected]) => actual === expected)) {\n      throw new JWSInvalid('the \"b64\" Header Parameter value MUST be the same for all recipients')\n    }\n  }\n}\n\nconst isJSON = (input) => {\n  return isObject(input) && (typeof input.payload === 'string' || Buffer.isBuffer(input.payload))\n}\n\nconst isValidRecipient = (recipient) => {\n  return isObject(recipient) && typeof recipient.signature === 'string' &&\n    (recipient.header === undefined || isObject(recipient.header)) &&\n    (recipient.protected === undefined || typeof recipient.protected === 'string')\n}\n\nconst isMultiRecipient = (input) => {\n  if (Array.isArray(input.signatures) && input.signatures.every(isValidRecipient)) {\n    return true\n  }\n\n  return false\n}\n\nconst detect = (input) => {\n  if (typeof input === 'string' && input.split('.').length === 3) {\n    return 'compact'\n  }\n\n  if (isJSON(input)) {\n    if (isMultiRecipient(input)) {\n      return 'general'\n    }\n\n    if (isValidRecipient(input)) {\n      return 'flattened'\n    }\n  }\n\n  throw new JWSInvalid('JWS malformed or invalid serialization')\n}\n\nmodule.exports = {\n  compact: compactSerializer,\n  flattened: flattenedSerializer,\n  general: generalSerializer,\n  detect\n}\n"]},"metadata":{},"sourceType":"script"}